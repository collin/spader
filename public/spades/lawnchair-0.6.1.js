minispade.register('lawnchair', "(function() {/**\n * Lawnchair!\n * --- \n * clientside json store \n *\n */\nvar Lawnchair = function (options, callback) {\n    // ensure Lawnchair was called as a constructor\n    if (!(this instanceof Lawnchair)) return new Lawnchair(options, callback);\n\n    // lawnchair requires json \n    if (!JSON) throw 'JSON unavailable! Include http://www.json.org/json2.js to fix.'\n    // options are optional; callback is not\n    if (arguments.length <= 2 && arguments.length > 0) {\n        callback = (typeof arguments[0] === 'function') ? arguments[0] : arguments[1];\n        options  = (typeof arguments[0] === 'function') ? {} : arguments[0];\n    } else {\n        throw 'Incorrect # of ctor args!'\n    }\n    // TODO perhaps allow for pub/sub instead?\n    if (typeof callback !== 'function') throw 'No callback was provided';\n    \n    // default configuration \n    this.record = options.record || 'record'  // default for records\n    this.name   = options.name   || 'records' // default name for underlying store\n    \n    // mixin first valid  adapter\n    var adapter\n    // if the adapter is passed in we try to load that only\n    if (options.adapter) {\n        for (var i = 0, l = Lawnchair.adapters.length; i < l; i++) {\n            if (Lawnchair.adapters[i].adapter === options.adapter) {\n              adapter = Lawnchair.adapters[i].valid() ? Lawnchair.adapters[i] : undefined;\n              break;\n            }\n        }\n    // otherwise find the first valid adapter for this env\n    } \n    else {\n        for (var i = 0, l = Lawnchair.adapters.length; i < l; i++) {\n            adapter = Lawnchair.adapters[i].valid() ? Lawnchair.adapters[i] : undefined\n            if (adapter) break \n        }\n    } \n    \n    // we have failed \n    if (!adapter) throw 'No valid adapter.' \n    \n    // yay! mixin the adapter \n    for (var j in adapter)  \n        this[j] = adapter[j]\n    \n    // call init for each mixed in plugin\n    for (var i = 0, l = Lawnchair.plugins.length; i < l; i++) \n        Lawnchair.plugins[i].call(this)\n\n    // init the adapter \n    this.init(options, callback)\n}\n\nLawnchair.adapters = [] \n\n/** \n * queues an adapter for mixin\n * ===\n * - ensures an adapter conforms to a specific interface\n *\n */\nLawnchair.adapter = function (id, obj) {\n    // add the adapter id to the adapter obj\n    // ugly here for a  cleaner dsl for implementing adapters\n    obj['adapter'] = id\n    // methods required to implement a lawnchair adapter \n    var implementing = 'adapter valid init keys save batch get exists all remove nuke'.split(' ')\n    ,   indexOf = this.prototype.indexOf\n    // mix in the adapter   \n    for (var i in obj) {\n        if (indexOf(implementing, i) === -1) throw 'Invalid adapter! Nonstandard method: ' + i\n    }\n    // if we made it this far the adapter interface is valid \n\t// insert the new adapter as the preferred adapter\n\tLawnchair.adapters.splice(0,0,obj)\n}\n\nLawnchair.plugins = []\n\n/**\n * generic shallow extension for plugins\n * ===\n * - if an init method is found it registers it to be called when the lawnchair is inited \n * - yes we could use hasOwnProp but nobody here is an asshole\n */ \nLawnchair.plugin = function (obj) {\n    for (var i in obj) \n        i === 'init' ? Lawnchair.plugins.push(obj[i]) : this.prototype[i] = obj[i]\n}\n\n/**\n * helpers\n *\n */\nLawnchair.prototype = {\n\n    isArray: Array.isArray || function(o) { return Object.prototype.toString.call(o) === '[object Array]' },\n    \n    /**\n     * this code exists for ie8... for more background see:\n     * http://www.flickr.com/photos/westcoastlogic/5955365742/in/photostream\n     */\n    indexOf: function(ary, item, i, l) {\n        if (ary.indexOf) return ary.indexOf(item)\n        for (i = 0, l = ary.length; i < l; i++) if (ary[i] === item) return i\n        return -1\n    },\n\n    // awesome shorthand callbacks as strings. this is shameless theft from dojo.\n    lambda: function (callback) {\n        return this.fn(this.record, callback)\n    },\n\n    // first stab at named parameters for terse callbacks; dojo: first != best // ;D\n    fn: function (name, callback) {\n        return typeof callback == 'string' ? new Function(name, callback) : callback\n    },\n\n    // returns a unique identifier (by way of Backbone.localStorage.js)\n    // TODO investigate smaller UUIDs to cut on storage cost\n    uuid: function () {\n        var S4 = function () {\n            return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n        }\n        return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n    },\n\n    // a classic iterator\n    each: function (callback) {\n        var cb = this.lambda(callback)\n        // iterate from chain\n        if (this.__results) {\n            for (var i = 0, l = this.__results.length; i < l; i++) cb.call(this, this.__results[i], i) \n        }  \n        // otherwise iterate the entire collection \n        else {\n            this.all(function(r) {\n                for (var i = 0, l = r.length; i < l; i++) cb.call(this, r[i], i)\n            })\n        }\n        return this\n    }\n// --\n};\n/**\n * dom storage adapter \n * === \n * - originally authored by Joseph Pecoraro\n *\n */ \n//\n// TODO does it make sense to be chainable all over the place?\n// chainable: nuke, remove, all, get, save, all    \n// not chainable: valid, keys\n//\nLawnchair.adapter('dom', (function() {\n    var storage = window.localStorage\n    // the indexer is an encapsulation of the helpers needed to keep an ordered index of the keys\n    var indexer = function(name) {\n        return {\n            // the key\n            key: name + '._index_',\n            // returns the index\n            all: function() {\n\t\t\t\tvar a  = storage.getItem(this.key)\n\t\t\t\tif (a) {\n\t\t\t\t\ta = JSON.parse(a)\n\t\t\t\t}\n                if (a === null) storage.setItem(this.key, JSON.stringify([])) // lazy init\n                return JSON.parse(storage.getItem(this.key))\n            },\n            // adds a key to the index\n            add: function (key) {\n                var a = this.all()\n                a.push(key)\n                storage.setItem(this.key, JSON.stringify(a))\n            },\n            // deletes a key from the index\n            del: function (key) {\n                var a = this.all(), r = []\n                // FIXME this is crazy inefficient but I'm in a strata meeting and half concentrating\n                for (var i = 0, l = a.length; i < l; i++) {\n                    if (a[i] != key) r.push(a[i])\n                }\n                storage.setItem(this.key, JSON.stringify(r))\n            },\n            // returns index for a key\n            find: function (key) {\n                var a = this.all()\n                for (var i = 0, l = a.length; i < l; i++) {\n                    if (key === a[i]) return i \n                }\n                return false\n            }\n        }\n    }\n    \n    // adapter api \n    return {\n    \n        // ensure we are in an env with localStorage \n        valid: function () {\n            return !!storage \n        },\n\n        init: function (options, callback) {\n            this.indexer = indexer(this.name)\n            if (callback) this.fn(this.name, callback).call(this, this)  \n        },\n        \n        save: function (obj, callback) {\n            var key = obj.key ? this.name + '.' + obj.key : this.name + '.' + this.uuid()\n            // if the key is not in the index push it on\n            if (this.indexer.find(key) === false) this.indexer.add(key)\n            // now we kil the key and use it in the store colleciton    \n            delete obj.key;\n            storage.setItem(key, JSON.stringify(obj))\n            obj.key = key.slice(this.name.length + 1)\n            if (callback) {\n                this.lambda(callback).call(this, obj)\n            }\n            return this\n        },\n\n        batch: function (ary, callback) {\n            var saved = []\n            // not particularily efficient but this is more for sqlite situations\n            for (var i = 0, l = ary.length; i < l; i++) {\n                this.save(ary[i], function(r){\n                    saved.push(r)\n                })\n            }\n            if (callback) this.lambda(callback).call(this, saved)\n            return this\n        },\n       \n        // accepts [options], callback\n        keys: function(callback) {\n            if (callback) { \n                var name = this.name\n                ,   keys = this.indexer.all().map(function(r){ return r.replace(name + '.', '') })\n                this.fn('keys', callback).call(this, keys)\n            }\n            return this // TODO options for limit/offset, return promise\n        },\n        \n        get: function (key, callback) {\n            if (this.isArray(key)) {\n                var r = []\n                for (var i = 0, l = key.length; i < l; i++) {\n                    var k = this.name + '.' + key[i]\n                    var obj = storage.getItem(k)\n                    if (obj) {\n\t\t\t\t\t\tobj = JSON.parse(obj)\n                        obj.key = key[i]\n                        r.push(obj)\n                    } \n                }\n                if (callback) this.lambda(callback).call(this, r)\n            } else {\n                var k = this.name + '.' + key\n                var  obj = storage.getItem(k)\n                if (obj) {\n\t\t\t\t\tobj = JSON.parse(obj)\n\t\t\t\t\tobj.key = key\n\t\t\t\t}\n                if (callback) this.lambda(callback).call(this, obj)\n            }\n            return this\n        },\n\n        exists: function (key, cb) {\n            var exists = this.indexer.find(this.name+'.'+key) === false ? false : true ;\n            this.lambda(cb).call(this, exists);\n            return this;\n        },\n        // NOTE adapters cannot set this.__results but plugins do\n        // this probably should be reviewed\n        all: function (callback) {\n            var idx = this.indexer.all()\n            ,   r   = []\n            ,   o\n            ,   k\n            for (var i = 0, l = idx.length; i < l; i++) {\n                k     = idx[i] //v\n                o     = JSON.parse(storage.getItem(k))\n                o.key = k.replace(this.name + '.', '')\n                r.push(o)\n            }\n            if (callback) this.fn(this.name, callback).call(this, r)\n            return this\n        },\n        \n        remove: function (keyOrObj, callback) {\n            var key = this.name + '.' + ((keyOrObj.key) ? keyOrObj.key : keyOrObj)\n            this.indexer.del(key)\n            storage.removeItem(key)\n            if (callback) this.lambda(callback).call(this)\n            return this\n        },\n        \n        nuke: function (callback) {\n            this.all(function(r) {\n                for (var i = 0, l = r.length; i < l; i++) {\n                    this.remove(r[i]);\n                }\n                if (callback) this.lambda(callback).call(this)\n            })\n            return this \n        }\n}})());\n// window.name code courtesy Remy Sharp: http://24ways.org/2009/breaking-out-the-edges-of-the-browser\nLawnchair.adapter('window-name', (function(index, store) {\n\n    var data = window.top.name ? JSON.parse(window.top.name) : {}\n\n    return {\n\n        valid: function () {\n            return typeof window.top.name != 'undefined' \n        },\n\n        init: function (options, callback) {\n            data[this.name] = data[this.name] || {index:[],store:{}}\n            index = data[this.name].index\n            store = data[this.name].store\n            this.fn(this.name, callback).call(this, this)\n        },\n\n        keys: function (callback) {\n            this.fn('keys', callback).call(this, index)\n            return this\n        },\n\n        save: function (obj, cb) {\n            // data[key] = value + ''; // force to string\n            // window.top.name = JSON.stringify(data);\n            var key = obj.key || this.uuid()\n            if (obj.key) delete obj.key \n            this.exists(key, function(exists) {\n                if (!exists) index.push(key)\n                store[key] = obj\n                window.top.name = JSON.stringify(data) // TODO wow, this is the only diff from the memory adapter\n                obj.key = key\n                if (cb) {\n                    this.lambda(cb).call(this, obj)\n                }\n            })\n            return this\n        },\n\n        batch: function (objs, cb) {\n            var r = []\n            for (var i = 0, l = objs.length; i < l; i++) {\n                this.save(objs[i], function(record) {\n                    r.push(record)\n                })\n            }\n            if (cb) this.lambda(cb).call(this, r)\n            return this\n        },\n        \n        get: function (keyOrArray, cb) {\n            var r;\n            if (this.isArray(keyOrArray)) {\n                r = []\n                for (var i = 0, l = keyOrArray.length; i < l; i++) {\n                    r.push(store[keyOrArray[i]]) \n                }\n            } else {\n                r = store[keyOrArray]\n                if (r) r.key = keyOrArray\n            }\n            if (cb) this.lambda(cb).call(this, r)\n            return this \n        },\n        \n        exists: function (key, cb) {\n            this.lambda(cb).call(this, !!(store[key]))\n            return this\n        },\n\n        all: function (cb) {\n            var r = []\n            for (var i = 0, l = index.length; i < l; i++) {\n                var obj = store[index[i]]\n                obj.key = index[i]\n                r.push(obj)\n            }\n            this.fn(this.name, cb).call(this, r)\n            return this\n        },\n        \n        remove: function (keyOrArray, cb) {\n            var del = this.isArray(keyOrArray) ? keyOrArray : [keyOrArray]\n            for (var i = 0, l = del.length; i < l; i++) {\n                delete store[del[i]]\n                index.splice(this.indexOf(index, del[i]), 1)\n            }\n            window.top.name = JSON.stringify(data)\n            if (cb) this.lambda(cb).call(this)\n            return this\n        },\n\n        nuke: function (cb) {\n            storage = {}\n            index = []\n            window.top.name = JSON.stringify(data)\n            if (cb) this.lambda(cb).call(this)\n            return this \n        }\n    }\n/////\n})())\n\n})();\n//@ sourceURL=lawnchair");