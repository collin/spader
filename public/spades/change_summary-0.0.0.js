minispade.register('change_summary', "(function() {// Copyright 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n(function(global) {\n  'use strict';\n\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var gotSplice = false;\n    function callback(records) {\n      if (records[0].type === 'splice' && records[1].type === 'splice')\n        gotSplice = true;\n    }\n\n    var test = [0];\n    Array.observe(test, callback);\n    test[1] = 1;\n    test.length = 0;\n    Object.deliverChangeRecords(callback);\n    return gotSplice;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  var hasEval = false;\n  try {\n    var f = new Function('', 'return true;');\n    hasEval = f();\n  } catch (ex) {\n  }\n\n  function isIndex(s) {\n    return +s === s >>> 0;\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function isNaN(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  }\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var ident = identStart + '+' + identPart + '*';\n  var elementIndex = '(?:[0-9]|[1-9]+[0-9]+)';\n  var identOrElementIndex = '(?:' + ident + '|' + elementIndex + ')';\n  var path = '(?:' + identOrElementIndex + ')(?:\\\\.' + identOrElementIndex + ')*';\n  var pathRegExp = new RegExp('^' + path + '$');\n\n  function isPathValid(s) {\n    if (typeof s != 'string')\n      return false;\n    s = s.replace(/\\s/g, '');\n\n    if (s == '')\n      return true;\n\n    if (s[0] == '.')\n      return false;\n\n    return pathRegExp.test(s);\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(str) {\n    var path = pathCache[str];\n    if (path)\n      return path;\n    if (!isPathValid(str))\n      return;\n    var path = new Path(str);\n    pathCache[str] = path;\n    return path;\n  }\n\n  function Path(s) {\n    if (s.trim() == '')\n      return this;\n\n    if (isIndex(s)) {\n      this.push(String(s));\n      return this;\n    }\n\n    s.split(/\\./).filter(function(part) {\n      return part;\n    }).forEach(function(part) {\n      this.push(part);\n    }, this);\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n\n    toString: function() {\n      return this.join('.');\n    },\n\n    getValueFrom: function(obj, allValues) {\n      for (var i = 0; i < this.length; i++) {\n        if (obj === undefined || obj === null)\n          return;\n        obj = obj[this[i]];\n      }\n\n      return obj;\n    },\n\n    getValueFromObserved: function(obj, observedSet) {\n      observedSet.reset();\n      for (var i = 0; i < this.length; i++) {\n        if (obj === undefined || obj === null) {\n          observedSet.cleanup();\n          return;\n        }\n        observedSet.observe(obj);\n        obj = obj[this[i]];\n      }\n\n      return obj;\n    },\n\n    compiledGetValueFromFn: function() {\n      var accessors = this.map(function(ident) {\n        return isIndex(ident) ? '[\"' + ident + '\"]' : '.' + ident;\n      });\n\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj !== null && obj !== undefined';\n      var i = 0;\n      for (; i < (this.length - 1); i++) {\n        var ident = this[i];\n        pathString += accessors[i];\n        str += ' &&\\n     ' + pathString + ' !== null && ' +\n               pathString + ' !== undefined';\n      }\n      str += ')\\n';\n\n      pathString += accessors[i];\n\n      str += '  return ' + pathString + ';\\nelse\\n  return undefined;';\n      return new Function('obj', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (obj === undefined || obj === null)\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (obj === undefined || obj === null)\n        return false;\n\n      obj[this[this.length - 1]] = value;\n      return true;\n    }\n  });\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check()) {\n      observer.report();\n      cycles++;\n    }\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n    var oldObjectHas = {};\n\n    for (var prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (var prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function copyObject(object, opt_copy) {\n    var copy = opt_copy || (Array.isArray(object) ? [] : {});\n    for (var prop in object) {\n      copy[prop] = object[prop];\n    };\n    if (Array.isArray(object))\n      copy.length = object.length;\n    return copy;\n  }\n\n  function Observer(object, callback, target, token) {\n    this.closed = false;\n    this.object = object;\n    this.callback = callback;\n    // TODO(rafaelw): Hold this.target weakly when WeakRef is available.\n    this.target = target;\n    this.token = token;\n    this.reporting = true;\n    if (hasObserve) {\n      var self = this;\n      this.boundInternalCallback = function(records) {\n        self.internalCallback(records);\n      };\n    }\n\n    addToAll(this);\n    this.connect();\n    this.sync(true);\n  }\n\n  Observer.prototype = {\n    internalCallback: function(records) {\n      if (this.closed)\n        return;\n      if (this.reporting && this.check(records)) {\n        this.report();\n        if (this.testingResults)\n          this.testingResults.anyChanged = true;\n      }\n    },\n\n    close: function() {\n      if (this.closed)\n        return;\n      if (this.object && typeof this.object.unobserved === 'function')\n        this.object.unobserved();\n\n      this.disconnect();\n      this.object = undefined;\n      this.closed = true;\n    },\n\n    deliver: function(testingResults) {\n      if (this.closed)\n        return;\n      if (hasObserve) {\n        this.testingResults = testingResults;\n        Object.deliverChangeRecords(this.boundInternalCallback);\n        this.testingResults = undefined;\n      } else {\n        dirtyCheck(this);\n      }\n    },\n\n    report: function() {\n      if (!this.reporting)\n        return;\n\n      this.sync(false);\n      this.reportArgs.push(this.token);\n      this.invokeCallback(this.reportArgs);\n      this.reportArgs = undefined;\n    },\n\n    invokeCallback: function(args) {\n      try {\n        this.callback.apply(this.target, args);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' + ex);\n      }\n    },\n\n    reset: function() {\n      if (this.closed)\n        return;\n\n      if (hasObserve) {\n        this.reporting = false;\n        Object.deliverChangeRecords(this.boundInternalCallback);\n        this.reporting = true;\n      }\n\n      this.sync(true);\n    }\n  }\n\n  var collectObservers = !hasObserve || global.forceCollectObservers;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n    Observer._allObserversCount++;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  var hasDebugForceFullDelivery = typeof Object.deliverAllChangeRecords == 'function';\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (hasDebugForceFullDelivery) {\n      Object.deliverAllChangeRecords();\n      return;\n    }\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var results = {};\n\n    do {\n      cycles++;\n      var toCheck = allObservers;\n      allObservers = [];\n      results.anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.closed)\n          continue;\n\n        if (hasObserve) {\n          observer.deliver(results);\n        } else if (observer.check()) {\n          results.anyChanged = true;\n          observer.report();\n        }\n\n        allObservers.push(observer);\n      }\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && results.anyChanged);\n\n    Observer._allObserversCount = allObservers.length;\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object, callback, target, token) {\n    Observer.call(this, object, callback, target, token);\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect: function() {\n      if (hasObserve)\n        Object.observe(this.object, this.boundInternalCallback);\n    },\n\n    sync: function(hard) {\n      if (!hasObserve)\n        this.oldObject = copyObject(this.object);\n    },\n\n    check: function(changeRecords) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.object, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject;\n        diff = diffObjectFromOldObject(this.object, this.oldObject);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      this.reportArgs =\n          [diff.added || {}, diff.removed || {}, diff.changed || {}];\n      this.reportArgs.push(function(property) {\n        return oldValues[property];\n      });\n\n      return true;\n    },\n\n    disconnect: function() {\n      if (!hasObserve)\n        this.oldObject = undefined;\n      else if (this.object)\n        Object.unobserve(this.object, this.boundInternalCallback);\n    }\n  });\n\n  function ArrayObserver(array, callback, target, token) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    Observer.call(this, array, callback, target, token);\n  }\n\n  ArrayObserver.prototype = createObject({\n    __proto__: ObjectObserver.prototype,\n\n    connect: function() {\n      if (hasObserve)\n        Array.observe(this.object, this.boundInternalCallback);\n    },\n\n    sync: function() {\n      if (!hasObserve)\n        this.oldObject = this.object.slice();\n    },\n\n    check: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.object, changeRecords);\n      } else {\n        splices = calcSplices(this.object, 0, this.object.length,\n                              this.oldObject, 0, this.oldObject.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      this.reportArgs = [splices];\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function getPathValue(object, path) {\n    return path.getValueFrom(object);\n  }\n\n  function ObservedSet(callback) {\n    this.arr = [];\n    this.callback = callback;\n    this.isObserved = true;\n  }\n\n  var objProto = Object.getPrototypeOf({});\n  var arrayProto = Object.getPrototypeOf([]);\n  ObservedSet.prototype = {\n    reset: function() {\n      this.isObserved = !this.isObserved;\n    },\n\n    observe: function(obj) {\n      if (!isObject(obj) || obj === objProto || obj === arrayProto)\n        return;\n      var i = this.arr.indexOf(obj);\n      if (i >= 0 && this.arr[i+1] === this.isObserved)\n        return;\n\n      if (i < 0) {\n        i = this.arr.length;\n        this.arr[i] = obj;\n        Object.observe(obj, this.callback);\n      }\n\n      this.arr[i+1] = this.isObserved;\n      this.observe(Object.getPrototypeOf(obj));\n    },\n\n    cleanup: function() {\n      var i = 0, j = 0;\n      var isObserved = this.isObserved;\n      while(j < this.arr.length) {\n        var obj = this.arr[j];\n        if (this.arr[j + 1] == isObserved) {\n          if (i < j) {\n            this.arr[i] = obj;\n            this.arr[i + 1] = isObserved;\n          }\n          i += 2;\n        } else {\n          Object.unobserve(obj, this.callback);\n        }\n        j += 2;\n      }\n\n      this.arr.length = i;\n    }\n  };\n\n  function PathObserver(object, pathString, callback, target, token) {\n    this.value = undefined;\n\n    var path = getPath(pathString);\n    if (!path) {\n      this.closed = true;\n      this.value = undefined;\n      return;\n    }\n\n    if (!path.length) {\n      this.closed = true;\n      this.value = object;\n      return;\n    }\n\n    if (!isObject(object)) {\n      this.closed = true;\n      this.value = undefined;\n      return;\n    }\n\n    this.path = path;\n    Observer.call(this, object, callback, target, token);\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect: function() {\n      if (hasObserve)\n        this.observedSet = new ObservedSet(this.boundInternalCallback);\n    },\n\n    disconnect: function() {\n      this.value = undefined;\n      if (hasObserve) {\n        this.observedSet.reset();\n        this.observedSet.cleanup();\n        this.observedSet = undefined;\n      }\n    },\n\n    check: function() {\n      this.value = !hasObserve ? this.path.getValueFrom(this.object) :\n          this.path.getValueFromObserved(this.object, this.observedSet);\n      if (areSameValue(this.value, this.oldValue))\n        return false;\n\n      this.reportArgs = [this.value, this.oldValue];\n      return true;\n    },\n\n    sync: function(hard) {\n      if (hard) {\n        this.value = !hasObserve ? this.path.getValueFrom(this.object) :\n            this.path.getValueFromObserved(this.object, this.observedSet);\n      }\n      this.oldValue = this.value;\n    }\n  });\n\n  PathObserver.getValueAtPath = function(obj, pathString) {\n    var path = getPath(pathString);\n    if (!path)\n      return;\n    return path.getValueFrom(obj);\n  }\n\n  PathObserver.setValueAtPath = function(obj, pathString, value) {\n    var path = getPath(pathString);\n    if (!path)\n      return;\n\n    path.setValueFrom(obj, value);\n  };\n\n  var knownRecordTypes = {\n    'new': true,\n    'updated': true,\n    'deleted': true\n  };\n\n  function notifyFunction(object, name) {\n    if (typeof Object.observe !== 'function')\n      return;\n\n    var notifier = Object.getNotifier(object);\n    return function(type, oldValue) {\n      var changeRecord = {\n        object: object,\n        type: type,\n        name: name\n      };\n      if (arguments.length === 2)\n        changeRecord.oldValue = oldValue;\n      notifier.notify(changeRecord);\n    }\n  }\n\n  // TODO(rafaelw): It should be possible for the Object.observe case to have\n  // every PathObserver used by defineProperty share a single Object.observe\n  // callback, and thus get() can simply call observer.deliver() and any changes\n  // to any dependent value will be observed.\n  PathObserver.defineProperty = function(object, name, descriptor) {\n    // TODO(rafaelw): Validate errors\n    var obj = descriptor.object;\n    var path = getPath(descriptor.path);\n    var notify = notifyFunction(object, name);\n\n    var observer = new PathObserver(obj, descriptor.path,\n        function(newValue, oldValue) {\n          if (notify)\n            notify('updated', oldValue);\n        }\n    );\n\n    Object.defineProperty(object, name, {\n      get: function() {\n        return path.getValueFrom(obj);\n      },\n      set: function(newValue) {\n        path.setValueFrom(obj, newValue);\n      },\n      configurable: true\n    });\n\n    return {\n      close: function() {\n        var oldValue = path.getValueFrom(obj);\n        if (notify)\n          observer.deliver();\n        observer.close();\n        Object.defineProperty(object, name, {\n          value: oldValue,\n          writable: true,\n          configurable: true\n        });\n      }\n    };\n  }\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!knownRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'updated')\n        continue;\n\n      if (record.type == 'new') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'deleted'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    for (var prop in added)\n      added[prop] = object[prop];\n\n    for (var prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (var prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  // Note: This function is *based* on the computation of the Levenshtein\n  // \"edit\" distance. The one change is that \"updates\" are treated as two\n  // edits - not one. With Array splices, an update is really a delete\n  // followed by an add. By retaining this, we optimize for \"keeping\" the\n  // maximum array items in the original array. For example:\n  //\n  //   'xxxx123' -> '123yyyy'\n  //\n  // With 1-edit updates, the shortest path would be just to update all seven\n  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n  // leaves the substring '123' intact.\n  function calcEditDistances(current, currentStart, currentEnd,\n                             old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    var rowCount = oldEnd - oldStart + 1;\n    var columnCount = currentEnd - currentStart + 1;\n    var distances = new Array(rowCount);\n\n    // \"Addition\" rows. Initialize null column.\n    for (var i = 0; i < rowCount; i++) {\n      distances[i] = new Array(columnCount);\n      distances[i][0] = i;\n    }\n\n    // Initialize null row\n    for (var j = 0; j < columnCount; j++)\n      distances[0][j] = j;\n\n    for (var i = 1; i < rowCount; i++) {\n      for (var j = 1; j < columnCount; j++) {\n        if (old[oldStart + i - 1] === current[currentStart + j - 1])\n          distances[i][j] = distances[i - 1][j - 1];\n        else {\n          var north = distances[i - 1][j] + 1;\n          var west = distances[i][j - 1] + 1;\n          distances[i][j] = north < west ? north : west;\n        }\n      }\n    }\n\n    return distances;\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  // This starts at the final weight, and walks \"backward\" by finding\n  // the minimum previous weight recursively until the origin of the weight\n  // matrix.\n  function spliceOperationsFromEditDistances(distances) {\n    var i = distances.length - 1;\n    var j = distances[0].length - 1;\n    var current = distances[i][j];\n    var edits = [];\n    while (i > 0 || j > 0) {\n      if (i == 0) {\n        edits.push(EDIT_ADD);\n        j--;\n        continue;\n      }\n      if (j == 0) {\n        edits.push(EDIT_DELETE);\n        i--;\n        continue;\n      }\n      var northWest = distances[i - 1][j - 1];\n      var west = distances[i - 1][j];\n      var north = distances[i][j - 1];\n\n      var min;\n      if (west < north)\n        min = west < northWest ? west : northWest;\n      else\n        min = north < northWest ? north : northWest;\n\n      if (min == northWest) {\n        if (northWest == current) {\n          edits.push(EDIT_LEAVE);\n        } else {\n          edits.push(EDIT_UPDATE);\n          current = northWest;\n        }\n        i--;\n        j--;\n      } else if (min == west) {\n        edits.push(EDIT_DELETE);\n        i--;\n        current = west;\n      } else {\n        edits.push(EDIT_ADD);\n        j--;\n        current = north;\n      }\n    }\n\n    edits.reverse();\n    return edits;\n  }\n\n  function sharedPrefix(arr1, arr2, searchLength) {\n    for (var i = 0; i < searchLength; i++)\n      if (arr1[i] !== arr2[i])\n        return i;\n    return searchLength;\n  }\n\n  function sharedSuffix(arr1, arr2, searchLength) {\n    var index1 = arr1.length;\n    var index2 = arr2.length;\n    var count = 0;\n    while (count < searchLength && arr1[--index1] === arr2[--index2])\n      count++;\n\n    return count;\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  /**\n   * Splice Projection functions:\n   *\n   * A splice map is a representation of how a previous array of items\n   * was transformed into a new array of items. Conceptually it is a list of\n   * tuples of\n   *\n   *   <index, removed, addedCount>\n   *\n   * which are kept in ascending index order of. The tuple represents that at\n   * the |index|, |removed| sequence of items were removed, and counting forward\n   * from |index|, |addedCount| items were added.\n   */\n\n  /**\n   * Lacking individual splice mutation information, the minimal set of\n   * splices can be synthesized given the previous state and final state of an\n   * array. The basic approach is to calculate the edit distance matrix and\n   * choose the shortest path through it.\n   *\n   * Complexity: O(l * p)\n   *   l: The length of the current array\n   *   p: The length of the old array\n   */\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    var prefixCount = 0;\n    var suffixCount = 0;\n\n    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n    if (currentStart == 0 && oldStart == 0)\n      prefixCount = sharedPrefix(current, old, minLength);\n\n    if (currentEnd == current.length && oldEnd == old.length)\n      suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n\n    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n      return [];\n\n    if (currentStart == currentEnd) {\n      var splice = newSplice(currentStart, [], 0);\n      while (oldStart < oldEnd)\n        splice.removed.push(old[oldStart++]);\n\n      return [ splice ];\n    } else if (oldStart == oldEnd)\n      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n    var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd,\n                                           old, oldStart, oldEnd));\n\n    var splice = undefined;\n    var splices = [];\n    var index = currentStart;\n    var oldIndex = oldStart;\n    for (var i = 0; i < ops.length; i++) {\n      switch(ops[i]) {\n        case EDIT_LEAVE:\n          if (splice) {\n            splices.push(splice);\n            splice = undefined;\n          }\n\n          index++;\n          oldIndex++;\n          break;\n        case EDIT_UPDATE:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n        case EDIT_ADD:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n          break;\n        case EDIT_DELETE:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n      }\n    }\n\n    if (splice) {\n      splices.push(splice);\n    }\n    return splices;\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          var removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'new':\n        case 'updated':\n        case 'deleted':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return\n      };\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  global.Observer = Observer;\n  global.Observer.hasObjectObserve = hasObserve;\n  global.ArrayObserver = ArrayObserver;\n  global.ArrayObserver.calculateSplices = function(current, previous) {\n    return calcSplices(current, 0, current.length, previous, 0, previous.length);\n  };\n  global.ObjectObserver = ObjectObserver;\n  global.PathObserver = PathObserver;\n  global.Path = Path;\n})(typeof global !== 'undefined' && global ? global : this);\n\n})();\n//@ sourceURL=change_summary");