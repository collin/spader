minispade.register('coffeekup', "(function() {# **CoffeeKup** lets you to write HTML templates in 100% pure\n# [CoffeeScript](http://coffeescript.org).\n# \n# You can run it on [node.js](http://nodejs.org) or the browser, or compile your\n# templates down to self-contained javascript functions, that will take in data\n# and options and return generated HTML on any JS runtime.\n# \n# The concept is directly stolen from the amazing\n# [Markaby](http://markaby.rubyforge.org/) by Tim Fletcher and why the lucky\n# stiff.\n\nif window?\n  coffeekup = window.CoffeeKup = {}\n  coffee = if CoffeeScript? then CoffeeScript else null\nelse\n  coffeekup = exports\n  coffee = require 'coffee-script'\n\ncoffeekup.version = '0.3.1edge'\n\n# Values available to the `doctype` function inside a template.\n# Ex.: `doctype 'strict'`\ncoffeekup.doctypes =\n  'default': '<!DOCTYPE html>'\n  '5': '<!DOCTYPE html>'\n  'xml': '<?xml version=\"1.0\" encoding=\"utf-8\" ?>'\n  'transitional': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">'\n  'strict': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">'\n  'frameset': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">'\n  '1.1': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">',\n  'basic': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">'\n  'mobile': '<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">'\n  'ce': '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"ce-html-1.0-transitional.dtd\">'\n\n# CoffeeScript-generated JavaScript may contain anyone of these; but when we\n# take a function to string form to manipulate it, and then recreate it through\n# the `Function()` constructor, it loses access to its parent scope and\n# consequently to any helpers it might need. So we need to reintroduce these\n# inside any \"rewritten\" function.\ncoffeescript_helpers = \"\"\"\n  var __slice = Array.prototype.slice;\n  var __hasProp = Object.prototype.hasOwnProperty;\n  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n  var __extends = function(child, parent) {\n    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype;\n    return child; };\n  var __indexOf = Array.prototype.indexOf || function(item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === item) return i;\n    } return -1; };\n\"\"\".replace /\\n/g, ''\n\n# Private HTML element reference.\n# Please mind the gap (1 space at the beginning of each subsequent line).\nelements =\n  # Valid HTML 5 elements requiring a closing tag.\n  # Note: the `var` element is out for obvious reasons, please use `tag 'var'`.\n  regular: 'a abbr address article aside audio b bdi bdo blockquote body button\n canvas caption cite code colgroup datalist dd del details dfn div dl dt em\n fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup\n html i iframe ins kbd label legend li map mark menu meter nav noscript object\n ol optgroup option output p pre progress q rp rt ruby s samp script section\n select small span strong style sub summary sup table tbody td textarea tfoot\n th thead time title tr u ul video'\n\n  # Valid self-closing HTML 5 elements.\n  void: 'area base br col command embed hr img input keygen link meta param\n source track wbr'\n\n  obsolete: 'applet acronym bgsound dir frameset noframes isindex listing\n nextid noembed plaintext rb strike xmp big blink center font marquee multicol\n nobr spacer tt'\n\n  obsolete_void: 'basefont frame'\n\n# Create a unique list of element names merging the desired groups.\nmerge_elements = (args...) ->\n  result = []\n  for a in args\n    for element in elements[a].split ' '\n      result.push element unless element in result\n  result\n\n# Public/customizable list of possible elements.\n# For each name in this list that is also present in the input template code,\n# a function with the same name will be added to the compiled template.\ncoffeekup.tags = merge_elements 'regular', 'obsolete', 'void', 'obsolete_void'\n\n# Public/customizable list of elements that should be rendered self-closed.\ncoffeekup.self_closing = merge_elements 'void', 'obsolete_void'\n\n# This is the basic material from which compiled templates will be formed.\n# It will be manipulated in its string form at the `coffeekup.compile` function\n# to generate the final template function. \nskeleton = (data = {}) ->\n  # Whether to generate formatted HTML with indentation and line breaks, or\n  # just the natural \"faux-minified\" output.\n  data.format ?= off\n\n  # Whether to autoescape all content or let you handle it on a case by case\n  # basis with the `h` function.\n  data.autoescape ?= off\n\n  # Internal CoffeeKup stuff.\n  __ck =\n    buffer: []\n      \n    esc: (txt) ->\n      if data.autoescape then h(txt) else String(txt)\n\n    tabs: 0\n\n    repeat: (string, count) -> Array(count + 1).join string\n\n    indent: -> text @repeat('  ', @tabs) if data.format\n\n    # Adapter to keep the builtin tag functions DRY.\n    tag: (name, args) ->\n      combo = [name]\n      combo.push i for i in args\n      tag.apply data, combo\n\n    render_idclass: (str) ->\n      classes = []\n        \n      for i in str.split '.'\n        if '#' in i\n          id = i.replace '#', ''\n        else\n          classes.push i unless i is ''\n            \n      text \" id=\\\"#{id}\\\"\" if id\n      \n      if classes.length > 0\n        text \" class=\\\"\"\n        for c in classes\n          text ' ' unless c is classes[0]\n          text c\n        text '\"'\n\n    render_attrs: (obj, prefix = '') ->\n      for k, v of obj\n        # `true` is rendered as `selected=\"selected\"`.\n        v = k if typeof v is 'boolean' and v\n        \n        # Functions are rendered in an executable form.\n        v = \"(#{v}).call(this);\" if typeof v is 'function'\n\n        # Prefixed attribute.\n        if typeof v is 'object' and v not instanceof Array\n          # `data: {icon: 'foo'}` is rendered as `data-icon=\"foo\"`.\n          @render_attrs(v, prefix + k + '-')\n        # `undefined`, `false` and `null` result in the attribute not being rendered.\n        else if v\n          # strings, numbers, arrays and functions are rendered \"as is\".\n          text \" #{prefix + k}=\\\"#{@esc(v)}\\\"\"\n\n    render_contents: (contents) ->\n      switch typeof contents\n        when 'string', 'number', 'boolean'\n          text @esc(contents)\n        when 'function'\n          text '\\n' if data.format\n          @tabs++\n          result = contents.call data\n          if typeof result is 'string'\n            @indent()\n            text @esc(result)\n            text '\\n' if data.format\n          @tabs--\n          @indent()\n\n    render_tag: (name, idclass, attrs, contents) ->\n      @indent()\n    \n      text \"<#{name}\"\n      @render_idclass(idclass) if idclass\n      @render_attrs(attrs) if attrs\n  \n      if name in @self_closing\n        text ' />'\n        text '\\n' if data.format\n      else\n        text '>'\n  \n        @render_contents(contents)\n\n        text \"</#{name}>\"\n        text '\\n' if data.format\n  \n      null\n\n  tag = (name, args...) ->\n    for a in args\n      switch typeof a\n        when 'function'\n          contents = a\n        when 'object'\n          attrs = a\n        when 'number', 'boolean'\n          contents = a\n        when 'string'\n          if args.length is 1\n            contents = a\n          else\n            if a is args[0]\n              idclass = a\n            else\n              contents = a\n\n    __ck.render_tag(name, idclass, attrs, contents)\n\n  yield = (f) ->\n    temp_buffer = []\n    old_buffer = __ck.buffer\n    __ck.buffer = temp_buffer\n    f()\n    __ck.buffer = old_buffer\n    temp_buffer.join ''\n\n  h = (txt) ->\n    String(txt).replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n    \n  doctype = (type = 'default') ->\n    text __ck.doctypes[type]\n    text '\\n' if data.format\n    \n  text = (txt) ->\n    __ck.buffer.push String(txt)\n    null\n\n  comment = (cmt) ->\n    text \"<!--#{cmt}-->\"\n    text '\\n' if data.format\n  \n  coffeescript = (param) ->\n    switch typeof param\n      # `coffeescript -> alert 'hi'` becomes:\n      # `<script>;(function () {return alert('hi');})();</script>`\n      when 'function'\n        script \"#{__ck.coffeescript_helpers}(#{param}).call(this);\"\n      # `coffeescript \"alert 'hi'\"` becomes:\n      # `<script type=\"text/coffeescript\">alert 'hi'</script>`\n      when 'string'\n        script type: 'text/coffeescript', -> param\n      # `coffeescript src: 'script.coffee'` becomes:\n      # `<script type=\"text/coffeescript\" src=\"script.coffee\"></script>`\n      when 'object'\n        param.type = 'text/coffeescript'\n        script param\n  \n  # Conditional IE comments.\n  ie = (condition, contents) ->\n    __ck.indent()\n    \n    text \"<!--[if #{condition}]>\"\n    __ck.render_contents(contents)\n    text \"<![endif]-->\"\n    text '\\n' if data.format\n\n  null\n\n# Stringify the skeleton and unwrap it from its enclosing `function(){}`, then\n# add the CoffeeScript helpers.\nskeleton = String(skeleton)\n  .replace(/function\\s*\\(.*\\)\\s*\\{/, '')\n  .replace(/return null;\\s*\\}$/, '')\n\nskeleton = coffeescript_helpers + skeleton\n\n# Compiles a template into a standalone JavaScript function.\ncoffeekup.compile = (template, options = {}) ->\n  # The template can be provided as either a function or a CoffeeScript string\n  # (in the latter case, the CoffeeScript compiler must be available).\n  if typeof template is 'function' then template = String(template)\n  else if typeof template is 'string' and coffee?\n    template = coffee.compile template, bare: yes\n    template = \"function(){#{template}}\"\n\n  # If an object `hardcode` is provided, insert the stringified value\n  # of each variable directly in the function body. This is a less flexible but\n  # faster alternative to the standard method of using `with` (see below). \n  hardcoded_locals = ''\n  \n  if options.hardcode\n    for k, v of options.hardcode\n      if typeof v is 'function'\n        # Make sure these functions have access to `data` as `@/this`.\n        hardcoded_locals += \"var #{k} = function(){return (#{v}).apply(data, arguments);};\"\n      else hardcoded_locals += \"var #{k} = #{JSON.stringify v};\"\n\n  # Add a function for each tag this template references. We don't want to have\n  # all hundred-odd tags wasting space in the compiled function.\n  tag_functions = ''\n  tags_used = []\n  \n  for t in coffeekup.tags\n    if template.indexOf(t) > -1 or hardcoded_locals.indexOf(t) > -1\n      tags_used.push t\n      \n  tag_functions += \"var #{tags_used.join ','};\"\n  for t in tags_used\n    tag_functions += \"#{t} = function(){return __ck.tag('#{t}', arguments);};\"\n\n  # Main function assembly.\n  code = tag_functions + hardcoded_locals + skeleton\n\n  code += \"__ck.doctypes = #{JSON.stringify coffeekup.doctypes};\"\n  code += \"__ck.coffeescript_helpers = #{JSON.stringify coffeescript_helpers};\"\n  code += \"__ck.self_closing = #{JSON.stringify coffeekup.self_closing};\"\n\n  # If `locals` is set, wrap the template inside a `with` block. This is the\n  # most flexible but slower approach to specifying local variables.\n  code += 'with(data.locals){' if options.locals\n  code += \"(#{template}).call(data);\"\n  code += '}' if options.locals\n  code += \"return __ck.buffer.join('');\"\n  \n  new Function('data', code)\n\ncache = {}\n\n# Template in, HTML out. Accepts functions or strings as does `coffeekup.compile`.\n# \n# Accepts an option `cache`, by default `false`. If set to `false` templates will\n# be recompiled each time.\n# \n# `options` is just a convenience parameter to pass options separately from the\n# data, but the two will be merged and passed down to the compiler (which uses\n# `locals` and `hardcode`), and the template (which understands `locals`, `format`\n# and `autoescape`).\ncoffeekup.render = (template, data = {}, options = {}) ->\n  data[k] = v for k, v of options\n  data.cache ?= off\n\n  if data.cache and cache[template]? then tpl = cache[template]\n  else if data.cache then tpl = cache[template] = coffeekup.compile(template, data)\n  else tpl = coffeekup.compile(template, data)\n  tpl(data)\n\nunless window?\n  coffeekup.adapters =\n    # Legacy adapters for when CoffeeKup expected data in the `context` attribute.\n    simple: coffeekup.render\n    meryl: coffeekup.render\n    \n    express:\n      TemplateError: class extends Error\n        constructor: (@message) ->\n          Error.call this, @message\n          Error.captureStackTrace this, arguments.callee\n        name: 'TemplateError'\n        \n      compile: (template, data) -> \n        # Allows `partial 'foo'` instead of `text @partial 'foo'`.\n        data.hardcode ?= {}\n        data.hardcode.partial = ->\n          text @partial.apply @, arguments\n        \n        TemplateError = @TemplateError\n        try tpl = coffeekup.compile(template, data)\n        catch e then throw new TemplateError \"Error compiling #{data.filename}: #{e.message}\"\n        \n        return ->\n          try tpl arguments...\n          catch e then throw new TemplateError \"Error rendering #{data.filename}: #{e.message}\"\n})();\n//@ sourceURL=coffeekup");