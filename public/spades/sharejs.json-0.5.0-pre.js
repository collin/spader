minispade.register('sharejs.json', "(function() {(function() {\n  /**\n   @const\n   @type {boolean}\n*/\nvar WEB = true;\n;\n  var SubDoc, clone, depath, exports, extendDoc, isArray, json, pathEquals, text, traverse,\n    __slice = Array.prototype.slice;\n\n  exports = window['sharejs'];\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    text = exports.types.text;\n  } else {\n    text = require('./text');\n  }\n\n  json = {};\n\n  json.name = 'json';\n\n  json.create = function() {\n    return null;\n  };\n\n  json.invertComponent = function(c) {\n    var c_;\n    c_ = {\n      p: c.p\n    };\n    if (c.si !== void 0) c_.sd = c.si;\n    if (c.sd !== void 0) c_.si = c.sd;\n    if (c.oi !== void 0) c_.od = c.oi;\n    if (c.od !== void 0) c_.oi = c.od;\n    if (c.li !== void 0) c_.ld = c.li;\n    if (c.ld !== void 0) c_.li = c.ld;\n    if (c.na !== void 0) c_.na = -c.na;\n    if (c.lm !== void 0) {\n      c_.lm = c.p[c.p.length - 1];\n      c_.p = c.p.slice(0, (c.p.length - 1)).concat([c.lm]);\n    }\n    return c_;\n  };\n\n  json.invert = function(op) {\n    var c, _i, _len, _ref, _results;\n    _ref = op.slice().reverse();\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      c = _ref[_i];\n      _results.push(json.invertComponent(c));\n    }\n    return _results;\n  };\n\n  json.checkValidOp = function(op) {};\n\n  isArray = function(o) {\n    return Object.prototype.toString.call(o) === '[object Array]';\n  };\n\n  json.checkList = function(elem) {\n    if (!isArray(elem)) throw new Error('Referenced element not a list');\n  };\n\n  json.checkObj = function(elem) {\n    if (elem.constructor !== Object) {\n      throw new Error(\"Referenced element not an object (it was \" + (JSON.stringify(elem)) + \")\");\n    }\n  };\n\n  json.apply = function(snapshot, op) {\n    var c, container, e, elem, i, key, p, parent, parentkey, _i, _len, _len2, _ref;\n    json.checkValidOp(op);\n    op = clone(op);\n    container = {\n      data: clone(snapshot)\n    };\n    try {\n      for (i = 0, _len = op.length; i < _len; i++) {\n        c = op[i];\n        parent = null;\n        parentkey = null;\n        elem = container;\n        key = 'data';\n        _ref = c.p;\n        for (_i = 0, _len2 = _ref.length; _i < _len2; _i++) {\n          p = _ref[_i];\n          parent = elem;\n          parentkey = key;\n          elem = elem[key];\n          key = p;\n          if (parent == null) throw new Error('Path invalid');\n        }\n        if (c.na !== void 0) {\n          if (typeof elem[key] !== 'number') {\n            throw new Error('Referenced element not a number');\n          }\n          elem[key] += c.na;\n        } else if (c.si !== void 0) {\n          if (typeof elem !== 'string') {\n            throw new Error(\"Referenced element not a string (it was \" + (JSON.stringify(elem)) + \")\");\n          }\n          parent[parentkey] = elem.slice(0, key) + c.si + elem.slice(key);\n        } else if (c.sd !== void 0) {\n          if (typeof elem !== 'string') {\n            throw new Error('Referenced element not a string');\n          }\n          if (elem.slice(key, (key + c.sd.length)) !== c.sd) {\n            throw new Error('Deleted string does not match');\n          }\n          parent[parentkey] = elem.slice(0, key) + elem.slice(key + c.sd.length);\n        } else if (c.li !== void 0 && c.ld !== void 0) {\n          json.checkList(elem);\n          elem[key] = c.li;\n        } else if (c.li !== void 0) {\n          json.checkList(elem);\n          elem.splice(key, 0, c.li);\n        } else if (c.ld !== void 0) {\n          json.checkList(elem);\n          elem.splice(key, 1);\n        } else if (c.lm !== void 0) {\n          json.checkList(elem);\n          if (c.lm !== key) {\n            e = elem[key];\n            elem.splice(key, 1);\n            elem.splice(c.lm, 0, e);\n          }\n        } else if (c.oi !== void 0) {\n          json.checkObj(elem);\n          elem[key] = c.oi;\n        } else if (c.od !== void 0) {\n          json.checkObj(elem);\n          delete elem[key];\n        } else {\n          throw new Error('invalid / missing instruction in op');\n        }\n      }\n    } catch (error) {\n      throw error;\n    }\n    return container.data;\n  };\n\n  json.pathMatches = function(p1, p2, ignoreLast) {\n    var i, p, _len;\n    if (p1.length !== p2.length) return false;\n    for (i = 0, _len = p1.length; i < _len; i++) {\n      p = p1[i];\n      if (p !== p2[i] && (!ignoreLast || i !== p1.length - 1)) return false;\n    }\n    return true;\n  };\n\n  json.append = function(dest, c) {\n    var last;\n    c = clone(c);\n    if (dest.length !== 0 && json.pathMatches(c.p, (last = dest[dest.length - 1]).p)) {\n      if (last.na !== void 0 && c.na !== void 0) {\n        return dest[dest.length - 1] = {\n          p: last.p,\n          na: last.na + c.na\n        };\n      } else if (last.li !== void 0 && c.li === void 0 && c.ld === last.li) {\n        if (last.ld !== void 0) {\n          return delete last.li;\n        } else {\n          return dest.pop();\n        }\n      } else if (last.od !== void 0 && last.oi === void 0 && c.oi !== void 0 && c.od === void 0) {\n        return last.oi = c.oi;\n      } else if (c.lm !== void 0 && c.p[c.p.length - 1] === c.lm) {\n        return null;\n      } else {\n        return dest.push(c);\n      }\n    } else {\n      return dest.push(c);\n    }\n  };\n\n  json.compose = function(op1, op2) {\n    var c, newOp, _i, _len;\n    json.checkValidOp(op1);\n    json.checkValidOp(op2);\n    newOp = clone(op1);\n    for (_i = 0, _len = op2.length; _i < _len; _i++) {\n      c = op2[_i];\n      json.append(newOp, c);\n    }\n    return newOp;\n  };\n\n  json.normalize = function(op) {\n    var c, newOp, _i, _len;\n    newOp = [];\n    if (!isArray(op)) op = [op];\n    for (_i = 0, _len = op.length; _i < _len; _i++) {\n      c = op[_i];\n      if (c.p == null) c.p = [];\n      json.append(newOp, c);\n    }\n    return newOp;\n  };\n\n  clone = function(o) {\n    return JSON.parse(JSON.stringify(o));\n  };\n\n  json.commonPath = function(p1, p2) {\n    var i;\n    p1 = p1.slice();\n    p2 = p2.slice();\n    p1.unshift('data');\n    p2.unshift('data');\n    p1 = p1.slice(0, (p1.length - 1));\n    p2 = p2.slice(0, (p2.length - 1));\n    if (p2.length === 0) return -1;\n    i = 0;\n    while (p1[i] === p2[i] && i < p1.length) {\n      i++;\n      if (i === p2.length) return i - 1;\n    }\n  };\n\n  json.transformComponent = function(dest, c, otherC, type) {\n    var common, common2, commonOperand, convert, cplength, from, jc, oc, otherCplength, otherFrom, otherTo, p, res, tc, tc1, tc2, to, _i, _len;\n    c = clone(c);\n    if (c.na !== void 0) c.p.push(0);\n    if (otherC.na !== void 0) otherC.p.push(0);\n    common = json.commonPath(c.p, otherC.p);\n    common2 = json.commonPath(otherC.p, c.p);\n    cplength = c.p.length;\n    otherCplength = otherC.p.length;\n    if (c.na !== void 0) c.p.pop();\n    if (otherC.na !== void 0) otherC.p.pop();\n    if (otherC.na) {\n      if ((common2 != null) && otherCplength >= cplength && otherC.p[common2] === c.p[common2]) {\n        if (c.ld !== void 0) {\n          oc = clone(otherC);\n          oc.p = oc.p.slice(cplength);\n          c.ld = json.apply(clone(c.ld), [oc]);\n        } else if (c.od !== void 0) {\n          oc = clone(otherC);\n          oc.p = oc.p.slice(cplength);\n          c.od = json.apply(clone(c.od), [oc]);\n        }\n      }\n      json.append(dest, c);\n      return dest;\n    }\n    if ((common2 != null) && otherCplength > cplength && c.p[common2] === otherC.p[common2]) {\n      if (c.ld !== void 0) {\n        oc = clone(otherC);\n        oc.p = oc.p.slice(cplength);\n        c.ld = json.apply(clone(c.ld), [oc]);\n      } else if (c.od !== void 0) {\n        oc = clone(otherC);\n        oc.p = oc.p.slice(cplength);\n        c.od = json.apply(clone(c.od), [oc]);\n      }\n    }\n    if (common != null) {\n      commonOperand = cplength === otherCplength;\n      if (otherC.na !== void 0) {} else if (otherC.si !== void 0 || otherC.sd !== void 0) {\n        if (c.si !== void 0 || c.sd !== void 0) {\n          if (!commonOperand) throw new Error(\"must be a string?\");\n          convert = function(component) {\n            var newC;\n            newC = {\n              p: component.p[component.p.length - 1]\n            };\n            if (component.si) {\n              newC.i = component.si;\n            } else {\n              newC.d = component.sd;\n            }\n            return newC;\n          };\n          tc1 = convert(c);\n          tc2 = convert(otherC);\n          res = [];\n          text._tc(res, tc1, tc2, type);\n          for (_i = 0, _len = res.length; _i < _len; _i++) {\n            tc = res[_i];\n            jc = {\n              p: c.p.slice(0, common)\n            };\n            jc.p.push(tc.p);\n            if (tc.i != null) jc.si = tc.i;\n            if (tc.d != null) jc.sd = tc.d;\n            json.append(dest, jc);\n          }\n          return dest;\n        }\n      } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n        if (otherC.p[common] === c.p[common]) {\n          if (!commonOperand) {\n            return dest;\n          } else if (c.ld !== void 0) {\n            if (c.li !== void 0 && type === 'left') {\n              c.ld = clone(otherC.li);\n            } else {\n              return dest;\n            }\n          }\n        }\n      } else if (otherC.li !== void 0) {\n        if (c.li !== void 0 && c.ld === void 0 && commonOperand && c.p[common] === otherC.p[common]) {\n          if (type === 'right') c.p[common]++;\n        } else if (otherC.p[common] <= c.p[common]) {\n          c.p[common]++;\n        }\n        if (c.lm !== void 0) {\n          if (commonOperand) if (otherC.p[common] <= c.lm) c.lm++;\n        }\n      } else if (otherC.ld !== void 0) {\n        if (c.lm !== void 0) {\n          if (commonOperand) {\n            if (otherC.p[common] === c.p[common]) return dest;\n            p = otherC.p[common];\n            from = c.p[common];\n            to = c.lm;\n            if (p < to || (p === to && from < to)) c.lm--;\n          }\n        }\n        if (otherC.p[common] < c.p[common]) {\n          c.p[common]--;\n        } else if (otherC.p[common] === c.p[common]) {\n          if (otherCplength < cplength) {\n            return dest;\n          } else if (c.ld !== void 0) {\n            if (c.li !== void 0) {\n              delete c.ld;\n            } else {\n              return dest;\n            }\n          }\n        }\n      } else if (otherC.lm !== void 0) {\n        if (c.lm !== void 0 && cplength === otherCplength) {\n          from = c.p[common];\n          to = c.lm;\n          otherFrom = otherC.p[common];\n          otherTo = otherC.lm;\n          if (otherFrom !== otherTo) {\n            if (from === otherFrom) {\n              if (type === 'left') {\n                c.p[common] = otherTo;\n                if (from === to) c.lm = otherTo;\n              } else {\n                return dest;\n              }\n            } else {\n              if (from > otherFrom) c.p[common]--;\n              if (from > otherTo) {\n                c.p[common]++;\n              } else if (from === otherTo) {\n                if (otherFrom > otherTo) {\n                  c.p[common]++;\n                  if (from === to) c.lm++;\n                }\n              }\n              if (to > otherFrom) {\n                c.lm--;\n              } else if (to === otherFrom) {\n                if (to > from) c.lm--;\n              }\n              if (to > otherTo) {\n                c.lm++;\n              } else if (to === otherTo) {\n                if ((otherTo > otherFrom && to > from) || (otherTo < otherFrom && to < from)) {\n                  if (type === 'right') c.lm++;\n                } else {\n                  if (to > from) {\n                    c.lm++;\n                  } else if (to === otherFrom) {\n                    c.lm--;\n                  }\n                }\n              }\n            }\n          }\n        } else if (c.li !== void 0 && c.ld === void 0 && commonOperand) {\n          from = otherC.p[common];\n          to = otherC.lm;\n          p = c.p[common];\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n        } else {\n          from = otherC.p[common];\n          to = otherC.lm;\n          p = c.p[common];\n          if (p === from) {\n            c.p[common] = to;\n          } else {\n            if (p > from) c.p[common]--;\n            if (p > to) {\n              c.p[common]++;\n            } else if (p === to) {\n              if (from > to) c.p[common]++;\n            }\n          }\n        }\n      } else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n        if (c.p[common] === otherC.p[common]) {\n          if (c.oi !== void 0 && commonOperand) {\n            if (type === 'right') {\n              return dest;\n            } else {\n              c.od = otherC.oi;\n            }\n          } else {\n            return dest;\n          }\n        }\n      } else if (otherC.oi !== void 0) {\n        if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n          if (type === 'left') {\n            json.append(dest, {\n              p: c.p,\n              od: otherC.oi\n            });\n          } else {\n            return dest;\n          }\n        }\n      } else if (otherC.od !== void 0) {\n        if (c.p[common] === otherC.p[common]) {\n          if (!commonOperand) return dest;\n          if (c.oi !== void 0) {\n            delete c.od;\n          } else {\n            return dest;\n          }\n        }\n      }\n    }\n    json.append(dest, c);\n    return dest;\n  };\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    exports.types || (exports.types = {});\n    exports._bt(json, json.transformComponent, json.checkValidOp, json.append);\n    exports.types.json = json;\n  } else {\n    module.exports = json;\nminispade.require('./helpers').bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);\n  }\n\n  if (typeof WEB === 'undefined') json = require('./json');\n\n  if (typeof WEB !== \"undefined\" && WEB !== null) {\n    extendDoc = exports.extendDoc;\n    exports.extendDoc = function(name, fn) {\n      SubDoc.prototype[name] = fn;\n      return extendDoc(name, fn);\n    };\n  }\n\n  depath = function(path) {\n    if (path.length === 1 && path[0].constructor === Array) {\n      return path[0];\n    } else {\n      return path;\n    }\n  };\n\n  SubDoc = (function() {\n\n    function SubDoc(doc, path) {\n      this.doc = doc;\n      this.path = path;\n    }\n\n    SubDoc.prototype.at = function() {\n      var path;\n      path = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.doc.at(this.path.concat(depath(path)));\n    };\n\n    SubDoc.prototype.get = function() {\n      return this.doc.getAt(this.path);\n    };\n\n    SubDoc.prototype.set = function(value, cb) {\n      return this.doc.setAt(this.path, value, cb);\n    };\n\n    SubDoc.prototype.insert = function(pos, value, cb) {\n      return this.doc.insertAt(this.path, pos, value, cb);\n    };\n\n    SubDoc.prototype.del = function(pos, length, cb) {\n      return this.doc.deleteTextAt(this.path, length, pos, cb);\n    };\n\n    SubDoc.prototype.remove = function(cb) {\n      return this.doc.removeAt(this.path, cb);\n    };\n\n    SubDoc.prototype.push = function(value, cb) {\n      return this.insert(this.get().length, value, cb);\n    };\n\n    SubDoc.prototype.move = function(from, to, cb) {\n      return this.doc.moveAt(this.path, from, to, cb);\n    };\n\n    SubDoc.prototype.add = function(amount, cb) {\n      return this.doc.addAt(this.path, amount, cb);\n    };\n\n    SubDoc.prototype.on = function(event, cb) {\n      return this.doc.addListener(this.path, event, cb);\n    };\n\n    SubDoc.prototype.removeListener = function(l) {\n      return this.doc.removeListener(l);\n    };\n\n    SubDoc.prototype.getLength = function() {\n      return this.get().length;\n    };\n\n    SubDoc.prototype.getText = function() {\n      return this.get();\n    };\n\n    return SubDoc;\n\n  })();\n\n  traverse = function(snapshot, path) {\n    var container, elem, key, p, _i, _len;\n    container = {\n      data: snapshot\n    };\n    key = 'data';\n    elem = container;\n    for (_i = 0, _len = path.length; _i < _len; _i++) {\n      p = path[_i];\n      elem = elem[key];\n      key = p;\n      if (typeof elem === 'undefined') throw new Error('bad path');\n    }\n    return {\n      elem: elem,\n      key: key\n    };\n  };\n\n  pathEquals = function(p1, p2) {\n    var e, i, _len;\n    if (p1.length !== p2.length) return false;\n    for (i = 0, _len = p1.length; i < _len; i++) {\n      e = p1[i];\n      if (e !== p2[i]) return false;\n    }\n    return true;\n  };\n\n  json.api = {\n    provides: {\n      json: true\n    },\n    at: function() {\n      var path;\n      path = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return new SubDoc(this, depath(path));\n    },\n    get: function() {\n      return this.snapshot;\n    },\n    set: function(value, cb) {\n      return this.setAt([], value, cb);\n    },\n    getAt: function(path) {\n      var elem, key, _ref;\n      _ref = traverse(this.snapshot, path), elem = _ref.elem, key = _ref.key;\n      return elem[key];\n    },\n    setAt: function(path, value, cb) {\n      var elem, key, op, _ref;\n      _ref = traverse(this.snapshot, path), elem = _ref.elem, key = _ref.key;\n      op = {\n        p: path\n      };\n      if (elem.constructor === Array) {\n        op.li = value;\n        if (typeof elem[key] !== 'undefined') op.ld = elem[key];\n      } else if (typeof elem === 'object') {\n        op.oi = value;\n        if (typeof elem[key] !== 'undefined') op.od = elem[key];\n      } else {\n        throw new Error('bad path');\n      }\n      return this.submitOp([op], cb);\n    },\n    removeAt: function(path, cb) {\n      var elem, key, op, _ref;\n      _ref = traverse(this.snapshot, path), elem = _ref.elem, key = _ref.key;\n      if (typeof elem[key] === 'undefined') {\n        throw new Error('no element at that path');\n      }\n      op = {\n        p: path\n      };\n      if (elem.constructor === Array) {\n        op.ld = elem[key];\n      } else if (typeof elem === 'object') {\n        op.od = elem[key];\n      } else {\n        throw new Error('bad path');\n      }\n      return this.submitOp([op], cb);\n    },\n    insertAt: function(path, pos, value, cb) {\n      var elem, key, op, _ref;\n      _ref = traverse(this.snapshot, path), elem = _ref.elem, key = _ref.key;\n      op = {\n        p: path.concat(pos)\n      };\n      if (elem[key].constructor === Array) {\n        op.li = value;\n      } else if (typeof elem[key] === 'string') {\n        op.si = value;\n      }\n      return this.submitOp([op], cb);\n    },\n    moveAt: function(path, from, to, cb) {\n      var op;\n      op = [\n        {\n          p: path.concat(from),\n          lm: to\n        }\n      ];\n      return this.submitOp(op, cb);\n    },\n    addAt: function(path, amount, cb) {\n      var op;\n      op = [\n        {\n          p: path,\n          na: amount\n        }\n      ];\n      return this.submitOp(op, cb);\n    },\n    deleteTextAt: function(path, length, pos, cb) {\n      var elem, key, op, _ref;\n      _ref = traverse(this.snapshot, path), elem = _ref.elem, key = _ref.key;\n      op = [\n        {\n          p: path.concat(pos),\n          sd: elem[key].slice(pos, (pos + length))\n        }\n      ];\n      return this.submitOp(op, cb);\n    },\n    addListener: function(path, event, cb) {\n      var l;\n      l = {\n        path: path,\n        event: event,\n        cb: cb\n      };\n      this._listeners.push(l);\n      return l;\n    },\n    removeListener: function(l) {\n      var i;\n      i = this._listeners.indexOf(l);\n      if (i < 0) return false;\n      this._listeners.splice(i, 1);\n      return true;\n    },\n    _register: function() {\n      this._listeners = [];\n      this.on('change', function(op) {\n        var c, dummy, i, l, to_remove, xformed, _i, _len, _len2, _ref, _results;\n        _results = [];\n        for (_i = 0, _len = op.length; _i < _len; _i++) {\n          c = op[_i];\n          if (c.na !== void 0 || c.si !== void 0 || c.sd !== void 0) continue;\n          to_remove = [];\n          _ref = this._listeners;\n          for (i = 0, _len2 = _ref.length; i < _len2; i++) {\n            l = _ref[i];\n            dummy = {\n              p: l.path,\n              na: 0\n            };\n            xformed = this.type.transformComponent([], dummy, c, 'left');\n            if (xformed.length === 0) {\n              to_remove.push(i);\n            } else if (xformed.length === 1) {\n              l.path = xformed[0].p;\n            } else {\n              throw new Error(\"Bad assumption in json-api: xforming an 'si' op will always result in 0 or 1 components.\");\n            }\n          }\n          to_remove.sort(function(a, b) {\n            return b - a;\n          });\n          _results.push((function() {\n            var _j, _len3, _results2;\n            _results2 = [];\n            for (_j = 0, _len3 = to_remove.length; _j < _len3; _j++) {\n              i = to_remove[_j];\n              _results2.push(this._listeners.splice(i, 1));\n            }\n            return _results2;\n          }).call(this));\n        }\n        return _results;\n      });\n      return this.on('remoteop', function(op) {\n        var c, cb, child_path, common, event, match_path, path, _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = op.length; _i < _len; _i++) {\n          c = op[_i];\n          match_path = c.na === void 0 ? c.p.slice(0, (c.p.length - 1)) : c.p;\n          _results.push((function() {\n            var _j, _len2, _ref, _ref2, _ref3, _results2;\n            _ref = this._listeners;\n            _results2 = [];\n            for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n              _ref2 = _ref[_j], path = _ref2.path, event = _ref2.event, cb = _ref2.cb;\n              if (pathEquals(path, match_path)) {\n                switch (event) {\n                  case 'insert':\n                    if (c.li !== void 0 && c.ld === void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.li));\n                    } else if (c.oi !== void 0 && c.od === void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.oi));\n                    } else if (c.si !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.si));\n                    } else {\n                      _results2.push(void 0);\n                    }\n                    break;\n                  case 'delete':\n                    if (c.li === void 0 && c.ld !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.ld));\n                    } else if (c.oi === void 0 && c.od !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.od));\n                    } else if (c.sd !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.sd));\n                    } else {\n                      _results2.push(void 0);\n                    }\n                    break;\n                  case 'replace':\n                    if (c.li !== void 0 && c.ld !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.ld, c.li));\n                    } else if (c.oi !== void 0 && c.od !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.od, c.oi));\n                    } else {\n                      _results2.push(void 0);\n                    }\n                    break;\n                  case 'move':\n                    if (c.lm !== void 0) {\n                      _results2.push(cb(c.p[c.p.length - 1], c.lm));\n                    } else {\n                      _results2.push(void 0);\n                    }\n                    break;\n                  case 'add':\n                    if (c.na !== void 0) {\n                      _results2.push(cb(c.na));\n                    } else {\n                      _results2.push(void 0);\n                    }\n                    break;\n                  default:\n                    _results2.push(void 0);\n                }\n              } else if ((common = this.type.commonPath(match_path, path)) != null) {\n                if (event === 'child op') {\n                  if ((match_path.length === (_ref3 = path.length) && _ref3 === common)) {\n                    throw new Error(\"paths match length and have commonality, but aren't equal?\");\n                  }\n                  child_path = c.p.slice(common + 1);\n                  _results2.push(cb(child_path, c));\n                } else {\n                  _results2.push(void 0);\n                }\n              } else {\n                _results2.push(void 0);\n              }\n            }\n            return _results2;\n          }).call(this));\n        }\n        return _results;\n      });\n    }\n  };\n\n}).call(this);\n\n})();\n//@ sourceURL=sharejs.json");