minispade.register('jquery-ui', "(function() {/*!\n * jQuery UI 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI\n */\n(function( $, undefined ) {\n\n// prevent duplicate loading\n// this is only a problem because we proxy existing functions\n// and we don't want to double proxy them\n$.ui = $.ui || {};\nif ( $.ui.version ) {\n  return;\n}\n\n$.extend( $.ui, {\n  version: \"1.8.18\",\n\n  keyCode: {\n    ALT: 18,\n    BACKSPACE: 8,\n    CAPS_LOCK: 20,\n    COMMA: 188,\n    COMMAND: 91,\n    COMMAND_LEFT: 91, // COMMAND\n    COMMAND_RIGHT: 93,\n    CONTROL: 17,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    INSERT: 45,\n    LEFT: 37,\n    MENU: 93, // COMMAND_RIGHT\n    NUMPAD_ADD: 107,\n    NUMPAD_DECIMAL: 110,\n    NUMPAD_DIVIDE: 111,\n    NUMPAD_ENTER: 108,\n    NUMPAD_MULTIPLY: 106,\n    NUMPAD_SUBTRACT: 109,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    PERIOD: 190,\n    RIGHT: 39,\n    SHIFT: 16,\n    SPACE: 32,\n    TAB: 9,\n    UP: 38,\n    WINDOWS: 91 // COMMAND\n  }\n});\n\n// plugins\n$.fn.extend({\n  propAttr: $.fn.prop || $.fn.attr,\n\n  _focus: $.fn.focus,\n  focus: function( delay, fn ) {\n    return typeof delay === \"number\" ?\n      this.each(function() {\n        var elem = this;\n        setTimeout(function() {\n          $( elem ).focus();\n          if ( fn ) {\n            fn.call( elem );\n          }\n        }, delay );\n      }) :\n      this._focus.apply( this, arguments );\n  },\n\n  scrollParent: function() {\n    var scrollParent;\n    if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {\n      scrollParent = this.parents().filter(function() {\n        return (/(relative|absolute|fixed)/).test($.curCSS(this,'position',1)) && (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));\n      }).eq(0);\n    } else {\n      scrollParent = this.parents().filter(function() {\n        return (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));\n      }).eq(0);\n    }\n\n    return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;\n  },\n\n  zIndex: function( zIndex ) {\n    if ( zIndex !== undefined ) {\n      return this.css( \"zIndex\", zIndex );\n    }\n\n    if ( this.length ) {\n      var elem = $( this[ 0 ] ), position, value;\n      while ( elem.length && elem[ 0 ] !== document ) {\n        // Ignore z-index if position is set to a value where z-index is ignored by the browser\n        // This makes behavior of this function consistent across browsers\n        // WebKit always returns auto if the element is positioned\n        position = elem.css( \"position\" );\n        if ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n          // IE returns 0 when zIndex is not specified\n          // other browsers return a string\n          // we ignore the case of nested elements with an explicit value of 0\n          // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n          value = parseInt( elem.css( \"zIndex\" ), 10 );\n          if ( !isNaN( value ) && value !== 0 ) {\n            return value;\n          }\n        }\n        elem = elem.parent();\n      }\n    }\n\n    return 0;\n  },\n\n  disableSelection: function() {\n    return this.bind( ( $.support.selectstart ? \"selectstart\" : \"mousedown\" ) +\n      \".ui-disableSelection\", function( event ) {\n        event.preventDefault();\n      });\n  },\n\n  enableSelection: function() {\n    return this.unbind( \".ui-disableSelection\" );\n  }\n});\n\n$.each( [ \"Width\", \"Height\" ], function( i, name ) {\n  var side = name === \"Width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ],\n    type = name.toLowerCase(),\n    orig = {\n      innerWidth: $.fn.innerWidth,\n      innerHeight: $.fn.innerHeight,\n      outerWidth: $.fn.outerWidth,\n      outerHeight: $.fn.outerHeight\n    };\n\n  function reduce( elem, size, border, margin ) {\n    $.each( side, function() {\n      size -= parseFloat( $.curCSS( elem, \"padding\" + this, true) ) || 0;\n      if ( border ) {\n        size -= parseFloat( $.curCSS( elem, \"border\" + this + \"Width\", true) ) || 0;\n      }\n      if ( margin ) {\n        size -= parseFloat( $.curCSS( elem, \"margin\" + this, true) ) || 0;\n      }\n    });\n    return size;\n  }\n\n  $.fn[ \"inner\" + name ] = function( size ) {\n    if ( size === undefined ) {\n      return orig[ \"inner\" + name ].call( this );\n    }\n\n    return this.each(function() {\n      $( this ).css( type, reduce( this, size ) + \"px\" );\n    });\n  };\n\n  $.fn[ \"outer\" + name] = function( size, margin ) {\n    if ( typeof size !== \"number\" ) {\n      return orig[ \"outer\" + name ].call( this, size );\n    }\n\n    return this.each(function() {\n      $( this).css( type, reduce( this, size, true, margin ) + \"px\" );\n    });\n  };\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n  var nodeName = element.nodeName.toLowerCase();\n  if ( \"area\" === nodeName ) {\n    var map = element.parentNode,\n      mapName = map.name,\n      img;\n    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\n      return false;\n    }\n    img = $( \"img[usemap=#\" + mapName + \"]\" )[0];\n    return !!img && visible( img );\n  }\n  return ( /input|select|textarea|button|object/.test( nodeName )\n    ? !element.disabled\n    : \"a\" == nodeName\n      ? element.href || isTabIndexNotNaN\n      : isTabIndexNotNaN)\n    // the element and all of its ancestors must be visible\n    && visible( element );\n}\n\nfunction visible( element ) {\n  return !$( element ).parents().andSelf().filter(function() {\n    return $.curCSS( this, \"visibility\" ) === \"hidden\" ||\n      $.expr.filters.hidden( this );\n  }).length;\n}\n\n$.extend( $.expr[ \":\" ], {\n  data: function( elem, i, match ) {\n    return !!$.data( elem, match[ 3 ] );\n  },\n\n  focusable: function( element ) {\n    return focusable( element, !isNaN( $.attr( element, \"tabindex\" ) ) );\n  },\n\n  tabbable: function( element ) {\n    var tabIndex = $.attr( element, \"tabindex\" ),\n      isTabIndexNaN = isNaN( tabIndex );\n    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n  }\n});\n\n// support\n$(function() {\n  var body = document.body,\n    div = body.appendChild( div = document.createElement( \"div\" ) );\n\n  // access offsetHeight before setting the style to prevent a layout bug\n  // in IE 9 which causes the elemnt to continue to take up space even\n  // after it is removed from the DOM (#8026)\n  div.offsetHeight;\n\n  $.extend( div.style, {\n    minHeight: \"100px\",\n    height: \"auto\",\n    padding: 0,\n    borderWidth: 0\n  });\n\n  $.support.minHeight = div.offsetHeight === 100;\n  $.support.selectstart = \"onselectstart\" in div;\n\n  // set display to none to avoid a layout bug in IE\n  // http://dev.jquery.com/ticket/4014\n  body.removeChild( div ).style.display = \"none\";\n});\n\n\n\n\n\n// deprecated\n$.extend( $.ui, {\n  // $.ui.plugin is deprecated.  Use the proxy pattern instead.\n  plugin: {\n    add: function( module, option, set ) {\n      var proto = $.ui[ module ].prototype;\n      for ( var i in set ) {\n        proto.plugins[ i ] = proto.plugins[ i ] || [];\n        proto.plugins[ i ].push( [ option, set[ i ] ] );\n      }\n    },\n    call: function( instance, name, args ) {\n      var set = instance.plugins[ name ];\n      if ( !set || !instance.element[ 0 ].parentNode ) {\n        return;\n      }\n  \n      for ( var i = 0; i < set.length; i++ ) {\n        if ( instance.options[ set[ i ][ 0 ] ] ) {\n          set[ i ][ 1 ].apply( instance.element, args );\n        }\n      }\n    }\n  },\n  \n  // will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()\n  contains: function( a, b ) {\n    return document.compareDocumentPosition ?\n      a.compareDocumentPosition( b ) & 16 :\n      a !== b && a.contains( b );\n  },\n  \n  // only used by resizable\n  hasScroll: function( el, a ) {\n  \n    //If overflow is hidden, the element might have extra content, but the user wants to hide it\n    if ( $( el ).css( \"overflow\" ) === \"hidden\") {\n      return false;\n    }\n  \n    var scroll = ( a && a === \"left\" ) ? \"scrollLeft\" : \"scrollTop\",\n      has = false;\n  \n    if ( el[ scroll ] > 0 ) {\n      return true;\n    }\n  \n    // TODO: determine which cases actually cause this to happen\n    // if the element doesn't have the scroll set, see if it's possible to\n    // set the scroll\n    el[ scroll ] = 1;\n    has = ( el[ scroll ] > 0 );\n    el[ scroll ] = 0;\n    return has;\n  },\n  \n  // these are odd functions, fix the API or move into individual plugins\n  isOverAxis: function( x, reference, size ) {\n    //Determines when x coordinate is over \"b\" element axis\n    return ( x > reference ) && ( x < ( reference + size ) );\n  },\n  isOver: function( y, x, top, left, height, width ) {\n    //Determines when x, y coordinates is over \"b\" element\n    return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );\n  }\n});\n\n})( jQuery );\n/*!\n * jQuery UI Widget 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Widget\n */\n(function( $, undefined ) {\n\n// jQuery 1.4+\nif ( $.cleanData ) {\n  var _cleanData = $.cleanData;\n  $.cleanData = function( elems ) {\n    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n      try {\n        $( elem ).triggerHandler( \"remove\" );\n      // http://bugs.jquery.com/ticket/8235\n      } catch( e ) {}\n    }\n    _cleanData( elems );\n  };\n} else {\n  var _remove = $.fn.remove;\n  $.fn.remove = function( selector, keepData ) {\n    return this.each(function() {\n      if ( !keepData ) {\n        if ( !selector || $.filter( selector, [ this ] ).length ) {\n          $( \"*\", this ).add( [ this ] ).each(function() {\n            try {\n              $( this ).triggerHandler( \"remove\" );\n            // http://bugs.jquery.com/ticket/8235\n            } catch( e ) {}\n          });\n        }\n      }\n      return _remove.call( $(this), selector, keepData );\n    });\n  };\n}\n\n$.widget = function( name, base, prototype ) {\n  var namespace = name.split( \".\" )[ 0 ],\n    fullName;\n  name = name.split( \".\" )[ 1 ];\n  fullName = namespace + \"-\" + name;\n\n  if ( !prototype ) {\n    prototype = base;\n    base = $.Widget;\n  }\n\n  // create selector for plugin\n  $.expr[ \":\" ][ fullName ] = function( elem ) {\n    return !!$.data( elem, name );\n  };\n\n  $[ namespace ] = $[ namespace ] || {};\n  $[ namespace ][ name ] = function( options, element ) {\n    // allow instantiation without initializing for simple inheritance\n    if ( arguments.length ) {\n      this._createWidget( options, element );\n    }\n  };\n\n  var basePrototype = new base();\n  // we need to make the options hash a property directly on the new instance\n  // otherwise we'll modify the options hash on the prototype that we're\n  // inheriting from\n//  $.each( basePrototype, function( key, val ) {\n//    if ( $.isPlainObject(val) ) {\n//      basePrototype[ key ] = $.extend( {}, val );\n//    }\n//  });\n  basePrototype.options = $.extend( true, {}, basePrototype.options );\n  $[ namespace ][ name ].prototype = $.extend( true, basePrototype, {\n    namespace: namespace,\n    widgetName: name,\n    widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,\n    widgetBaseClass: fullName\n  }, prototype );\n\n  $.widget.bridge( name, $[ namespace ][ name ] );\n};\n\n$.widget.bridge = function( name, object ) {\n  $.fn[ name ] = function( options ) {\n    var isMethodCall = typeof options === \"string\",\n      args = Array.prototype.slice.call( arguments, 1 ),\n      returnValue = this;\n\n    // allow multiple hashes to be passed on init\n    options = !isMethodCall && args.length ?\n      $.extend.apply( null, [ true, options ].concat(args) ) :\n      options;\n\n    // prevent calls to internal methods\n    if ( isMethodCall && options.charAt( 0 ) === \"_\" ) {\n      return returnValue;\n    }\n\n    if ( isMethodCall ) {\n      this.each(function() {\n        var instance = $.data( this, name ),\n          methodValue = instance && $.isFunction( instance[options] ) ?\n            instance[ options ].apply( instance, args ) :\n            instance;\n        // TODO: add this back in 1.9 and use $.error() (see #5972)\n//        if ( !instance ) {\n//          throw \"cannot call methods on \" + name + \" prior to initialization; \" +\n//            \"attempted to call method '\" + options + \"'\";\n//        }\n//        if ( !$.isFunction( instance[options] ) ) {\n//          throw \"no such method '\" + options + \"' for \" + name + \" widget instance\";\n//        }\n//        var methodValue = instance[ options ].apply( instance, args );\n        if ( methodValue !== instance && methodValue !== undefined ) {\n          returnValue = methodValue;\n          return false;\n        }\n      });\n    } else {\n      this.each(function() {\n        var instance = $.data( this, name );\n        if ( instance ) {\n          instance.option( options || {} )._init();\n        } else {\n          $.data( this, name, new object( options, this ) );\n        }\n      });\n    }\n\n    return returnValue;\n  };\n};\n\n$.Widget = function( options, element ) {\n  // allow instantiation without initializing for simple inheritance\n  if ( arguments.length ) {\n    this._createWidget( options, element );\n  }\n};\n\n$.Widget.prototype = {\n  widgetName: \"widget\",\n  widgetEventPrefix: \"\",\n  options: {\n    disabled: false\n  },\n  _createWidget: function( options, element ) {\n    // $.widget.bridge stores the plugin instance, but we do it anyway\n    // so that it's stored even before the _create function runs\n    $.data( element, this.widgetName, this );\n    this.element = $( element );\n    this.options = $.extend( true, {},\n      this.options,\n      this._getCreateOptions(),\n      options );\n\n    var self = this;\n    this.element.bind( \"remove.\" + this.widgetName, function() {\n      self.destroy();\n    });\n\n    this._create();\n    this._trigger( \"create\" );\n    this._init();\n  },\n  _getCreateOptions: function() {\n    return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];\n  },\n  _create: function() {},\n  _init: function() {},\n\n  destroy: function() {\n    this.element\n      .unbind( \".\" + this.widgetName )\n      .removeData( this.widgetName );\n    this.widget()\n      .unbind( \".\" + this.widgetName )\n      .removeAttr( \"aria-disabled\" )\n      .removeClass(\n        this.widgetBaseClass + \"-disabled \" +\n        \"ui-state-disabled\" );\n  },\n\n  widget: function() {\n    return this.element;\n  },\n\n  option: function( key, value ) {\n    var options = key;\n\n    if ( arguments.length === 0 ) {\n      // don't return a reference to the internal hash\n      return $.extend( {}, this.options );\n    }\n\n    if  (typeof key === \"string\" ) {\n      if ( value === undefined ) {\n        return this.options[ key ];\n      }\n      options = {};\n      options[ key ] = value;\n    }\n\n    this._setOptions( options );\n\n    return this;\n  },\n  _setOptions: function( options ) {\n    var self = this;\n    $.each( options, function( key, value ) {\n      self._setOption( key, value );\n    });\n\n    return this;\n  },\n  _setOption: function( key, value ) {\n    this.options[ key ] = value;\n\n    if ( key === \"disabled\" ) {\n      this.widget()\n        [ value ? \"addClass\" : \"removeClass\"](\n          this.widgetBaseClass + \"-disabled\" + \" \" +\n          \"ui-state-disabled\" )\n        .attr( \"aria-disabled\", value );\n    }\n\n    return this;\n  },\n\n  enable: function() {\n    return this._setOption( \"disabled\", false );\n  },\n  disable: function() {\n    return this._setOption( \"disabled\", true );\n  },\n\n  _trigger: function( type, event, data ) {\n    var prop, orig,\n      callback = this.options[ type ];\n\n    data = data || {};\n    event = $.Event( event );\n    event.type = ( type === this.widgetEventPrefix ?\n      type :\n      this.widgetEventPrefix + type ).toLowerCase();\n    // the original event may come from any element\n    // so we need to reset the target on the new event\n    event.target = this.element[ 0 ];\n\n    // copy original event properties over to the new event\n    orig = event.originalEvent;\n    if ( orig ) {\n      for ( prop in orig ) {\n        if ( !( prop in event ) ) {\n          event[ prop ] = orig[ prop ];\n        }\n      }\n    }\n\n    this.element.trigger( event, data );\n\n    return !( $.isFunction(callback) &&\n      callback.call( this.element[0], event, data ) === false ||\n      event.isDefaultPrevented() );\n  }\n};\n\n})( jQuery );\n/*!\n * jQuery UI Mouse 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Mouse\n *\n * Depends:\n *  jquery.ui.widget.js\n */\n(function( $, undefined ) {\n\nvar mouseHandled = false;\n$( document ).mouseup( function( e ) {\n  mouseHandled = false;\n});\n\n$.widget(\"ui.mouse\", {\n  options: {\n    cancel: ':input,option',\n    distance: 1,\n    delay: 0\n  },\n  _mouseInit: function() {\n    var self = this;\n\n    this.element\n      .bind('mousedown.'+this.widgetName, function(event) {\n        return self._mouseDown(event);\n      })\n      .bind('click.'+this.widgetName, function(event) {\n        if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {\n            $.removeData(event.target, self.widgetName + '.preventClickEvent');\n          event.stopImmediatePropagation();\n          return false;\n        }\n      });\n\n    this.started = false;\n  },\n\n  // TODO: make sure destroying one instance of mouse doesn't mess with\n  // other instances of mouse\n  _mouseDestroy: function() {\n    this.element.unbind('.'+this.widgetName);\n  },\n\n  _mouseDown: function(event) {\n    // don't let more than one widget handle mouseStart\n    if( mouseHandled ) { return };\n\n    // we may have missed mouseup (out of window)\n    (this._mouseStarted && this._mouseUp(event));\n\n    this._mouseDownEvent = event;\n\n    var self = this,\n      btnIsLeft = (event.which == 1),\n      // event.target.nodeName works around a bug in IE 8 with\n      // disabled inputs (#7620)\n      elIsCancel = (typeof this.options.cancel == \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n      return true;\n    }\n\n    this.mouseDelayMet = !this.options.delay;\n    if (!this.mouseDelayMet) {\n      this._mouseDelayTimer = setTimeout(function() {\n        self.mouseDelayMet = true;\n      }, this.options.delay);\n    }\n\n    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n      this._mouseStarted = (this._mouseStart(event) !== false);\n      if (!this._mouseStarted) {\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    // Click event may never have fired (Gecko & Opera)\n    if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {\n      $.removeData(event.target, this.widgetName + '.preventClickEvent');\n    }\n\n    // these delegates are required to keep context\n    this._mouseMoveDelegate = function(event) {\n      return self._mouseMove(event);\n    };\n    this._mouseUpDelegate = function(event) {\n      return self._mouseUp(event);\n    };\n    $(document)\n      .bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\n      .bind('mouseup.'+this.widgetName, this._mouseUpDelegate);\n\n    event.preventDefault();\n    \n    mouseHandled = true;\n    return true;\n  },\n\n  _mouseMove: function(event) {\n    // IE mouseup check - mouseup happened when mouse was out of window\n    if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {\n      return this._mouseUp(event);\n    }\n\n    if (this._mouseStarted) {\n      this._mouseDrag(event);\n      return event.preventDefault();\n    }\n\n    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n      this._mouseStarted =\n        (this._mouseStart(this._mouseDownEvent, event) !== false);\n      (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n    }\n\n    return !this._mouseStarted;\n  },\n\n  _mouseUp: function(event) {\n    $(document)\n      .unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\n      .unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);\n\n    if (this._mouseStarted) {\n      this._mouseStarted = false;\n\n      if (event.target == this._mouseDownEvent.target) {\n          $.data(event.target, this.widgetName + '.preventClickEvent', true);\n      }\n\n      this._mouseStop(event);\n    }\n\n    return false;\n  },\n\n  _mouseDistanceMet: function(event) {\n    return (Math.max(\n        Math.abs(this._mouseDownEvent.pageX - event.pageX),\n        Math.abs(this._mouseDownEvent.pageY - event.pageY)\n      ) >= this.options.distance\n    );\n  },\n\n  _mouseDelayMet: function(event) {\n    return this.mouseDelayMet;\n  },\n\n  // These are placeholder methods, to be overriden by extending plugin\n  _mouseStart: function(event) {},\n  _mouseDrag: function(event) {},\n  _mouseStop: function(event) {},\n  _mouseCapture: function(event) { return true; }\n});\n\n})(jQuery);\n/*\n * jQuery UI Position 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Position\n */\n(function( $, undefined ) {\n\n$.ui = $.ui || {};\n\nvar horizontalPositions = /left|center|right/,\n  verticalPositions = /top|center|bottom/,\n  center = \"center\",\n  support = {},\n  _position = $.fn.position,\n  _offset = $.fn.offset;\n\n$.fn.position = function( options ) {\n  if ( !options || !options.of ) {\n    return _position.apply( this, arguments );\n  }\n\n  // make a copy, we don't want to modify arguments\n  options = $.extend( {}, options );\n\n  var target = $( options.of ),\n    targetElem = target[0],\n    collision = ( options.collision || \"flip\" ).split( \" \" ),\n    offset = options.offset ? options.offset.split( \" \" ) : [ 0, 0 ],\n    targetWidth,\n    targetHeight,\n    basePosition;\n\n  if ( targetElem.nodeType === 9 ) {\n    targetWidth = target.width();\n    targetHeight = target.height();\n    basePosition = { top: 0, left: 0 };\n  // TODO: use $.isWindow() in 1.9\n  } else if ( targetElem.setTimeout ) {\n    targetWidth = target.width();\n    targetHeight = target.height();\n    basePosition = { top: target.scrollTop(), left: target.scrollLeft() };\n  } else if ( targetElem.preventDefault ) {\n    // force left top to allow flipping\n    options.at = \"left top\";\n    targetWidth = targetHeight = 0;\n    basePosition = { top: options.of.pageY, left: options.of.pageX };\n  } else {\n    targetWidth = target.outerWidth();\n    targetHeight = target.outerHeight();\n    basePosition = target.offset();\n  }\n\n  // force my and at to have valid horizontal and veritcal positions\n  // if a value is missing or invalid, it will be converted to center \n  $.each( [ \"my\", \"at\" ], function() {\n    var pos = ( options[this] || \"\" ).split( \" \" );\n    if ( pos.length === 1) {\n      pos = horizontalPositions.test( pos[0] ) ?\n        pos.concat( [center] ) :\n        verticalPositions.test( pos[0] ) ?\n          [ center ].concat( pos ) :\n          [ center, center ];\n    }\n    pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;\n    pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;\n    options[ this ] = pos;\n  });\n\n  // normalize collision option\n  if ( collision.length === 1 ) {\n    collision[ 1 ] = collision[ 0 ];\n  }\n\n  // normalize offset option\n  offset[ 0 ] = parseInt( offset[0], 10 ) || 0;\n  if ( offset.length === 1 ) {\n    offset[ 1 ] = offset[ 0 ];\n  }\n  offset[ 1 ] = parseInt( offset[1], 10 ) || 0;\n\n  if ( options.at[0] === \"right\" ) {\n    basePosition.left += targetWidth;\n  } else if ( options.at[0] === center ) {\n    basePosition.left += targetWidth / 2;\n  }\n\n  if ( options.at[1] === \"bottom\" ) {\n    basePosition.top += targetHeight;\n  } else if ( options.at[1] === center ) {\n    basePosition.top += targetHeight / 2;\n  }\n\n  basePosition.left += offset[ 0 ];\n  basePosition.top += offset[ 1 ];\n\n  return this.each(function() {\n    var elem = $( this ),\n      elemWidth = elem.outerWidth(),\n      elemHeight = elem.outerHeight(),\n      marginLeft = parseInt( $.curCSS( this, \"marginLeft\", true ) ) || 0,\n      marginTop = parseInt( $.curCSS( this, \"marginTop\", true ) ) || 0,\n      collisionWidth = elemWidth + marginLeft +\n        ( parseInt( $.curCSS( this, \"marginRight\", true ) ) || 0 ),\n      collisionHeight = elemHeight + marginTop +\n        ( parseInt( $.curCSS( this, \"marginBottom\", true ) ) || 0 ),\n      position = $.extend( {}, basePosition ),\n      collisionPosition;\n\n    if ( options.my[0] === \"right\" ) {\n      position.left -= elemWidth;\n    } else if ( options.my[0] === center ) {\n      position.left -= elemWidth / 2;\n    }\n\n    if ( options.my[1] === \"bottom\" ) {\n      position.top -= elemHeight;\n    } else if ( options.my[1] === center ) {\n      position.top -= elemHeight / 2;\n    }\n\n    // prevent fractions if jQuery version doesn't support them (see #5280)\n    if ( !support.fractions ) {\n      position.left = Math.round( position.left );\n      position.top = Math.round( position.top );\n    }\n\n    collisionPosition = {\n      left: position.left - marginLeft,\n      top: position.top - marginTop\n    };\n\n    $.each( [ \"left\", \"top\" ], function( i, dir ) {\n      if ( $.ui.position[ collision[i] ] ) {\n        $.ui.position[ collision[i] ][ dir ]( position, {\n          targetWidth: targetWidth,\n          targetHeight: targetHeight,\n          elemWidth: elemWidth,\n          elemHeight: elemHeight,\n          collisionPosition: collisionPosition,\n          collisionWidth: collisionWidth,\n          collisionHeight: collisionHeight,\n          offset: offset,\n          my: options.my,\n          at: options.at\n        });\n      }\n    });\n\n    if ( $.fn.bgiframe ) {\n      elem.bgiframe();\n    }\n    elem.offset( $.extend( position, { using: options.using } ) );\n  });\n};\n\n$.ui.position = {\n  fit: {\n    left: function( position, data ) {\n      var win = $( window ),\n        over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();\n      position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );\n    },\n    top: function( position, data ) {\n      var win = $( window ),\n        over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();\n      position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );\n    }\n  },\n\n  flip: {\n    left: function( position, data ) {\n      if ( data.at[0] === center ) {\n        return;\n      }\n      var win = $( window ),\n        over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),\n        myOffset = data.my[ 0 ] === \"left\" ?\n          -data.elemWidth :\n          data.my[ 0 ] === \"right\" ?\n            data.elemWidth :\n            0,\n        atOffset = data.at[ 0 ] === \"left\" ?\n          data.targetWidth :\n          -data.targetWidth,\n        offset = -2 * data.offset[ 0 ];\n      position.left += data.collisionPosition.left < 0 ?\n        myOffset + atOffset + offset :\n        over > 0 ?\n          myOffset + atOffset + offset :\n          0;\n    },\n    top: function( position, data ) {\n      if ( data.at[1] === center ) {\n        return;\n      }\n      var win = $( window ),\n        over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),\n        myOffset = data.my[ 1 ] === \"top\" ?\n          -data.elemHeight :\n          data.my[ 1 ] === \"bottom\" ?\n            data.elemHeight :\n            0,\n        atOffset = data.at[ 1 ] === \"top\" ?\n          data.targetHeight :\n          -data.targetHeight,\n        offset = -2 * data.offset[ 1 ];\n      position.top += data.collisionPosition.top < 0 ?\n        myOffset + atOffset + offset :\n        over > 0 ?\n          myOffset + atOffset + offset :\n          0;\n    }\n  }\n};\n\n// offset setter from jQuery 1.4\nif ( !$.offset.setOffset ) {\n  $.offset.setOffset = function( elem, options ) {\n    // set position first, in-case top/left are set even on static elem\n    if ( /static/.test( $.curCSS( elem, \"position\" ) ) ) {\n      elem.style.position = \"relative\";\n    }\n    var curElem   = $( elem ),\n      curOffset = curElem.offset(),\n      curTop    = parseInt( $.curCSS( elem, \"top\",  true ), 10 ) || 0,\n      curLeft   = parseInt( $.curCSS( elem, \"left\", true ), 10)  || 0,\n      props     = {\n        top:  (options.top  - curOffset.top)  + curTop,\n        left: (options.left - curOffset.left) + curLeft\n      };\n    \n    if ( 'using' in options ) {\n      options.using.call( elem, props );\n    } else {\n      curElem.css( props );\n    }\n  };\n\n  $.fn.offset = function( options ) {\n    var elem = this[ 0 ];\n    if ( !elem || !elem.ownerDocument ) { return null; }\n    if ( options ) { \n      return this.each(function() {\n        $.offset.setOffset( this, options );\n      });\n    }\n    return _offset.call( this );\n  };\n}\n\n// fraction support test (older versions of jQuery don't support fractions)\n(function () {\n  var body = document.getElementsByTagName( \"body\" )[ 0 ], \n    div = document.createElement( \"div\" ),\n    testElement, testElementParent, testElementStyle, offset, offsetTotal;\n\n  //Create a \"fake body\" for testing based on method used in jQuery.support\n  testElement = document.createElement( body ? \"div\" : \"body\" );\n  testElementStyle = {\n    visibility: \"hidden\",\n    width: 0,\n    height: 0,\n    border: 0,\n    margin: 0,\n    background: \"none\"\n  };\n  if ( body ) {\n    $.extend( testElementStyle, {\n      position: \"absolute\",\n      left: \"-1000px\",\n      top: \"-1000px\"\n    });\n  }\n  for ( var i in testElementStyle ) {\n    testElement.style[ i ] = testElementStyle[ i ];\n  }\n  testElement.appendChild( div );\n  testElementParent = body || document.documentElement;\n  testElementParent.insertBefore( testElement, testElementParent.firstChild );\n\n  div.style.cssText = \"position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;\";\n\n  offset = $( div ).offset( function( _, offset ) {\n    return offset;\n  }).offset();\n\n  testElement.innerHTML = \"\";\n  testElementParent.removeChild( testElement );\n\n  offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );\n  support.fractions = offsetTotal > 21 && offsetTotal < 22;\n})();\n\n}( jQuery ));\n/*\n * jQuery UI Draggable 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Draggables\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.mouse.js\n *  jquery.ui.widget.js\n */\n(function( $, undefined ) {\n\n$.widget(\"ui.draggable\", $.ui.mouse, {\n  widgetEventPrefix: \"drag\",\n  options: {\n    addClasses: true,\n    appendTo: \"parent\",\n    axis: false,\n    connectToSortable: false,\n    containment: false,\n    cursor: \"auto\",\n    cursorAt: false,\n    grid: false,\n    handle: false,\n    helper: \"original\",\n    iframeFix: false,\n    opacity: false,\n    refreshPositions: false,\n    revert: false,\n    revertDuration: 500,\n    scope: \"default\",\n    scroll: true,\n    scrollSensitivity: 20,\n    scrollSpeed: 20,\n    snap: false,\n    snapMode: \"both\",\n    snapTolerance: 20,\n    stack: false,\n    zIndex: false\n  },\n  _create: function() {\n\n    if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css(\"position\")))\n      this.element[0].style.position = 'relative';\n\n    (this.options.addClasses && this.element.addClass(\"ui-draggable\"));\n    (this.options.disabled && this.element.addClass(\"ui-draggable-disabled\"));\n\n    this._mouseInit();\n\n  },\n\n  destroy: function() {\n    if(!this.element.data('draggable')) return;\n    this.element\n      .removeData(\"draggable\")\n      .unbind(\".draggable\")\n      .removeClass(\"ui-draggable\"\n        + \" ui-draggable-dragging\"\n        + \" ui-draggable-disabled\");\n    this._mouseDestroy();\n\n    return this;\n  },\n\n  _mouseCapture: function(event) {\n\n    var o = this.options;\n\n    // among others, prevent a drag on a resizable-handle\n    if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))\n      return false;\n\n    //Quit if we're not on a valid handle\n    this.handle = this._getHandle(event);\n    if (!this.handle)\n      return false;\n    \n    if ( o.iframeFix ) {\n      $(o.iframeFix === true ? \"iframe\" : o.iframeFix).each(function() {\n        $('<div class=\"ui-draggable-iframeFix\" style=\"background: #fff;\"></div>')\n        .css({\n          width: this.offsetWidth+\"px\", height: this.offsetHeight+\"px\",\n          position: \"absolute\", opacity: \"0.001\", zIndex: 1000\n        })\n        .css($(this).offset())\n        .appendTo(\"body\");\n      });\n    }\n\n    return true;\n\n  },\n\n  _mouseStart: function(event) {\n\n    var o = this.options;\n\n    //Create and append the visible helper\n    this.helper = this._createHelper(event);\n\n    //Cache the helper size\n    this._cacheHelperProportions();\n\n    //If ddmanager is used for droppables, set the global draggable\n    if($.ui.ddmanager)\n      $.ui.ddmanager.current = this;\n\n    /*\n     * - Position generation -\n     * This block generates everything position related - it's the core of draggables.\n     */\n\n    //Cache the margins of the original element\n    this._cacheMargins();\n\n    //Store the helper's css position\n    this.cssPosition = this.helper.css(\"position\");\n    this.scrollParent = this.helper.scrollParent();\n\n    //The element's absolute position on the page minus margins\n    this.offset = this.positionAbs = this.element.offset();\n    this.offset = {\n      top: this.offset.top - this.margins.top,\n      left: this.offset.left - this.margins.left\n    };\n\n    $.extend(this.offset, {\n      click: { //Where the click happened, relative to the element\n        left: event.pageX - this.offset.left,\n        top: event.pageY - this.offset.top\n      },\n      parent: this._getParentOffset(),\n      relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n    });\n\n    //Generate the original position\n    this.originalPosition = this.position = this._generatePosition(event);\n    this.originalPageX = event.pageX;\n    this.originalPageY = event.pageY;\n\n    //Adjust the mouse offset relative to the helper if 'cursorAt' is supplied\n    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n    //Set a containment if given in the options\n    if(o.containment)\n      this._setContainment();\n\n    //Trigger event + callbacks\n    if(this._trigger(\"start\", event) === false) {\n      this._clear();\n      return false;\n    }\n\n    //Recache the helper size\n    this._cacheHelperProportions();\n\n    //Prepare the droppable offsets\n    if ($.ui.ddmanager && !o.dropBehaviour)\n      $.ui.ddmanager.prepareOffsets(this, event);\n\n    this.helper.addClass(\"ui-draggable-dragging\");\n    this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n    \n    //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n    if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);\n    \n    return true;\n  },\n\n  _mouseDrag: function(event, noPropagation) {\n\n    //Compute the helpers position\n    this.position = this._generatePosition(event);\n    this.positionAbs = this._convertPositionTo(\"absolute\");\n\n    //Call plugins and callbacks and use the resulting position if something is returned\n    if (!noPropagation) {\n      var ui = this._uiHash();\n      if(this._trigger('drag', event, ui) === false) {\n        this._mouseUp({});\n        return false;\n      }\n      this.position = ui.position;\n    }\n\n    if(!this.options.axis || this.options.axis != \"y\") this.helper[0].style.left = this.position.left+'px';\n    if(!this.options.axis || this.options.axis != \"x\") this.helper[0].style.top = this.position.top+'px';\n    if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);\n\n    return false;\n  },\n\n  _mouseStop: function(event) {\n\n    //If we are using droppables, inform the manager about the drop\n    var dropped = false;\n    if ($.ui.ddmanager && !this.options.dropBehaviour)\n      dropped = $.ui.ddmanager.drop(this, event);\n\n    //if a drop comes from outside (a sortable)\n    if(this.dropped) {\n      dropped = this.dropped;\n      this.dropped = false;\n    }\n    \n    //if the original element is removed, don't bother to continue if helper is set to \"original\"\n    if((!this.element[0] || !this.element[0].parentNode) && this.options.helper == \"original\")\n      return false;\n\n    if((this.options.revert == \"invalid\" && !dropped) || (this.options.revert == \"valid\" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\n      var self = this;\n      $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\n        if(self._trigger(\"stop\", event) !== false) {\n          self._clear();\n        }\n      });\n    } else {\n      if(this._trigger(\"stop\", event) !== false) {\n        this._clear();\n      }\n    }\n\n    return false;\n  },\n  \n  _mouseUp: function(event) {\n    if (this.options.iframeFix === true) {\n      $(\"div.ui-draggable-iframeFix\").each(function() { \n        this.parentNode.removeChild(this); \n      }); //Remove frame helpers\n    }\n    \n    //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n    if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);\n    \n    return $.ui.mouse.prototype._mouseUp.call(this, event);\n  },\n  \n  cancel: function() {\n    \n    if(this.helper.is(\".ui-draggable-dragging\")) {\n      this._mouseUp({});\n    } else {\n      this._clear();\n    }\n    \n    return this;\n    \n  },\n\n  _getHandle: function(event) {\n\n    var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;\n    $(this.options.handle, this.element)\n      .find(\"*\")\n      .andSelf()\n      .each(function() {\n        if(this == event.target) handle = true;\n      });\n\n    return handle;\n\n  },\n\n  _createHelper: function(event) {\n\n    var o = this.options;\n    var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);\n\n    if(!helper.parents('body').length)\n      helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));\n\n    if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css(\"position\")))\n      helper.css(\"position\", \"absolute\");\n\n    return helper;\n\n  },\n\n  _adjustOffsetFromHelper: function(obj) {\n    if (typeof obj == 'string') {\n      obj = obj.split(' ');\n    }\n    if ($.isArray(obj)) {\n      obj = {left: +obj[0], top: +obj[1] || 0};\n    }\n    if ('left' in obj) {\n      this.offset.click.left = obj.left + this.margins.left;\n    }\n    if ('right' in obj) {\n      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n    }\n    if ('top' in obj) {\n      this.offset.click.top = obj.top + this.margins.top;\n    }\n    if ('bottom' in obj) {\n      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n    }\n  },\n\n  _getParentOffset: function() {\n\n    //Get the offsetParent and cache its position\n    this.offsetParent = this.helper.offsetParent();\n    var po = this.offsetParent.offset();\n\n    // This is a special case where we need to modify a offset calculated on start, since the following happened:\n    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n    if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {\n      po.left += this.scrollParent.scrollLeft();\n      po.top += this.scrollParent.scrollTop();\n    }\n\n    if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information\n    || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix\n      po = { top: 0, left: 0 };\n\n    return {\n      top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"),10) || 0),\n      left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"),10) || 0)\n    };\n\n  },\n\n  _getRelativeOffset: function() {\n\n    if(this.cssPosition == \"relative\") {\n      var p = this.element.position();\n      return {\n        top: p.top - (parseInt(this.helper.css(\"top\"),10) || 0) + this.scrollParent.scrollTop(),\n        left: p.left - (parseInt(this.helper.css(\"left\"),10) || 0) + this.scrollParent.scrollLeft()\n      };\n    } else {\n      return { top: 0, left: 0 };\n    }\n\n  },\n\n  _cacheMargins: function() {\n    this.margins = {\n      left: (parseInt(this.element.css(\"marginLeft\"),10) || 0),\n      top: (parseInt(this.element.css(\"marginTop\"),10) || 0),\n      right: (parseInt(this.element.css(\"marginRight\"),10) || 0),\n      bottom: (parseInt(this.element.css(\"marginBottom\"),10) || 0)\n    };\n  },\n\n  _cacheHelperProportions: function() {\n    this.helperProportions = {\n      width: this.helper.outerWidth(),\n      height: this.helper.outerHeight()\n    };\n  },\n\n  _setContainment: function() {\n\n    var o = this.options;\n    if(o.containment == 'parent') o.containment = this.helper[0].parentNode;\n    if(o.containment == 'document' || o.containment == 'window') this.containment = [\n      o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\n      o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,\n      (o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,\n      (o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n    ];\n\n    if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {\n            var c = $(o.containment);\n      var ce = c[0]; if(!ce) return;\n      var co = c.offset();\n      var over = ($(ce).css(\"overflow\") != 'hidden');\n\n      this.containment = [\n        (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingLeft\"),10) || 0),\n        (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingTop\"),10) || 0),\n        (over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingRight\"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,\n        (over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingBottom\"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom\n      ];\n      this.relative_container = c;\n\n    } else if(o.containment.constructor == Array) {\n      this.containment = o.containment;\n    }\n\n  },\n\n  _convertPositionTo: function(d, pos) {\n\n    if(!pos) pos = this.position;\n    var mod = d == \"absolute\" ? 1 : -1;\n    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n    return {\n      top: (\n        pos.top                                 // The absolute mouse position\n        + this.offset.relative.top * mod                    // Only for relative positioned nodes: Relative offset from element to offset parent\n        + this.offset.parent.top * mod                      // The offsetParent's offset without borders (offset + border)\n        - ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n      ),\n      left: (\n        pos.left                                // The absolute mouse position\n        + this.offset.relative.left * mod                   // Only for relative positioned nodes: Relative offset from element to offset parent\n        + this.offset.parent.left * mod                     // The offsetParent's offset without borders (offset + border)\n        - ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n      )\n    };\n\n  },\n\n  _generatePosition: function(event) {\n\n    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n    var pageX = event.pageX;\n    var pageY = event.pageY;\n\n    /*\n     * - Position constraining -\n     * Constrain the position to a mix of grid, containment.\n     */\n\n    if(this.originalPosition) { //If we are not dragging yet, we won't check for options\n             var containment;\n             if(this.containment) {\n         if (this.relative_container){\n             var co = this.relative_container.offset();\n             containment = [ this.containment[0] + co.left,\n                 this.containment[1] + co.top,\n                 this.containment[2] + co.left,\n                 this.containment[3] + co.top ];\n         }\n         else {\n             containment = this.containment;\n         }\n\n        if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;\n        if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;\n        if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;\n        if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;\n      }\n\n      if(o.grid) {\n        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n        var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n        pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n        var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n        pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n      }\n\n    }\n\n    return {\n      top: (\n        pageY                               // The absolute mouse position\n        - this.offset.click.top                         // Click offset (relative to the element)\n        - this.offset.relative.top                        // Only for relative positioned nodes: Relative offset from element to offset parent\n        - this.offset.parent.top                        // The offsetParent's offset without borders (offset + border)\n        + ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n      ),\n      left: (\n        pageX                               // The absolute mouse position\n        - this.offset.click.left                        // Click offset (relative to the element)\n        - this.offset.relative.left                       // Only for relative positioned nodes: Relative offset from element to offset parent\n        - this.offset.parent.left                       // The offsetParent's offset without borders (offset + border)\n        + ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n      )\n    };\n\n  },\n\n  _clear: function() {\n    this.helper.removeClass(\"ui-draggable-dragging\");\n    if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();\n    //if($.ui.ddmanager) $.ui.ddmanager.current = null;\n    this.helper = null;\n    this.cancelHelperRemoval = false;\n  },\n\n  // From now on bulk stuff - mainly helpers\n\n  _trigger: function(type, event, ui) {\n    ui = ui || this._uiHash();\n    $.ui.plugin.call(this, type, [event, ui]);\n    if(type == \"drag\") this.positionAbs = this._convertPositionTo(\"absolute\"); //The absolute position has to be recalculated after plugins\n    return $.Widget.prototype._trigger.call(this, type, event, ui);\n  },\n\n  plugins: {},\n\n  _uiHash: function(event) {\n    return {\n      helper: this.helper,\n      position: this.position,\n      originalPosition: this.originalPosition,\n      offset: this.positionAbs\n    };\n  }\n\n});\n\n$.extend($.ui.draggable, {\n  version: \"1.8.18\"\n});\n\n$.ui.plugin.add(\"draggable\", \"connectToSortable\", {\n  start: function(event, ui) {\n\n    var inst = $(this).data(\"draggable\"), o = inst.options,\n      uiSortable = $.extend({}, ui, { item: inst.element });\n    inst.sortables = [];\n    $(o.connectToSortable).each(function() {\n      var sortable = $.data(this, 'sortable');\n      if (sortable && !sortable.options.disabled) {\n        inst.sortables.push({\n          instance: sortable,\n          shouldRevert: sortable.options.revert\n        });\n        sortable.refreshPositions();  // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).\n        sortable._trigger(\"activate\", event, uiSortable);\n      }\n    });\n\n  },\n  stop: function(event, ui) {\n\n    //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper\n    var inst = $(this).data(\"draggable\"),\n      uiSortable = $.extend({}, ui, { item: inst.element });\n\n    $.each(inst.sortables, function() {\n      if(this.instance.isOver) {\n\n        this.instance.isOver = 0;\n\n        inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance\n        this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)\n\n        //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'\n        if(this.shouldRevert) this.instance.options.revert = true;\n\n        //Trigger the stop of the sortable\n        this.instance._mouseStop(event);\n\n        this.instance.options.helper = this.instance.options._helper;\n\n        //If the helper has been the original item, restore properties in the sortable\n        if(inst.options.helper == 'original')\n          this.instance.currentItem.css({ top: 'auto', left: 'auto' });\n\n      } else {\n        this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance\n        this.instance._trigger(\"deactivate\", event, uiSortable);\n      }\n\n    });\n\n  },\n  drag: function(event, ui) {\n\n    var inst = $(this).data(\"draggable\"), self = this;\n\n    var checkPos = function(o) {\n      var dyClick = this.offset.click.top, dxClick = this.offset.click.left;\n      var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;\n      var itemHeight = o.height, itemWidth = o.width;\n      var itemTop = o.top, itemLeft = o.left;\n\n      return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);\n    };\n\n    $.each(inst.sortables, function(i) {\n      \n      //Copy over some variables to allow calling the sortable's native _intersectsWith\n      this.instance.positionAbs = inst.positionAbs;\n      this.instance.helperProportions = inst.helperProportions;\n      this.instance.offset.click = inst.offset.click;\n      \n      if(this.instance._intersectsWith(this.instance.containerCache)) {\n\n        //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once\n        if(!this.instance.isOver) {\n\n          this.instance.isOver = 1;\n          //Now we fake the start of dragging for the sortable instance,\n          //by cloning the list group item, appending it to the sortable and using it as inst.currentItem\n          //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)\n          this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data(\"sortable-item\", true);\n          this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it\n          this.instance.options.helper = function() { return ui.helper[0]; };\n\n          event.target = this.instance.currentItem[0];\n          this.instance._mouseCapture(event, true);\n          this.instance._mouseStart(event, true, true);\n\n          //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes\n          this.instance.offset.click.top = inst.offset.click.top;\n          this.instance.offset.click.left = inst.offset.click.left;\n          this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;\n          this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;\n\n          inst._trigger(\"toSortable\", event);\n          inst.dropped = this.instance.element; //draggable revert needs that\n          //hack so receive/update callbacks work (mostly)\n          inst.currentItem = inst.element;\n          this.instance.fromOutside = inst;\n\n        }\n\n        //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable\n        if(this.instance.currentItem) this.instance._mouseDrag(event);\n\n      } else {\n\n        //If it doesn't intersect with the sortable, and it intersected before,\n        //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval\n        if(this.instance.isOver) {\n\n          this.instance.isOver = 0;\n          this.instance.cancelHelperRemoval = true;\n          \n          //Prevent reverting on this forced stop\n          this.instance.options.revert = false;\n          \n          // The out event needs to be triggered independently\n          this.instance._trigger('out', event, this.instance._uiHash(this.instance));\n          \n          this.instance._mouseStop(event, true);\n          this.instance.options.helper = this.instance.options._helper;\n\n          //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size\n          this.instance.currentItem.remove();\n          if(this.instance.placeholder) this.instance.placeholder.remove();\n\n          inst._trigger(\"fromSortable\", event);\n          inst.dropped = false; //draggable revert needs that\n        }\n\n      };\n\n    });\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"cursor\", {\n  start: function(event, ui) {\n    var t = $('body'), o = $(this).data('draggable').options;\n    if (t.css(\"cursor\")) o._cursor = t.css(\"cursor\");\n    t.css(\"cursor\", o.cursor);\n  },\n  stop: function(event, ui) {\n    var o = $(this).data('draggable').options;\n    if (o._cursor) $('body').css(\"cursor\", o._cursor);\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"opacity\", {\n  start: function(event, ui) {\n    var t = $(ui.helper), o = $(this).data('draggable').options;\n    if(t.css(\"opacity\")) o._opacity = t.css(\"opacity\");\n    t.css('opacity', o.opacity);\n  },\n  stop: function(event, ui) {\n    var o = $(this).data('draggable').options;\n    if(o._opacity) $(ui.helper).css('opacity', o._opacity);\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"scroll\", {\n  start: function(event, ui) {\n    var i = $(this).data(\"draggable\");\n    if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();\n  },\n  drag: function(event, ui) {\n\n    var i = $(this).data(\"draggable\"), o = i.options, scrolled = false;\n\n    if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {\n\n      if(!o.axis || o.axis != 'x') {\n        if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)\n          i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;\n        else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)\n          i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;\n      }\n\n      if(!o.axis || o.axis != 'y') {\n        if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)\n          i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;\n        else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)\n          i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;\n      }\n\n    } else {\n\n      if(!o.axis || o.axis != 'x') {\n        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)\n          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n        else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)\n          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n      }\n\n      if(!o.axis || o.axis != 'y') {\n        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)\n          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n        else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)\n          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n      }\n\n    }\n\n    if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)\n      $.ui.ddmanager.prepareOffsets(i, event);\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"snap\", {\n  start: function(event, ui) {\n\n    var i = $(this).data(\"draggable\"), o = i.options;\n    i.snapElements = [];\n\n    $(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {\n      var $t = $(this); var $o = $t.offset();\n      if(this != i.element[0]) i.snapElements.push({\n        item: this,\n        width: $t.outerWidth(), height: $t.outerHeight(),\n        top: $o.top, left: $o.left\n      });\n    });\n\n  },\n  drag: function(event, ui) {\n\n    var inst = $(this).data(\"draggable\"), o = inst.options;\n    var d = o.snapTolerance;\n\n    var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\n      y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\n\n    for (var i = inst.snapElements.length - 1; i >= 0; i--){\n\n      var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,\n        t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;\n\n      //Yes, I know, this is insane ;)\n      if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {\n        if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n        inst.snapElements[i].snapping = false;\n        continue;\n      }\n\n      if(o.snapMode != 'inner') {\n        var ts = Math.abs(t - y2) <= d;\n        var bs = Math.abs(b - y1) <= d;\n        var ls = Math.abs(l - x2) <= d;\n        var rs = Math.abs(r - x1) <= d;\n        if(ts) ui.position.top = inst._convertPositionTo(\"relative\", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;\n        if(bs) ui.position.top = inst._convertPositionTo(\"relative\", { top: b, left: 0 }).top - inst.margins.top;\n        if(ls) ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;\n        if(rs) ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r }).left - inst.margins.left;\n      }\n\n      var first = (ts || bs || ls || rs);\n\n      if(o.snapMode != 'outer') {\n        var ts = Math.abs(t - y1) <= d;\n        var bs = Math.abs(b - y2) <= d;\n        var ls = Math.abs(l - x1) <= d;\n        var rs = Math.abs(r - x2) <= d;\n        if(ts) ui.position.top = inst._convertPositionTo(\"relative\", { top: t, left: 0 }).top - inst.margins.top;\n        if(bs) ui.position.top = inst._convertPositionTo(\"relative\", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;\n        if(ls) ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l }).left - inst.margins.left;\n        if(rs) ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;\n      }\n\n      if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))\n        (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n      inst.snapElements[i].snapping = (ts || bs || ls || rs || first);\n\n    };\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"stack\", {\n  start: function(event, ui) {\n\n    var o = $(this).data(\"draggable\").options;\n\n    var group = $.makeArray($(o.stack)).sort(function(a,b) {\n      return (parseInt($(a).css(\"zIndex\"),10) || 0) - (parseInt($(b).css(\"zIndex\"),10) || 0);\n    });\n    if (!group.length) { return; }\n    \n    var min = parseInt(group[0].style.zIndex) || 0;\n    $(group).each(function(i) {\n      this.style.zIndex = min + i;\n    });\n\n    this[0].style.zIndex = min + group.length;\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"zIndex\", {\n  start: function(event, ui) {\n    var t = $(ui.helper), o = $(this).data(\"draggable\").options;\n    if(t.css(\"zIndex\")) o._zIndex = t.css(\"zIndex\");\n    t.css('zIndex', o.zIndex);\n  },\n  stop: function(event, ui) {\n    var o = $(this).data(\"draggable\").options;\n    if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);\n  }\n});\n\n})(jQuery);\n/*\n * jQuery UI Droppable 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Droppables\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.widget.js\n *  jquery.ui.mouse.js\n *  jquery.ui.draggable.js\n */\n(function( $, undefined ) {\n\n$.widget(\"ui.droppable\", {\n  widgetEventPrefix: \"drop\",\n  options: {\n    accept: '*',\n    activeClass: false,\n    addClasses: true,\n    greedy: false,\n    hoverClass: false,\n    scope: 'default',\n    tolerance: 'intersect'\n  },\n  _create: function() {\n\n    var o = this.options, accept = o.accept;\n    this.isover = 0; this.isout = 1;\n\n    this.accept = $.isFunction(accept) ? accept : function(d) {\n      return d.is(accept);\n    };\n\n    //Store the droppable's proportions\n    this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };\n\n    // Add the reference and positions to the manager\n    $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];\n    $.ui.ddmanager.droppables[o.scope].push(this);\n\n    (o.addClasses && this.element.addClass(\"ui-droppable\"));\n\n  },\n\n  destroy: function() {\n    var drop = $.ui.ddmanager.droppables[this.options.scope];\n    for ( var i = 0; i < drop.length; i++ )\n      if ( drop[i] == this )\n        drop.splice(i, 1);\n\n    this.element\n      .removeClass(\"ui-droppable ui-droppable-disabled\")\n      .removeData(\"droppable\")\n      .unbind(\".droppable\");\n\n    return this;\n  },\n\n  _setOption: function(key, value) {\n\n    if(key == 'accept') {\n      this.accept = $.isFunction(value) ? value : function(d) {\n        return d.is(value);\n      };\n    }\n    $.Widget.prototype._setOption.apply(this, arguments);\n  },\n\n  _activate: function(event) {\n    var draggable = $.ui.ddmanager.current;\n    if(this.options.activeClass) this.element.addClass(this.options.activeClass);\n    (draggable && this._trigger('activate', event, this.ui(draggable)));\n  },\n\n  _deactivate: function(event) {\n    var draggable = $.ui.ddmanager.current;\n    if(this.options.activeClass) this.element.removeClass(this.options.activeClass);\n    (draggable && this._trigger('deactivate', event, this.ui(draggable)));\n  },\n\n  _over: function(event) {\n\n    var draggable = $.ui.ddmanager.current;\n    if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element\n\n    if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n      if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);\n      this._trigger('over', event, this.ui(draggable));\n    }\n\n  },\n\n  _out: function(event) {\n\n    var draggable = $.ui.ddmanager.current;\n    if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element\n\n    if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n      if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);\n      this._trigger('out', event, this.ui(draggable));\n    }\n\n  },\n\n  _drop: function(event,custom) {\n\n    var draggable = custom || $.ui.ddmanager.current;\n    if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element\n\n    var childrenIntersection = false;\n    this.element.find(\":data(droppable)\").not(\".ui-draggable-dragging\").each(function() {\n      var inst = $.data(this, 'droppable');\n      if(\n        inst.options.greedy\n        && !inst.options.disabled\n        && inst.options.scope == draggable.options.scope\n        && inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))\n        && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)\n      ) { childrenIntersection = true; return false; }\n    });\n    if(childrenIntersection) return false;\n\n    if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n      if(this.options.activeClass) this.element.removeClass(this.options.activeClass);\n      if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);\n      this._trigger('drop', event, this.ui(draggable));\n      return this.element;\n    }\n\n    return false;\n\n  },\n\n  ui: function(c) {\n    return {\n      draggable: (c.currentItem || c.element),\n      helper: c.helper,\n      position: c.position,\n      offset: c.positionAbs\n    };\n  }\n\n});\n\n$.extend($.ui.droppable, {\n  version: \"1.8.18\"\n});\n\n$.ui.intersect = function(draggable, droppable, toleranceMode) {\n\n  if (!droppable.offset) return false;\n\n  var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,\n    y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;\n  var l = droppable.offset.left, r = l + droppable.proportions.width,\n    t = droppable.offset.top, b = t + droppable.proportions.height;\n\n  switch (toleranceMode) {\n    case 'fit':\n      return (l <= x1 && x2 <= r\n        && t <= y1 && y2 <= b);\n      break;\n    case 'intersect':\n      return (l < x1 + (draggable.helperProportions.width / 2) // Right Half\n        && x2 - (draggable.helperProportions.width / 2) < r // Left Half\n        && t < y1 + (draggable.helperProportions.height / 2) // Bottom Half\n        && y2 - (draggable.helperProportions.height / 2) < b ); // Top Half\n      break;\n    case 'pointer':\n      var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),\n        draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),\n        isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);\n      return isOver;\n      break;\n    case 'touch':\n      return (\n          (y1 >= t && y1 <= b) || // Top edge touching\n          (y2 >= t && y2 <= b) || // Bottom edge touching\n          (y1 < t && y2 > b)    // Surrounded vertically\n        ) && (\n          (x1 >= l && x1 <= r) || // Left edge touching\n          (x2 >= l && x2 <= r) || // Right edge touching\n          (x1 < l && x2 > r)    // Surrounded horizontally\n        );\n      break;\n    default:\n      return false;\n      break;\n    }\n\n};\n\n/*\n  This manager tracks offsets of draggables and droppables\n*/\n$.ui.ddmanager = {\n  current: null,\n  droppables: { 'default': [] },\n  prepareOffsets: function(t, event) {\n\n    var m = $.ui.ddmanager.droppables[t.options.scope] || [];\n    var type = event ? event.type : null; // workaround for #2317\n    var list = (t.currentItem || t.element).find(\":data(droppable)\").andSelf();\n\n    droppablesLoop: for (var i = 0; i < m.length; i++) {\n\n      if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue; //No disabled and non-accepted\n      for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item\n      m[i].visible = m[i].element.css(\"display\") != \"none\"; if(!m[i].visible) continue;                   //If the element is not visible, continue\n\n      if(type == \"mousedown\") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables\n\n      m[i].offset = m[i].element.offset();\n      m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };\n\n    }\n\n  },\n  drop: function(draggable, event) {\n\n    var dropped = false;\n    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {\n\n      if(!this.options) return;\n      if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))\n        dropped = this._drop.call(this, event) || dropped;\n\n      if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n        this.isout = 1; this.isover = 0;\n        this._deactivate.call(this, event);\n      }\n\n    });\n    return dropped;\n\n  },\n  dragStart: function( draggable, event ) {\n    //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\n    draggable.element.parents( \":not(body,html)\" ).bind( \"scroll.droppable\", function() {\n      if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );\n    });\n  },\n  drag: function(draggable, event) {\n\n    //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\n    if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);\n\n    //Run through all droppables and check their positions based on specific tolerance options\n    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {\n\n      if(this.options.disabled || this.greedyChild || !this.visible) return;\n      var intersects = $.ui.intersect(draggable, this, this.options.tolerance);\n\n      var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);\n      if(!c) return;\n\n      var parentInstance;\n      if (this.options.greedy) {\n        var parent = this.element.parents(':data(droppable):eq(0)');\n        if (parent.length) {\n          parentInstance = $.data(parent[0], 'droppable');\n          parentInstance.greedyChild = (c == 'isover' ? 1 : 0);\n        }\n      }\n\n      // we just moved into a greedy child\n      if (parentInstance && c == 'isover') {\n        parentInstance['isover'] = 0;\n        parentInstance['isout'] = 1;\n        parentInstance._out.call(parentInstance, event);\n      }\n\n      this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;\n      this[c == \"isover\" ? \"_over\" : \"_out\"].call(this, event);\n\n      // we just moved out of a greedy child\n      if (parentInstance && c == 'isout') {\n        parentInstance['isout'] = 0;\n        parentInstance['isover'] = 1;\n        parentInstance._over.call(parentInstance, event);\n      }\n    });\n\n  },\n  dragStop: function( draggable, event ) {\n    draggable.element.parents( \":not(body,html)\" ).unbind( \"scroll.droppable\" );\n    //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\n    if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );\n  }\n};\n\n})(jQuery);\n/*\n * jQuery UI Resizable 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Resizables\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.mouse.js\n *  jquery.ui.widget.js\n */\n(function( $, undefined ) {\n\n$.widget(\"ui.resizable\", $.ui.mouse, {\n  widgetEventPrefix: \"resize\",\n  options: {\n    alsoResize: false,\n    animate: false,\n    animateDuration: \"slow\",\n    animateEasing: \"swing\",\n    aspectRatio: false,\n    autoHide: false,\n    containment: false,\n    ghost: false,\n    grid: false,\n    handles: \"e,s,se\",\n    helper: false,\n    maxHeight: null,\n    maxWidth: null,\n    minHeight: 10,\n    minWidth: 10,\n    zIndex: 1000\n  },\n  _create: function() {\n\n    var self = this, o = this.options;\n    this.element.addClass(\"ui-resizable\");\n\n    $.extend(this, {\n      _aspectRatio: !!(o.aspectRatio),\n      aspectRatio: o.aspectRatio,\n      originalElement: this.element,\n      _proportionallyResizeElements: [],\n      _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null\n    });\n\n    //Wrap the element if it cannot hold child nodes\n    if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {\n\n      //Create a wrapper element and set the wrapper to the new current internal element\n      this.element.wrap(\n        $('<div class=\"ui-wrapper\" style=\"overflow: hidden;\"></div>').css({\n          position: this.element.css('position'),\n          width: this.element.outerWidth(),\n          height: this.element.outerHeight(),\n          top: this.element.css('top'),\n          left: this.element.css('left')\n        })\n      );\n\n      //Overwrite the original this.element\n      this.element = this.element.parent().data(\n        \"resizable\", this.element.data('resizable')\n      );\n\n      this.elementIsWrapper = true;\n\n      //Move margins to the wrapper\n      this.element.css({ marginLeft: this.originalElement.css(\"marginLeft\"), marginTop: this.originalElement.css(\"marginTop\"), marginRight: this.originalElement.css(\"marginRight\"), marginBottom: this.originalElement.css(\"marginBottom\") });\n      this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});\n\n      //Prevent Safari textarea resize\n      this.originalResizeStyle = this.originalElement.css('resize');\n      this.originalElement.css('resize', 'none');\n\n      //Push the actual element to our proportionallyResize internal array\n      this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));\n\n      // avoid IE jump (hard set the margin)\n      this.originalElement.css({ margin: this.originalElement.css('margin') });\n\n      // fix handlers offset\n      this._proportionallyResize();\n\n    }\n\n    this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? \"e,s,se\" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });\n    if(this.handles.constructor == String) {\n\n      if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';\n      var n = this.handles.split(\",\"); this.handles = {};\n\n      for(var i = 0; i < n.length; i++) {\n\n        var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;\n        var axis = $('<div class=\"ui-resizable-handle ' + hname + '\"></div>');\n\n        // increase zIndex of sw, se, ne, nw axis\n        //TODO : this modifies original option\n        if(/sw|se|ne|nw/.test(handle)) axis.css({ zIndex: ++o.zIndex });\n\n        //TODO : What's going on here?\n        if ('se' == handle) {\n          axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');\n        };\n\n        //Insert into internal handles object and append to element\n        this.handles[handle] = '.ui-resizable-'+handle;\n        this.element.append(axis);\n      }\n\n    }\n\n    this._renderAxis = function(target) {\n\n      target = target || this.element;\n\n      for(var i in this.handles) {\n\n        if(this.handles[i].constructor == String)\n          this.handles[i] = $(this.handles[i], this.element).show();\n\n        //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)\n        if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {\n\n          var axis = $(this.handles[i], this.element), padWrapper = 0;\n\n          //Checking the correct pad and border\n          padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();\n\n          //The padding type i have to apply...\n          var padPos = [ 'padding',\n            /ne|nw|n/.test(i) ? 'Top' :\n            /se|sw|s/.test(i) ? 'Bottom' :\n            /^e$/.test(i) ? 'Right' : 'Left' ].join(\"\");\n\n          target.css(padPos, padWrapper);\n\n          this._proportionallyResize();\n\n        }\n\n        //TODO: What's that good for? There's not anything to be executed left\n        if(!$(this.handles[i]).length)\n          continue;\n\n      }\n    };\n\n    //TODO: make renderAxis a prototype function\n    this._renderAxis(this.element);\n\n    this._handles = $('.ui-resizable-handle', this.element)\n      .disableSelection();\n\n    //Matching axis name\n    this._handles.mouseover(function() {\n      if (!self.resizing) {\n        if (this.className)\n          var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);\n        //Axis, default = se\n        self.axis = axis && axis[1] ? axis[1] : 'se';\n      }\n    });\n\n    //If we want to auto hide the elements\n    if (o.autoHide) {\n      this._handles.hide();\n      $(this.element)\n        .addClass(\"ui-resizable-autohide\")\n        .hover(function() {\n          if (o.disabled) return;\n          $(this).removeClass(\"ui-resizable-autohide\");\n          self._handles.show();\n        },\n        function(){\n          if (o.disabled) return;\n          if (!self.resizing) {\n            $(this).addClass(\"ui-resizable-autohide\");\n            self._handles.hide();\n          }\n        });\n    }\n\n    //Initialize the mouse interaction\n    this._mouseInit();\n\n  },\n\n  destroy: function() {\n\n    this._mouseDestroy();\n\n    var _destroy = function(exp) {\n      $(exp).removeClass(\"ui-resizable ui-resizable-disabled ui-resizable-resizing\")\n        .removeData(\"resizable\").unbind(\".resizable\").find('.ui-resizable-handle').remove();\n    };\n\n    //TODO: Unwrap at same DOM position\n    if (this.elementIsWrapper) {\n      _destroy(this.element);\n      var wrapper = this.element;\n      wrapper.after(\n        this.originalElement.css({\n          position: wrapper.css('position'),\n          width: wrapper.outerWidth(),\n          height: wrapper.outerHeight(),\n          top: wrapper.css('top'),\n          left: wrapper.css('left')\n        })\n      ).remove();\n    }\n\n    this.originalElement.css('resize', this.originalResizeStyle);\n    _destroy(this.originalElement);\n\n    return this;\n  },\n\n  _mouseCapture: function(event) {\n    var handle = false;\n    for (var i in this.handles) {\n      if ($(this.handles[i])[0] == event.target) {\n        handle = true;\n      }\n    }\n\n    return !this.options.disabled && handle;\n  },\n\n  _mouseStart: function(event) {\n\n    var o = this.options, iniPos = this.element.position(), el = this.element;\n\n    this.resizing = true;\n    this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };\n\n    // bugfix for http://dev.jquery.com/ticket/1749\n    if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {\n      el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });\n    }\n\n    this._renderProxy();\n\n    var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));\n\n    if (o.containment) {\n      curleft += $(o.containment).scrollLeft() || 0;\n      curtop += $(o.containment).scrollTop() || 0;\n    }\n\n    //Store needed variables\n    this.offset = this.helper.offset();\n    this.position = { left: curleft, top: curtop };\n    this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };\n    this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };\n    this.originalPosition = { left: curleft, top: curtop };\n    this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };\n    this.originalMousePosition = { left: event.pageX, top: event.pageY };\n\n    //Aspect Ratio\n    this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);\n\n      var cursor = $('.ui-resizable-' + this.axis).css('cursor');\n      $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);\n\n    el.addClass(\"ui-resizable-resizing\");\n    this._propagate(\"start\", event);\n    return true;\n  },\n\n  _mouseDrag: function(event) {\n\n    //Increase performance, avoid regex\n    var el = this.helper, o = this.options, props = {},\n      self = this, smp = this.originalMousePosition, a = this.axis;\n\n    var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;\n    var trigger = this._change[a];\n    if (!trigger) return false;\n\n    // Calculate the attrs that will be change\n    var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;\n\n    // Put this in the mouseDrag handler since the user can start pressing shift while resizing\n    this._updateVirtualBoundaries(event.shiftKey);\n    if (this._aspectRatio || event.shiftKey)\n      data = this._updateRatio(data, event);\n\n    data = this._respectSize(data, event);\n\n    // plugins callbacks need to be called first\n    this._propagate(\"resize\", event);\n\n    el.css({\n      top: this.position.top + \"px\", left: this.position.left + \"px\",\n      width: this.size.width + \"px\", height: this.size.height + \"px\"\n    });\n\n    if (!this._helper && this._proportionallyResizeElements.length)\n      this._proportionallyResize();\n\n    this._updateCache(data);\n\n    // calling the user callback at the end\n    this._trigger('resize', event, this.ui());\n\n    return false;\n  },\n\n  _mouseStop: function(event) {\n\n    this.resizing = false;\n    var o = this.options, self = this;\n\n    if(this._helper) {\n      var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),\n        soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,\n        soffsetw = ista ? 0 : self.sizeDiff.width;\n\n      var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },\n        left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,\n        top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;\n\n      if (!o.animate)\n        this.element.css($.extend(s, { top: top, left: left }));\n\n      self.helper.height(self.size.height);\n      self.helper.width(self.size.width);\n\n      if (this._helper && !o.animate) this._proportionallyResize();\n    }\n\n    $('body').css('cursor', 'auto');\n\n    this.element.removeClass(\"ui-resizable-resizing\");\n\n    this._propagate(\"stop\", event);\n\n    if (this._helper) this.helper.remove();\n    return false;\n\n  },\n\n    _updateVirtualBoundaries: function(forceAspectRatio) {\n        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;\n\n        b = {\n            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,\n            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,\n            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,\n            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity\n        };\n\n        if(this._aspectRatio || forceAspectRatio) {\n            // We want to create an enclosing box whose aspect ration is the requested one\n            // First, compute the \"projected\" size for each dimension based on the aspect ratio and other dimension\n            pMinWidth = b.minHeight * this.aspectRatio;\n            pMinHeight = b.minWidth / this.aspectRatio;\n            pMaxWidth = b.maxHeight * this.aspectRatio;\n            pMaxHeight = b.maxWidth / this.aspectRatio;\n\n            if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;\n            if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;\n            if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;\n            if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;\n        }\n        this._vBoundaries = b;\n    },\n\n  _updateCache: function(data) {\n    var o = this.options;\n    this.offset = this.helper.offset();\n    if (isNumber(data.left)) this.position.left = data.left;\n    if (isNumber(data.top)) this.position.top = data.top;\n    if (isNumber(data.height)) this.size.height = data.height;\n    if (isNumber(data.width)) this.size.width = data.width;\n  },\n\n  _updateRatio: function(data, event) {\n\n    var o = this.options, cpos = this.position, csize = this.size, a = this.axis;\n\n    if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);\n    else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);\n\n    if (a == 'sw') {\n      data.left = cpos.left + (csize.width - data.width);\n      data.top = null;\n    }\n    if (a == 'nw') {\n      data.top = cpos.top + (csize.height - data.height);\n      data.left = cpos.left + (csize.width - data.width);\n    }\n\n    return data;\n  },\n\n  _respectSize: function(data, event) {\n\n    var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,\n        ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),\n          isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);\n\n    if (isminw) data.width = o.minWidth;\n    if (isminh) data.height = o.minHeight;\n    if (ismaxw) data.width = o.maxWidth;\n    if (ismaxh) data.height = o.maxHeight;\n\n    var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;\n    var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);\n\n    if (isminw && cw) data.left = dw - o.minWidth;\n    if (ismaxw && cw) data.left = dw - o.maxWidth;\n    if (isminh && ch) data.top = dh - o.minHeight;\n    if (ismaxh && ch) data.top = dh - o.maxHeight;\n\n    // fixing jump error on top/left - bug #2330\n    var isNotwh = !data.width && !data.height;\n    if (isNotwh && !data.left && data.top) data.top = null;\n    else if (isNotwh && !data.top && data.left) data.left = null;\n\n    return data;\n  },\n\n  _proportionallyResize: function() {\n\n    var o = this.options;\n    if (!this._proportionallyResizeElements.length) return;\n    var element = this.helper || this.element;\n\n    for (var i=0; i < this._proportionallyResizeElements.length; i++) {\n\n      var prel = this._proportionallyResizeElements[i];\n\n      if (!this.borderDif) {\n        var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],\n          p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];\n\n        this.borderDif = $.map(b, function(v, i) {\n          var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;\n          return border + padding;\n        });\n      }\n\n      if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))\n        continue;\n\n      prel.css({\n        height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,\n        width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0\n      });\n\n    };\n\n  },\n\n  _renderProxy: function() {\n\n    var el = this.element, o = this.options;\n    this.elementOffset = el.offset();\n\n    if(this._helper) {\n\n      this.helper = this.helper || $('<div style=\"overflow:hidden;\"></div>');\n\n      // fix ie6 offset TODO: This seems broken\n      var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),\n      pxyoffset = ( ie6 ? 2 : -1 );\n\n      this.helper.addClass(this._helper).css({\n        width: this.element.outerWidth() + pxyoffset,\n        height: this.element.outerHeight() + pxyoffset,\n        position: 'absolute',\n        left: this.elementOffset.left - ie6offset +'px',\n        top: this.elementOffset.top - ie6offset +'px',\n        zIndex: ++o.zIndex //TODO: Don't modify option\n      });\n\n      this.helper\n        .appendTo(\"body\")\n        .disableSelection();\n\n    } else {\n      this.helper = this.element;\n    }\n\n  },\n\n  _change: {\n    e: function(event, dx, dy) {\n      return { width: this.originalSize.width + dx };\n    },\n    w: function(event, dx, dy) {\n      var o = this.options, cs = this.originalSize, sp = this.originalPosition;\n      return { left: sp.left + dx, width: cs.width - dx };\n    },\n    n: function(event, dx, dy) {\n      var o = this.options, cs = this.originalSize, sp = this.originalPosition;\n      return { top: sp.top + dy, height: cs.height - dy };\n    },\n    s: function(event, dx, dy) {\n      return { height: this.originalSize.height + dy };\n    },\n    se: function(event, dx, dy) {\n      return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\n    },\n    sw: function(event, dx, dy) {\n      return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\n    },\n    ne: function(event, dx, dy) {\n      return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\n    },\n    nw: function(event, dx, dy) {\n      return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\n    }\n  },\n\n  _propagate: function(n, event) {\n    $.ui.plugin.call(this, n, [event, this.ui()]);\n    (n != \"resize\" && this._trigger(n, event, this.ui()));\n  },\n\n  plugins: {},\n\n  ui: function() {\n    return {\n      originalElement: this.originalElement,\n      element: this.element,\n      helper: this.helper,\n      position: this.position,\n      size: this.size,\n      originalSize: this.originalSize,\n      originalPosition: this.originalPosition\n    };\n  }\n\n});\n\n$.extend($.ui.resizable, {\n  version: \"1.8.18\"\n});\n\n/*\n * Resizable Extensions\n */\n\n$.ui.plugin.add(\"resizable\", \"alsoResize\", {\n\n  start: function (event, ui) {\n    var self = $(this).data(\"resizable\"), o = self.options;\n\n    var _store = function (exp) {\n      $(exp).each(function() {\n        var el = $(this);\n        el.data(\"resizable-alsoresize\", {\n          width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),\n          left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)\n        });\n      });\n    };\n\n    if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {\n      if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }\n      else { $.each(o.alsoResize, function (exp) { _store(exp); }); }\n    }else{\n      _store(o.alsoResize);\n    }\n  },\n\n  resize: function (event, ui) {\n    var self = $(this).data(\"resizable\"), o = self.options, os = self.originalSize, op = self.originalPosition;\n\n    var delta = {\n      height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,\n      top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0\n    },\n\n    _alsoResize = function (exp, c) {\n      $(exp).each(function() {\n        var el = $(this), start = $(this).data(\"resizable-alsoresize\"), style = {}, \n          css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];\n\n        $.each(css, function (i, prop) {\n          var sum = (start[prop]||0) + (delta[prop]||0);\n          if (sum && sum >= 0)\n            style[prop] = sum || null;\n        });\n\n        el.css(style);\n      });\n    };\n\n    if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {\n      $.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });\n    }else{\n      _alsoResize(o.alsoResize);\n    }\n  },\n\n  stop: function (event, ui) {\n    $(this).removeData(\"resizable-alsoresize\");\n  }\n});\n\n$.ui.plugin.add(\"resizable\", \"animate\", {\n\n  stop: function(event, ui) {\n    var self = $(this).data(\"resizable\"), o = self.options;\n\n    var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),\n          soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,\n            soffsetw = ista ? 0 : self.sizeDiff.width;\n\n    var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },\n          left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,\n            top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;\n\n    self.element.animate(\n      $.extend(style, top && left ? { top: top, left: left } : {}), {\n        duration: o.animateDuration,\n        easing: o.animateEasing,\n        step: function() {\n\n          var data = {\n            width: parseInt(self.element.css('width'), 10),\n            height: parseInt(self.element.css('height'), 10),\n            top: parseInt(self.element.css('top'), 10),\n            left: parseInt(self.element.css('left'), 10)\n          };\n\n          if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });\n\n          // propagating resize, and updating values for each animation step\n          self._updateCache(data);\n          self._propagate(\"resize\", event);\n\n        }\n      }\n    );\n  }\n\n});\n\n$.ui.plugin.add(\"resizable\", \"containment\", {\n\n  start: function(event, ui) {\n    var self = $(this).data(\"resizable\"), o = self.options, el = self.element;\n    var oc = o.containment, ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;\n    if (!ce) return;\n\n    self.containerElement = $(ce);\n\n    if (/document/.test(oc) || oc == document) {\n      self.containerOffset = { left: 0, top: 0 };\n      self.containerPosition = { left: 0, top: 0 };\n\n      self.parentData = {\n        element: $(document), left: 0, top: 0,\n        width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight\n      };\n    }\n\n    // i'm a node, so compute top, left, right, bottom\n    else {\n      var element = $(ce), p = [];\n      $([ \"Top\", \"Right\", \"Left\", \"Bottom\" ]).each(function(i, name) { p[i] = num(element.css(\"padding\" + name)); });\n\n      self.containerOffset = element.offset();\n      self.containerPosition = element.position();\n      self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };\n\n      var co = self.containerOffset, ch = self.containerSize.height,  cw = self.containerSize.width,\n            width = ($.ui.hasScroll(ce, \"left\") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);\n\n      self.parentData = {\n        element: ce, left: co.left, top: co.top, width: width, height: height\n      };\n    }\n  },\n\n  resize: function(event, ui) {\n    var self = $(this).data(\"resizable\"), o = self.options,\n        ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,\n        pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;\n\n    if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;\n\n    if (cp.left < (self._helper ? co.left : 0)) {\n      self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));\n      if (pRatio) self.size.height = self.size.width / o.aspectRatio;\n      self.position.left = o.helper ? co.left : 0;\n    }\n\n    if (cp.top < (self._helper ? co.top : 0)) {\n      self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);\n      if (pRatio) self.size.width = self.size.height * o.aspectRatio;\n      self.position.top = self._helper ? co.top : 0;\n    }\n\n    self.offset.left = self.parentData.left+self.position.left;\n    self.offset.top = self.parentData.top+self.position.top;\n\n    var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),\n          hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );\n\n    var isParent = self.containerElement.get(0) == self.element.parent().get(0),\n        isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));\n\n    if(isParent && isOffsetRelative) woset -= self.parentData.left;\n\n    if (woset + self.size.width >= self.parentData.width) {\n      self.size.width = self.parentData.width - woset;\n      if (pRatio) self.size.height = self.size.width / self.aspectRatio;\n    }\n\n    if (hoset + self.size.height >= self.parentData.height) {\n      self.size.height = self.parentData.height - hoset;\n      if (pRatio) self.size.width = self.size.height * self.aspectRatio;\n    }\n  },\n\n  stop: function(event, ui){\n    var self = $(this).data(\"resizable\"), o = self.options, cp = self.position,\n        co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;\n\n    var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;\n\n    if (self._helper && !o.animate && (/relative/).test(ce.css('position')))\n      $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });\n\n    if (self._helper && !o.animate && (/static/).test(ce.css('position')))\n      $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });\n\n  }\n});\n\n$.ui.plugin.add(\"resizable\", \"ghost\", {\n\n  start: function(event, ui) {\n\n    var self = $(this).data(\"resizable\"), o = self.options, cs = self.size;\n\n    self.ghost = self.originalElement.clone();\n    self.ghost\n      .css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })\n      .addClass('ui-resizable-ghost')\n      .addClass(typeof o.ghost == 'string' ? o.ghost : '');\n\n    self.ghost.appendTo(self.helper);\n\n  },\n\n  resize: function(event, ui){\n    var self = $(this).data(\"resizable\"), o = self.options;\n    if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });\n  },\n\n  stop: function(event, ui){\n    var self = $(this).data(\"resizable\"), o = self.options;\n    if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));\n  }\n\n});\n\n$.ui.plugin.add(\"resizable\", \"grid\", {\n\n  resize: function(event, ui) {\n    var self = $(this).data(\"resizable\"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;\n    o.grid = typeof o.grid == \"number\" ? [o.grid, o.grid] : o.grid;\n    var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);\n\n    if (/^(se|s|e)$/.test(a)) {\n      self.size.width = os.width + ox;\n      self.size.height = os.height + oy;\n    }\n    else if (/^(ne)$/.test(a)) {\n      self.size.width = os.width + ox;\n      self.size.height = os.height + oy;\n      self.position.top = op.top - oy;\n    }\n    else if (/^(sw)$/.test(a)) {\n      self.size.width = os.width + ox;\n      self.size.height = os.height + oy;\n      self.position.left = op.left - ox;\n    }\n    else {\n      self.size.width = os.width + ox;\n      self.size.height = os.height + oy;\n      self.position.top = op.top - oy;\n      self.position.left = op.left - ox;\n    }\n  }\n\n});\n\nvar num = function(v) {\n  return parseInt(v, 10) || 0;\n};\n\nvar isNumber = function(value) {\n  return !isNaN(parseInt(value, 10));\n};\n\n})(jQuery);\n/*\n * jQuery UI Selectable 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Selectables\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.mouse.js\n *  jquery.ui.widget.js\n */\n(function( $, undefined ) {\n\n$.widget(\"ui.selectable\", $.ui.mouse, {\n  options: {\n    appendTo: 'body',\n    autoRefresh: true,\n    distance: 0,\n    filter: '*',\n    tolerance: 'touch'\n  },\n  _create: function() {\n    var self = this;\n\n    this.element.addClass(\"ui-selectable\");\n\n    this.dragged = false;\n\n    // cache selectee children based on filter\n    var selectees;\n    this.refresh = function() {\n      selectees = $(self.options.filter, self.element[0]);\n      selectees.addClass(\"ui-selectee\");\n      selectees.each(function() {\n        var $this = $(this);\n        var pos = $this.offset();\n        $.data(this, \"selectable-item\", {\n          element: this,\n          $element: $this,\n          left: pos.left,\n          top: pos.top,\n          right: pos.left + $this.outerWidth(),\n          bottom: pos.top + $this.outerHeight(),\n          startselected: false,\n          selected: $this.hasClass('ui-selected'),\n          selecting: $this.hasClass('ui-selecting'),\n          unselecting: $this.hasClass('ui-unselecting')\n        });\n      });\n    };\n    this.refresh();\n\n    this.selectees = selectees.addClass(\"ui-selectee\");\n\n    this._mouseInit();\n\n    this.helper = $(\"<div class='ui-selectable-helper'></div>\");\n  },\n\n  destroy: function() {\n    this.selectees\n      .removeClass(\"ui-selectee\")\n      .removeData(\"selectable-item\");\n    this.element\n      .removeClass(\"ui-selectable ui-selectable-disabled\")\n      .removeData(\"selectable\")\n      .unbind(\".selectable\");\n    this._mouseDestroy();\n\n    return this;\n  },\n\n  _mouseStart: function(event) {\n    var self = this;\n\n    this.opos = [event.pageX, event.pageY];\n\n    if (this.options.disabled)\n      return;\n\n    var options = this.options;\n\n    this.selectees = $(options.filter, this.element[0]);\n\n    this._trigger(\"start\", event);\n\n    $(options.appendTo).append(this.helper);\n    // position helper (lasso)\n    this.helper.css({\n      \"left\": event.clientX,\n      \"top\": event.clientY,\n      \"width\": 0,\n      \"height\": 0\n    });\n\n    if (options.autoRefresh) {\n      this.refresh();\n    }\n\n    this.selectees.filter('.ui-selected').each(function() {\n      var selectee = $.data(this, \"selectable-item\");\n      selectee.startselected = true;\n      if (!event.metaKey && !event.ctrlKey) {\n        selectee.$element.removeClass('ui-selected');\n        selectee.selected = false;\n        selectee.$element.addClass('ui-unselecting');\n        selectee.unselecting = true;\n        // selectable UNSELECTING callback\n        self._trigger(\"unselecting\", event, {\n          unselecting: selectee.element\n        });\n      }\n    });\n\n    $(event.target).parents().andSelf().each(function() {\n      var selectee = $.data(this, \"selectable-item\");\n      if (selectee) {\n        var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');\n        selectee.$element\n          .removeClass(doSelect ? \"ui-unselecting\" : \"ui-selected\")\n          .addClass(doSelect ? \"ui-selecting\" : \"ui-unselecting\");\n        selectee.unselecting = !doSelect;\n        selectee.selecting = doSelect;\n        selectee.selected = doSelect;\n        // selectable (UN)SELECTING callback\n        if (doSelect) {\n          self._trigger(\"selecting\", event, {\n            selecting: selectee.element\n          });\n        } else {\n          self._trigger(\"unselecting\", event, {\n            unselecting: selectee.element\n          });\n        }\n        return false;\n      }\n    });\n\n  },\n\n  _mouseDrag: function(event) {\n    var self = this;\n    this.dragged = true;\n\n    if (this.options.disabled)\n      return;\n\n    var options = this.options;\n\n    var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;\n    if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }\n    if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }\n    this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});\n\n    this.selectees.each(function() {\n      var selectee = $.data(this, \"selectable-item\");\n      //prevent helper from being selected if appendTo: selectable\n      if (!selectee || selectee.element == self.element[0])\n        return;\n      var hit = false;\n      if (options.tolerance == 'touch') {\n        hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );\n      } else if (options.tolerance == 'fit') {\n        hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);\n      }\n\n      if (hit) {\n        // SELECT\n        if (selectee.selected) {\n          selectee.$element.removeClass('ui-selected');\n          selectee.selected = false;\n        }\n        if (selectee.unselecting) {\n          selectee.$element.removeClass('ui-unselecting');\n          selectee.unselecting = false;\n        }\n        if (!selectee.selecting) {\n          selectee.$element.addClass('ui-selecting');\n          selectee.selecting = true;\n          // selectable SELECTING callback\n          self._trigger(\"selecting\", event, {\n            selecting: selectee.element\n          });\n        }\n      } else {\n        // UNSELECT\n        if (selectee.selecting) {\n          if ((event.metaKey || event.ctrlKey) && selectee.startselected) {\n            selectee.$element.removeClass('ui-selecting');\n            selectee.selecting = false;\n            selectee.$element.addClass('ui-selected');\n            selectee.selected = true;\n          } else {\n            selectee.$element.removeClass('ui-selecting');\n            selectee.selecting = false;\n            if (selectee.startselected) {\n              selectee.$element.addClass('ui-unselecting');\n              selectee.unselecting = true;\n            }\n            // selectable UNSELECTING callback\n            self._trigger(\"unselecting\", event, {\n              unselecting: selectee.element\n            });\n          }\n        }\n        if (selectee.selected) {\n          if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {\n            selectee.$element.removeClass('ui-selected');\n            selectee.selected = false;\n\n            selectee.$element.addClass('ui-unselecting');\n            selectee.unselecting = true;\n            // selectable UNSELECTING callback\n            self._trigger(\"unselecting\", event, {\n              unselecting: selectee.element\n            });\n          }\n        }\n      }\n    });\n\n    return false;\n  },\n\n  _mouseStop: function(event) {\n    var self = this;\n\n    this.dragged = false;\n\n    var options = this.options;\n\n    $('.ui-unselecting', this.element[0]).each(function() {\n      var selectee = $.data(this, \"selectable-item\");\n      selectee.$element.removeClass('ui-unselecting');\n      selectee.unselecting = false;\n      selectee.startselected = false;\n      self._trigger(\"unselected\", event, {\n        unselected: selectee.element\n      });\n    });\n    $('.ui-selecting', this.element[0]).each(function() {\n      var selectee = $.data(this, \"selectable-item\");\n      selectee.$element.removeClass('ui-selecting').addClass('ui-selected');\n      selectee.selecting = false;\n      selectee.selected = true;\n      selectee.startselected = true;\n      self._trigger(\"selected\", event, {\n        selected: selectee.element\n      });\n    });\n    this._trigger(\"stop\", event);\n\n    this.helper.remove();\n\n    return false;\n  }\n\n});\n\n$.extend($.ui.selectable, {\n  version: \"1.8.18\"\n});\n\n})(jQuery);\n/*\n * jQuery UI Sortable 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Sortables\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.mouse.js\n *  jquery.ui.widget.js\n */\n(function( $, undefined ) {\n\n$.widget(\"ui.sortable\", $.ui.mouse, {\n  widgetEventPrefix: \"sort\",\n  ready: false,\n  options: {\n    appendTo: \"parent\",\n    axis: false,\n    connectWith: false,\n    containment: false,\n    cursor: 'auto',\n    cursorAt: false,\n    dropOnEmpty: true,\n    forcePlaceholderSize: false,\n    forceHelperSize: false,\n    grid: false,\n    handle: false,\n    helper: \"original\",\n    items: '> *',\n    opacity: false,\n    placeholder: false,\n    revert: false,\n    scroll: true,\n    scrollSensitivity: 20,\n    scrollSpeed: 20,\n    scope: \"default\",\n    tolerance: \"intersect\",\n    zIndex: 1000\n  },\n  _create: function() {\n\n    var o = this.options;\n    this.containerCache = {};\n    this.element.addClass(\"ui-sortable\");\n\n    //Get the items\n    this.refresh();\n\n    //Let's determine if the items are being displayed horizontally\n    this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;\n\n    //Let's determine the parent's offset\n    this.offset = this.element.offset();\n\n    //Initialize mouse events for interaction\n    this._mouseInit();\n    \n    //We're ready to go\n    this.ready = true\n\n  },\n\n  destroy: function() {\n    $.Widget.prototype.destroy.call( this );\n    this.element\n      .removeClass(\"ui-sortable ui-sortable-disabled\");\n    this._mouseDestroy();\n\n    for ( var i = this.items.length - 1; i >= 0; i-- )\n      this.items[i].item.removeData(this.widgetName + \"-item\");\n\n    return this;\n  },\n\n  _setOption: function(key, value){\n    if ( key === \"disabled\" ) {\n      this.options[ key ] = value;\n  \n      this.widget()\n        [ value ? \"addClass\" : \"removeClass\"]( \"ui-sortable-disabled\" );\n    } else {\n      // Don't call widget base _setOption for disable as it adds ui-state-disabled class\n      $.Widget.prototype._setOption.apply(this, arguments);\n    }\n  },\n\n  _mouseCapture: function(event, overrideHandle) {\n    var that = this;\n\n    if (this.reverting) {\n      return false;\n    }\n\n    if(this.options.disabled || this.options.type == 'static') return false;\n\n    //We have to refresh the items data once first\n    this._refreshItems(event);\n\n    //Find out if the clicked node (or one of its parents) is a actual item in this.items\n    var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {\n      if($.data(this, that.widgetName + '-item') == self) {\n        currentItem = $(this);\n        return false;\n      }\n    });\n    if($.data(event.target, that.widgetName + '-item') == self) currentItem = $(event.target);\n\n    if(!currentItem) return false;\n    if(this.options.handle && !overrideHandle) {\n      var validHandle = false;\n\n      $(this.options.handle, currentItem).find(\"*\").andSelf().each(function() { if(this == event.target) validHandle = true; });\n      if(!validHandle) return false;\n    }\n\n    this.currentItem = currentItem;\n    this._removeCurrentsFromItems();\n    return true;\n\n  },\n\n  _mouseStart: function(event, overrideHandle, noActivation) {\n\n    var o = this.options, self = this;\n    this.currentContainer = this;\n\n    //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n    this.refreshPositions();\n\n    //Create and append the visible helper\n    this.helper = this._createHelper(event);\n\n    //Cache the helper size\n    this._cacheHelperProportions();\n\n    /*\n     * - Position generation -\n     * This block generates everything position related - it's the core of draggables.\n     */\n\n    //Cache the margins of the original element\n    this._cacheMargins();\n\n    //Get the next scrolling parent\n    this.scrollParent = this.helper.scrollParent();\n\n    //The element's absolute position on the page minus margins\n    this.offset = this.currentItem.offset();\n    this.offset = {\n      top: this.offset.top - this.margins.top,\n      left: this.offset.left - this.margins.left\n    };\n\n    // Only after we got the offset, we can change the helper's position to absolute\n    // TODO: Still need to figure out a way to make relative sorting possible\n    this.helper.css(\"position\", \"absolute\");\n    this.cssPosition = this.helper.css(\"position\");\n\n    $.extend(this.offset, {\n      click: { //Where the click happened, relative to the element\n        left: event.pageX - this.offset.left,\n        top: event.pageY - this.offset.top\n      },\n      parent: this._getParentOffset(),\n      relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n    });\n\n    //Generate the original position\n    this.originalPosition = this._generatePosition(event);\n    this.originalPageX = event.pageX;\n    this.originalPageY = event.pageY;\n\n    //Adjust the mouse offset relative to the helper if 'cursorAt' is supplied\n    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n    //Cache the former DOM position\n    this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\n\n    //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\n    if(this.helper[0] != this.currentItem[0]) {\n      this.currentItem.hide();\n    }\n\n    //Create the placeholder\n    this._createPlaceholder();\n\n    //Set a containment if given in the options\n    if(o.containment)\n      this._setContainment();\n\n    if(o.cursor) { // cursor option\n      if ($('body').css(\"cursor\")) this._storedCursor = $('body').css(\"cursor\");\n      $('body').css(\"cursor\", o.cursor);\n    }\n\n    if(o.opacity) { // opacity option\n      if (this.helper.css(\"opacity\")) this._storedOpacity = this.helper.css(\"opacity\");\n      this.helper.css(\"opacity\", o.opacity);\n    }\n\n    if(o.zIndex) { // zIndex option\n      if (this.helper.css(\"zIndex\")) this._storedZIndex = this.helper.css(\"zIndex\");\n      this.helper.css(\"zIndex\", o.zIndex);\n    }\n\n    //Prepare scrolling\n    if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')\n      this.overflowOffset = this.scrollParent.offset();\n\n    //Call callbacks\n    this._trigger(\"start\", event, this._uiHash());\n\n    //Recache the helper size\n    if(!this._preserveHelperProportions)\n      this._cacheHelperProportions();\n\n\n    //Post 'activate' events to possible containers\n    if(!noActivation) {\n       for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger(\"activate\", event, self._uiHash(this)); }\n    }\n\n    //Prepare possible droppables\n    if($.ui.ddmanager)\n      $.ui.ddmanager.current = this;\n\n    if ($.ui.ddmanager && !o.dropBehaviour)\n      $.ui.ddmanager.prepareOffsets(this, event);\n\n    this.dragging = true;\n\n    this.helper.addClass(\"ui-sortable-helper\");\n    this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n    return true;\n\n  },\n\n  _mouseDrag: function(event) {\n\n    //Compute the helpers position\n    this.position = this._generatePosition(event);\n    this.positionAbs = this._convertPositionTo(\"absolute\");\n\n    if (!this.lastPositionAbs) {\n      this.lastPositionAbs = this.positionAbs;\n    }\n\n    //Do scrolling\n    if(this.options.scroll) {\n      var o = this.options, scrolled = false;\n      if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {\n\n        if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)\n          this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n        else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)\n          this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n\n        if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)\n          this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n        else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)\n          this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n\n      } else {\n\n        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)\n          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n        else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)\n          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n\n        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)\n          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n        else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)\n          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n\n      }\n\n      if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)\n        $.ui.ddmanager.prepareOffsets(this, event);\n    }\n\n    //Regenerate the absolute position used for position checks\n    this.positionAbs = this._convertPositionTo(\"absolute\");\n\n    //Set the helper position\n    if(!this.options.axis || this.options.axis != \"y\") this.helper[0].style.left = this.position.left+'px';\n    if(!this.options.axis || this.options.axis != \"x\") this.helper[0].style.top = this.position.top+'px';\n\n    //Rearrange\n    for (var i = this.items.length - 1; i >= 0; i--) {\n\n      //Cache variables and intersection, continue if no intersection\n      var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);\n      if (!intersection) continue;\n\n      if(itemElement != this.currentItem[0] //cannot intersect with itself\n        &&  this.placeholder[intersection == 1 ? \"next\" : \"prev\"]()[0] != itemElement //no useless actions that have been done before\n        &&  !$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked\n        && (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)\n        //&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container\n      ) {\n\n        this.direction = intersection == 1 ? \"down\" : \"up\";\n\n        if (this.options.tolerance == \"pointer\" || this._intersectsWithSides(item)) {\n          this._rearrange(event, item);\n        } else {\n          break;\n        }\n\n        this._trigger(\"change\", event, this._uiHash());\n        break;\n      }\n    }\n\n    //Post events to containers\n    this._contactContainers(event);\n\n    //Interconnect with droppables\n    if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);\n\n    //Call callbacks\n    this._trigger('sort', event, this._uiHash());\n\n    this.lastPositionAbs = this.positionAbs;\n    return false;\n\n  },\n\n  _mouseStop: function(event, noPropagation) {\n\n    if(!event) return;\n\n    //If we are using droppables, inform the manager about the drop\n    if ($.ui.ddmanager && !this.options.dropBehaviour)\n      $.ui.ddmanager.drop(this, event);\n\n    if(this.options.revert) {\n      var self = this;\n      var cur = self.placeholder.offset();\n\n      self.reverting = true;\n\n      $(this.helper).animate({\n        left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),\n        top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)\n      }, parseInt(this.options.revert, 10) || 500, function() {\n        self._clear(event);\n      });\n    } else {\n      this._clear(event, noPropagation);\n    }\n\n    return false;\n\n  },\n\n  cancel: function() {\n\n    var self = this;\n\n    if(this.dragging) {\n\n      this._mouseUp({ target: null });\n\n      if(this.options.helper == \"original\")\n        this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n      else\n        this.currentItem.show();\n\n      //Post deactivating events to containers\n      for (var i = this.containers.length - 1; i >= 0; i--){\n        this.containers[i]._trigger(\"deactivate\", null, self._uiHash(this));\n        if(this.containers[i].containerCache.over) {\n          this.containers[i]._trigger(\"out\", null, self._uiHash(this));\n          this.containers[i].containerCache.over = 0;\n        }\n      }\n\n    }\n\n    if (this.placeholder) {\n      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n      if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n      if(this.options.helper != \"original\" && this.helper && this.helper[0].parentNode) this.helper.remove();\n\n      $.extend(this, {\n        helper: null,\n        dragging: false,\n        reverting: false,\n        _noFinalSort: null\n      });\n\n      if(this.domPosition.prev) {\n        $(this.domPosition.prev).after(this.currentItem);\n      } else {\n        $(this.domPosition.parent).prepend(this.currentItem);\n      }\n    }\n\n    return this;\n\n  },\n\n  serialize: function(o) {\n\n    var items = this._getItemsAsjQuery(o && o.connected);\n    var str = []; o = o || {};\n\n    $(items).each(function() {\n      var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));\n      if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));\n    });\n\n    if(!str.length && o.key) {\n      str.push(o.key + '=');\n    }\n\n    return str.join('&');\n\n  },\n\n  toArray: function(o) {\n\n    var items = this._getItemsAsjQuery(o && o.connected);\n    var ret = []; o = o || {};\n\n    items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });\n    return ret;\n\n  },\n\n  /* Be careful with the following core functions */\n  _intersectsWith: function(item) {\n\n    var x1 = this.positionAbs.left,\n      x2 = x1 + this.helperProportions.width,\n      y1 = this.positionAbs.top,\n      y2 = y1 + this.helperProportions.height;\n\n    var l = item.left,\n      r = l + item.width,\n      t = item.top,\n      b = t + item.height;\n\n    var dyClick = this.offset.click.top,\n      dxClick = this.offset.click.left;\n\n    var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;\n\n    if(    this.options.tolerance == \"pointer\"\n      || this.options.forcePointerForContainers\n      || (this.options.tolerance != \"pointer\" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])\n    ) {\n      return isOverElement;\n    } else {\n\n      return (l < x1 + (this.helperProportions.width / 2) // Right Half\n        && x2 - (this.helperProportions.width / 2) < r // Left Half\n        && t < y1 + (this.helperProportions.height / 2) // Bottom Half\n        && y2 - (this.helperProportions.height / 2) < b ); // Top Half\n\n    }\n  },\n\n  _intersectsWithPointer: function(item) {\n\n    var isOverElementHeight = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n      isOverElementWidth = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n      isOverElement = isOverElementHeight && isOverElementWidth,\n      verticalDirection = this._getDragVerticalDirection(),\n      horizontalDirection = this._getDragHorizontalDirection();\n\n    if (!isOverElement)\n      return false;\n\n    return this.floating ?\n      ( ((horizontalDirection && horizontalDirection == \"right\") || verticalDirection == \"down\") ? 2 : 1 )\n      : ( verticalDirection && (verticalDirection == \"down\" ? 2 : 1) );\n\n  },\n\n  _intersectsWithSides: function(item) {\n\n    var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\n      isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\n      verticalDirection = this._getDragVerticalDirection(),\n      horizontalDirection = this._getDragHorizontalDirection();\n\n    if (this.floating && horizontalDirection) {\n      return ((horizontalDirection == \"right\" && isOverRightHalf) || (horizontalDirection == \"left\" && !isOverRightHalf));\n    } else {\n      return verticalDirection && ((verticalDirection == \"down\" && isOverBottomHalf) || (verticalDirection == \"up\" && !isOverBottomHalf));\n    }\n\n  },\n\n  _getDragVerticalDirection: function() {\n    var delta = this.positionAbs.top - this.lastPositionAbs.top;\n    return delta != 0 && (delta > 0 ? \"down\" : \"up\");\n  },\n\n  _getDragHorizontalDirection: function() {\n    var delta = this.positionAbs.left - this.lastPositionAbs.left;\n    return delta != 0 && (delta > 0 ? \"right\" : \"left\");\n  },\n\n  refresh: function(event) {\n    this._refreshItems(event);\n    this.refreshPositions();\n    return this;\n  },\n\n  _connectWith: function() {\n    var options = this.options;\n    return options.connectWith.constructor == String\n      ? [options.connectWith]\n      : options.connectWith;\n  },\n  \n  _getItemsAsjQuery: function(connected) {\n\n    var self = this;\n    var items = [];\n    var queries = [];\n    var connectWith = this._connectWith();\n\n    if(connectWith && connected) {\n      for (var i = connectWith.length - 1; i >= 0; i--){\n        var cur = $(connectWith[i]);\n        for (var j = cur.length - 1; j >= 0; j--){\n          var inst = $.data(cur[j], this.widgetName);\n          if(inst && inst != this && !inst.options.disabled) {\n            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\".ui-sortable-helper\").not('.ui-sortable-placeholder'), inst]);\n          }\n        };\n      };\n    }\n\n    queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(\".ui-sortable-helper\").not('.ui-sortable-placeholder'), this]);\n\n    for (var i = queries.length - 1; i >= 0; i--){\n      queries[i][0].each(function() {\n        items.push(this);\n      });\n    };\n\n    return $(items);\n\n  },\n\n  _removeCurrentsFromItems: function() {\n\n    var list = this.currentItem.find(\":data(\" + this.widgetName + \"-item)\");\n\n    for (var i=0; i < this.items.length; i++) {\n\n      for (var j=0; j < list.length; j++) {\n        if(list[j] == this.items[i].item[0])\n          this.items.splice(i,1);\n      };\n\n    };\n\n  },\n\n  _refreshItems: function(event) {\n\n    this.items = [];\n    this.containers = [this];\n    var items = this.items;\n    var self = this;\n    var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];\n    var connectWith = this._connectWith();\n\n    if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\n      for (var i = connectWith.length - 1; i >= 0; i--){\n        var cur = $(connectWith[i]);\n        for (var j = cur.length - 1; j >= 0; j--){\n          var inst = $.data(cur[j], this.widgetName);\n          if(inst && inst != this && !inst.options.disabled) {\n            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\n            this.containers.push(inst);\n          }\n        };\n      };\n    }\n\n    for (var i = queries.length - 1; i >= 0; i--) {\n      var targetData = queries[i][1];\n      var _queries = queries[i][0];\n\n      for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {\n        var item = $(_queries[j]);\n\n        item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)\n\n        items.push({\n          item: item,\n          instance: targetData,\n          width: 0, height: 0,\n          left: 0, top: 0\n        });\n      };\n    };\n\n  },\n\n  refreshPositions: function(fast) {\n\n    //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\n    if(this.offsetParent && this.helper) {\n      this.offset.parent = this._getParentOffset();\n    }\n\n    for (var i = this.items.length - 1; i >= 0; i--){\n      var item = this.items[i];\n\n      //We ignore calculating positions of all connected containers when we're not over them\n      if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])\n        continue;\n\n      var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n      if (!fast) {\n        item.width = t.outerWidth();\n        item.height = t.outerHeight();\n      }\n\n      var p = t.offset();\n      item.left = p.left;\n      item.top = p.top;\n    };\n\n    if(this.options.custom && this.options.custom.refreshContainers) {\n      this.options.custom.refreshContainers.call(this);\n    } else {\n      for (var i = this.containers.length - 1; i >= 0; i--){\n        var p = this.containers[i].element.offset();\n        this.containers[i].containerCache.left = p.left;\n        this.containers[i].containerCache.top = p.top;\n        this.containers[i].containerCache.width = this.containers[i].element.outerWidth();\n        this.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n      };\n    }\n\n    return this;\n  },\n\n  _createPlaceholder: function(that) {\n\n    var self = that || this, o = self.options;\n\n    if(!o.placeholder || o.placeholder.constructor == String) {\n      var className = o.placeholder;\n      o.placeholder = {\n        element: function() {\n\n          var el = $(document.createElement(self.currentItem[0].nodeName))\n            .addClass(className || self.currentItem[0].className+\" ui-sortable-placeholder\")\n            .removeClass(\"ui-sortable-helper\")[0];\n\n          if(!className)\n            el.style.visibility = \"hidden\";\n\n          return el;\n        },\n        update: function(container, p) {\n\n          // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\n          // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\n          if(className && !o.forcePlaceholderSize) return;\n\n          //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n          if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };\n          if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };\n        }\n      };\n    }\n\n    //Create the placeholder\n    self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));\n\n    //Append it after the actual current item\n    self.currentItem.after(self.placeholder);\n\n    //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n    o.placeholder.update(self, self.placeholder);\n\n  },\n\n  _contactContainers: function(event) {\n    \n    // get innermost container that intersects with item \n    var innermostContainer = null, innermostIndex = null;   \n    \n    \n    for (var i = this.containers.length - 1; i >= 0; i--){\n\n      // never consider a container that's located within the item itself \n      if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))\n        continue;\n\n      if(this._intersectsWith(this.containers[i].containerCache)) {\n\n        // if we've already found a container and it's more \"inner\" than this, then continue \n        if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))\n          continue;\n\n        innermostContainer = this.containers[i]; \n        innermostIndex = i;\n          \n      } else {\n        // container doesn't intersect. trigger \"out\" event if necessary \n        if(this.containers[i].containerCache.over) {\n          this.containers[i]._trigger(\"out\", event, this._uiHash(this));\n          this.containers[i].containerCache.over = 0;\n        }\n      }\n\n    }\n    \n    // if no intersecting containers found, return \n    if(!innermostContainer) return; \n\n    // move the item into the container if it's not there already\n    if(this.containers.length === 1) {\n      this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n      this.containers[innermostIndex].containerCache.over = 1;\n    } else if(this.currentContainer != this.containers[innermostIndex]) { \n\n      //When entering a new container, we will find the item with the least distance and append our item near it \n      var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top']; \n      for (var j = this.items.length - 1; j >= 0; j--) { \n        if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue; \n        var cur = this.items[j][this.containers[innermostIndex].floating ? 'left' : 'top']; \n        if(Math.abs(cur - base) < dist) { \n          dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j]; \n        } \n      } \n\n      if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled \n        return; \n\n      this.currentContainer = this.containers[innermostIndex]; \n      itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true); \n      this._trigger(\"change\", event, this._uiHash()); \n      this.containers[innermostIndex]._trigger(\"change\", event, this._uiHash(this)); \n\n      //Update the placeholder \n      this.options.placeholder.update(this.currentContainer, this.placeholder); \n    \n      this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this)); \n      this.containers[innermostIndex].containerCache.over = 1;\n    } \n  \n    \n  },\n\n  _createHelper: function(event) {\n\n    var o = this.options;\n    var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);\n\n    if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already\n      $(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n\n    if(helper[0] == this.currentItem[0])\n      this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(\"position\"), top: this.currentItem.css(\"top\"), left: this.currentItem.css(\"left\") };\n\n    if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());\n    if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());\n\n    return helper;\n\n  },\n\n  _adjustOffsetFromHelper: function(obj) {\n    if (typeof obj == 'string') {\n      obj = obj.split(' ');\n    }\n    if ($.isArray(obj)) {\n      obj = {left: +obj[0], top: +obj[1] || 0};\n    }\n    if ('left' in obj) {\n      this.offset.click.left = obj.left + this.margins.left;\n    }\n    if ('right' in obj) {\n      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n    }\n    if ('top' in obj) {\n      this.offset.click.top = obj.top + this.margins.top;\n    }\n    if ('bottom' in obj) {\n      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n    }\n  },\n\n  _getParentOffset: function() {\n\n\n    //Get the offsetParent and cache its position\n    this.offsetParent = this.helper.offsetParent();\n    var po = this.offsetParent.offset();\n\n    // This is a special case where we need to modify a offset calculated on start, since the following happened:\n    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n    if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {\n      po.left += this.scrollParent.scrollLeft();\n      po.top += this.scrollParent.scrollTop();\n    }\n\n    if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information\n    || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix\n      po = { top: 0, left: 0 };\n\n    return {\n      top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"),10) || 0),\n      left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"),10) || 0)\n    };\n\n  },\n\n  _getRelativeOffset: function() {\n\n    if(this.cssPosition == \"relative\") {\n      var p = this.currentItem.position();\n      return {\n        top: p.top - (parseInt(this.helper.css(\"top\"),10) || 0) + this.scrollParent.scrollTop(),\n        left: p.left - (parseInt(this.helper.css(\"left\"),10) || 0) + this.scrollParent.scrollLeft()\n      };\n    } else {\n      return { top: 0, left: 0 };\n    }\n\n  },\n\n  _cacheMargins: function() {\n    this.margins = {\n      left: (parseInt(this.currentItem.css(\"marginLeft\"),10) || 0),\n      top: (parseInt(this.currentItem.css(\"marginTop\"),10) || 0)\n    };\n  },\n\n  _cacheHelperProportions: function() {\n    this.helperProportions = {\n      width: this.helper.outerWidth(),\n      height: this.helper.outerHeight()\n    };\n  },\n\n  _setContainment: function() {\n\n    var o = this.options;\n    if(o.containment == 'parent') o.containment = this.helper[0].parentNode;\n    if(o.containment == 'document' || o.containment == 'window') this.containment = [\n      0 - this.offset.relative.left - this.offset.parent.left,\n      0 - this.offset.relative.top - this.offset.parent.top,\n      $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,\n      ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n    ];\n\n    if(!(/^(document|window|parent)$/).test(o.containment)) {\n      var ce = $(o.containment)[0];\n      var co = $(o.containment).offset();\n      var over = ($(ce).css(\"overflow\") != 'hidden');\n\n      this.containment = [\n        co.left + (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingLeft\"),10) || 0) - this.margins.left,\n        co.top + (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingTop\"),10) || 0) - this.margins.top,\n        co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingRight\"),10) || 0) - this.helperProportions.width - this.margins.left,\n        co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingBottom\"),10) || 0) - this.helperProportions.height - this.margins.top\n      ];\n    }\n\n  },\n\n  _convertPositionTo: function(d, pos) {\n\n    if(!pos) pos = this.position;\n    var mod = d == \"absolute\" ? 1 : -1;\n    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n    return {\n      top: (\n        pos.top                                 // The absolute mouse position\n        + this.offset.relative.top * mod                    // Only for relative positioned nodes: Relative offset from element to offset parent\n        + this.offset.parent.top * mod                      // The offsetParent's offset without borders (offset + border)\n        - ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n      ),\n      left: (\n        pos.left                                // The absolute mouse position\n        + this.offset.relative.left * mod                   // Only for relative positioned nodes: Relative offset from element to offset parent\n        + this.offset.parent.left * mod                     // The offsetParent's offset without borders (offset + border)\n        - ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n      )\n    };\n\n  },\n\n  _generatePosition: function(event) {\n\n    var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n    // This is another very weird special case that only happens for relative elements:\n    // 1. If the css position is relative\n    // 2. and the scroll parent is the document or similar to the offset parent\n    // we have to refresh the relative offset during the scroll so there are no jumps\n    if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {\n      this.offset.relative = this._getRelativeOffset();\n    }\n\n    var pageX = event.pageX;\n    var pageY = event.pageY;\n\n    /*\n     * - Position constraining -\n     * Constrain the position to a mix of grid, containment.\n     */\n\n    if(this.originalPosition) { //If we are not dragging yet, we won't check for options\n\n      if(this.containment) {\n        if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;\n        if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;\n        if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;\n        if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;\n      }\n\n      if(o.grid) {\n        var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n        pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n        var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n        pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n      }\n\n    }\n\n    return {\n      top: (\n        pageY                               // The absolute mouse position\n        - this.offset.click.top                         // Click offset (relative to the element)\n        - this.offset.relative.top                        // Only for relative positioned nodes: Relative offset from element to offset parent\n        - this.offset.parent.top                        // The offsetParent's offset without borders (offset + border)\n        + ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n      ),\n      left: (\n        pageX                               // The absolute mouse position\n        - this.offset.click.left                        // Click offset (relative to the element)\n        - this.offset.relative.left                       // Only for relative positioned nodes: Relative offset from element to offset parent\n        - this.offset.parent.left                       // The offsetParent's offset without borders (offset + border)\n        + ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n      )\n    };\n\n  },\n\n  _rearrange: function(event, i, a, hardRefresh) {\n\n    a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));\n\n    //Various things done here to improve the performance:\n    // 1. we create a setTimeout, that calls refreshPositions\n    // 2. on the instance, we have a counter variable, that get's higher after every append\n    // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\n    // 4. this lets only the last addition to the timeout stack through\n    this.counter = this.counter ? ++this.counter : 1;\n    var self = this, counter = this.counter;\n\n    window.setTimeout(function() {\n      if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n    },0);\n\n  },\n\n  _clear: function(event, noPropagation) {\n\n    this.reverting = false;\n    // We delay all events that have to be triggered to after the point where the placeholder has been removed and\n    // everything else normalized again\n    var delayedTriggers = [], self = this;\n\n    // We first have to update the dom position of the actual currentItem\n    // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n    if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);\n    this._noFinalSort = null;\n\n    if(this.helper[0] == this.currentItem[0]) {\n      for(var i in this._storedCSS) {\n        if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';\n      }\n      this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n    } else {\n      this.currentItem.show();\n    }\n\n    if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger(\"receive\", event, this._uiHash(this.fromOutside)); });\n    if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(\".ui-sortable-helper\")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger(\"update\", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\n    if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element\n      if(!noPropagation) delayedTriggers.push(function(event) { this._trigger(\"remove\", event, this._uiHash()); });\n      for (var i = this.containers.length - 1; i >= 0; i--){\n        if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {\n          delayedTriggers.push((function(c) { return function(event) { c._trigger(\"receive\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\n          delayedTriggers.push((function(c) { return function(event) { c._trigger(\"update\", event, this._uiHash(this));  }; }).call(this, this.containers[i]));\n        }\n      };\n    };\n\n    //Post events to containers\n    for (var i = this.containers.length - 1; i >= 0; i--){\n      if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger(\"deactivate\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\n      if(this.containers[i].containerCache.over) {\n        delayedTriggers.push((function(c) { return function(event) { c._trigger(\"out\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\n        this.containers[i].containerCache.over = 0;\n      }\n    }\n\n    //Do what was originally in plugins\n    if(this._storedCursor) $('body').css(\"cursor\", this._storedCursor); //Reset cursor\n    if(this._storedOpacity) this.helper.css(\"opacity\", this._storedOpacity); //Reset opacity\n    if(this._storedZIndex) this.helper.css(\"zIndex\", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index\n\n    this.dragging = false;\n    if(this.cancelHelperRemoval) {\n      if(!noPropagation) {\n        this._trigger(\"beforeStop\", event, this._uiHash());\n        for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events\n        this._trigger(\"stop\", event, this._uiHash());\n      }\n      return false;\n    }\n\n    if(!noPropagation) this._trigger(\"beforeStop\", event, this._uiHash());\n\n    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n    if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;\n\n    if(!noPropagation) {\n      for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events\n      this._trigger(\"stop\", event, this._uiHash());\n    }\n\n    this.fromOutside = false;\n    return true;\n\n  },\n\n  _trigger: function() {\n    if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n      this.cancel();\n    }\n  },\n\n  _uiHash: function(inst) {\n    var self = inst || this;\n    return {\n      helper: self.helper,\n      placeholder: self.placeholder || $([]),\n      position: self.position,\n      originalPosition: self.originalPosition,\n      offset: self.positionAbs,\n      item: self.currentItem,\n      sender: inst ? inst.element : null\n    };\n  }\n\n});\n\n$.extend($.ui.sortable, {\n  version: \"1.8.18\"\n});\n\n})(jQuery);\n/*\n * jQuery UI Autocomplete 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Autocomplete\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.widget.js\n *  jquery.ui.position.js\n */\n(function( $, undefined ) {\n\n// used to prevent race conditions with remote data sources\nvar requestIndex = 0;\n\n$.widget( \"ui.autocomplete\", {\n  options: {\n    appendTo: \"body\",\n    autoFocus: false,\n    delay: 300,\n    minLength: 1,\n    position: {\n      my: \"left top\",\n      at: \"left bottom\",\n      collision: \"none\"\n    },\n    source: null\n  },\n\n  pending: 0,\n\n  _create: function() {\n    var self = this,\n      doc = this.element[ 0 ].ownerDocument,\n      suppressKeyPress;\n\n    this.element\n      .addClass( \"ui-autocomplete-input\" )\n      .attr( \"autocomplete\", \"off\" )\n      // TODO verify these actually work as intended\n      .attr({\n        role: \"textbox\",\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"true\"\n      })\n      .bind( \"keydown.autocomplete\", function( event ) {\n        if ( self.options.disabled || self.element.propAttr( \"readOnly\" ) ) {\n          return;\n        }\n\n        suppressKeyPress = false;\n        var keyCode = $.ui.keyCode;\n        switch( event.keyCode ) {\n        case keyCode.PAGE_UP:\n          self._move( \"previousPage\", event );\n          break;\n        case keyCode.PAGE_DOWN:\n          self._move( \"nextPage\", event );\n          break;\n        case keyCode.UP:\n          self._move( \"previous\", event );\n          // prevent moving cursor to beginning of text field in some browsers\n          event.preventDefault();\n          break;\n        case keyCode.DOWN:\n          self._move( \"next\", event );\n          // prevent moving cursor to end of text field in some browsers\n          event.preventDefault();\n          break;\n        case keyCode.ENTER:\n        case keyCode.NUMPAD_ENTER:\n          // when menu is open and has focus\n          if ( self.menu.active ) {\n            // #6055 - Opera still allows the keypress to occur\n            // which causes forms to submit\n            suppressKeyPress = true;\n            event.preventDefault();\n          }\n          //passthrough - ENTER and TAB both select the current element\n        case keyCode.TAB:\n          if ( !self.menu.active ) {\n            return;\n          }\n          self.menu.select( event );\n          break;\n        case keyCode.ESCAPE:\n          self.element.val( self.term );\n          self.close( event );\n          break;\n        default:\n          // keypress is triggered before the input value is changed\n          clearTimeout( self.searching );\n          self.searching = setTimeout(function() {\n            // only search if the value has changed\n            if ( self.term != self.element.val() ) {\n              self.selectedItem = null;\n              self.search( null, event );\n            }\n          }, self.options.delay );\n          break;\n        }\n      })\n      .bind( \"keypress.autocomplete\", function( event ) {\n        if ( suppressKeyPress ) {\n          suppressKeyPress = false;\n          event.preventDefault();\n        }\n      })\n      .bind( \"focus.autocomplete\", function() {\n        if ( self.options.disabled ) {\n          return;\n        }\n\n        self.selectedItem = null;\n        self.previous = self.element.val();\n      })\n      .bind( \"blur.autocomplete\", function( event ) {\n        if ( self.options.disabled ) {\n          return;\n        }\n\n        clearTimeout( self.searching );\n        // clicks on the menu (or a button to trigger a search) will cause a blur event\n        self.closing = setTimeout(function() {\n          self.close( event );\n          self._change( event );\n        }, 150 );\n      });\n    this._initSource();\n    this.response = function() {\n      return self._response.apply( self, arguments );\n    };\n    this.menu = $( \"<ul></ul>\" )\n      .addClass( \"ui-autocomplete\" )\n      .appendTo( $( this.options.appendTo || \"body\", doc )[0] )\n      // prevent the close-on-blur in case of a \"slow\" click on the menu (long mousedown)\n      .mousedown(function( event ) {\n        // clicking on the scrollbar causes focus to shift to the body\n        // but we can't detect a mouseup or a click immediately afterward\n        // so we have to track the next mousedown and close the menu if\n        // the user clicks somewhere outside of the autocomplete\n        var menuElement = self.menu.element[ 0 ];\n        if ( !$( event.target ).closest( \".ui-menu-item\" ).length ) {\n          setTimeout(function() {\n            $( document ).one( 'mousedown', function( event ) {\n              if ( event.target !== self.element[ 0 ] &&\n                event.target !== menuElement &&\n                !$.ui.contains( menuElement, event.target ) ) {\n                self.close();\n              }\n            });\n          }, 1 );\n        }\n\n        // use another timeout to make sure the blur-event-handler on the input was already triggered\n        setTimeout(function() {\n          clearTimeout( self.closing );\n        }, 13);\n      })\n      .menu({\n        focus: function( event, ui ) {\n          var item = ui.item.data( \"item.autocomplete\" );\n          if ( false !== self._trigger( \"focus\", event, { item: item } ) ) {\n            // use value to match what will end up in the input, if it was a key event\n            if ( /^key/.test(event.originalEvent.type) ) {\n              self.element.val( item.value );\n            }\n          }\n        },\n        selected: function( event, ui ) {\n          var item = ui.item.data( \"item.autocomplete\" ),\n            previous = self.previous;\n\n          // only trigger when focus was lost (click on menu)\n          if ( self.element[0] !== doc.activeElement ) {\n            self.element.focus();\n            self.previous = previous;\n            // #6109 - IE triggers two focus events and the second\n            // is asynchronous, so we need to reset the previous\n            // term synchronously and asynchronously :-(\n            setTimeout(function() {\n              self.previous = previous;\n              self.selectedItem = item;\n            }, 1);\n          }\n\n          if ( false !== self._trigger( \"select\", event, { item: item } ) ) {\n            self.element.val( item.value );\n          }\n          // reset the term after the select event\n          // this allows custom select handling to work properly\n          self.term = self.element.val();\n\n          self.close( event );\n          self.selectedItem = item;\n        },\n        blur: function( event, ui ) {\n          // don't set the value of the text field if it's already correct\n          // this prevents moving the cursor unnecessarily\n          if ( self.menu.element.is(\":visible\") &&\n            ( self.element.val() !== self.term ) ) {\n            self.element.val( self.term );\n          }\n        }\n      })\n      .zIndex( this.element.zIndex() + 1 )\n      // workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781\n      .css({ top: 0, left: 0 })\n      .hide()\n      .data( \"menu\" );\n    if ( $.fn.bgiframe ) {\n       this.menu.element.bgiframe();\n    }\n    // turning off autocomplete prevents the browser from remembering the\n    // value when navigating through history, so we re-enable autocomplete\n    // if the page is unloaded before the widget is destroyed. #7790\n    self.beforeunloadHandler = function() {\n      self.element.removeAttr( \"autocomplete\" );\n    };\n    $( window ).bind( \"beforeunload\", self.beforeunloadHandler );\n  },\n\n  destroy: function() {\n    this.element\n      .removeClass( \"ui-autocomplete-input\" )\n      .removeAttr( \"autocomplete\" )\n      .removeAttr( \"role\" )\n      .removeAttr( \"aria-autocomplete\" )\n      .removeAttr( \"aria-haspopup\" );\n    this.menu.element.remove();\n    $( window ).unbind( \"beforeunload\", this.beforeunloadHandler );\n    $.Widget.prototype.destroy.call( this );\n  },\n\n  _setOption: function( key, value ) {\n    $.Widget.prototype._setOption.apply( this, arguments );\n    if ( key === \"source\" ) {\n      this._initSource();\n    }\n    if ( key === \"appendTo\" ) {\n      this.menu.element.appendTo( $( value || \"body\", this.element[0].ownerDocument )[0] )\n    }\n    if ( key === \"disabled\" && value && this.xhr ) {\n      this.xhr.abort();\n    }\n  },\n\n  _initSource: function() {\n    var self = this,\n      array,\n      url;\n    if ( $.isArray(this.options.source) ) {\n      array = this.options.source;\n      this.source = function( request, response ) {\n        response( $.ui.autocomplete.filter(array, request.term) );\n      };\n    } else if ( typeof this.options.source === \"string\" ) {\n      url = this.options.source;\n      this.source = function( request, response ) {\n        if ( self.xhr ) {\n          self.xhr.abort();\n        }\n        self.xhr = $.ajax({\n          url: url,\n          data: request,\n          dataType: \"json\",\n          context: {\n            autocompleteRequest: ++requestIndex\n          },\n          success: function( data, status ) {\n            if ( this.autocompleteRequest === requestIndex ) {\n              response( data );\n            }\n          },\n          error: function() {\n            if ( this.autocompleteRequest === requestIndex ) {\n              response( [] );\n            }\n          }\n        });\n      };\n    } else {\n      this.source = this.options.source;\n    }\n  },\n\n  search: function( value, event ) {\n    value = value != null ? value : this.element.val();\n\n    // always save the actual value, not the one passed as an argument\n    this.term = this.element.val();\n\n    if ( value.length < this.options.minLength ) {\n      return this.close( event );\n    }\n\n    clearTimeout( this.closing );\n    if ( this._trigger( \"search\", event ) === false ) {\n      return;\n    }\n\n    return this._search( value );\n  },\n\n  _search: function( value ) {\n    this.pending++;\n    this.element.addClass( \"ui-autocomplete-loading\" );\n\n    this.source( { term: value }, this.response );\n  },\n\n  _response: function( content ) {\n    if ( !this.options.disabled && content && content.length ) {\n      content = this._normalize( content );\n      this._suggest( content );\n      this._trigger( \"open\" );\n    } else {\n      this.close();\n    }\n    this.pending--;\n    if ( !this.pending ) {\n      this.element.removeClass( \"ui-autocomplete-loading\" );\n    }\n  },\n\n  close: function( event ) {\n    clearTimeout( this.closing );\n    if ( this.menu.element.is(\":visible\") ) {\n      this.menu.element.hide();\n      this.menu.deactivate();\n      this._trigger( \"close\", event );\n    }\n  },\n  \n  _change: function( event ) {\n    if ( this.previous !== this.element.val() ) {\n      this._trigger( \"change\", event, { item: this.selectedItem } );\n    }\n  },\n\n  _normalize: function( items ) {\n    // assume all items have the right format when the first item is complete\n    if ( items.length && items[0].label && items[0].value ) {\n      return items;\n    }\n    return $.map( items, function(item) {\n      if ( typeof item === \"string\" ) {\n        return {\n          label: item,\n          value: item\n        };\n      }\n      return $.extend({\n        label: item.label || item.value,\n        value: item.value || item.label\n      }, item );\n    });\n  },\n\n  _suggest: function( items ) {\n    var ul = this.menu.element\n      .empty()\n      .zIndex( this.element.zIndex() + 1 );\n    this._renderMenu( ul, items );\n    // TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate\n    this.menu.deactivate();\n    this.menu.refresh();\n\n    // size and position menu\n    ul.show();\n    this._resizeMenu();\n    ul.position( $.extend({\n      of: this.element\n    }, this.options.position ));\n\n    if ( this.options.autoFocus ) {\n      this.menu.next( new $.Event(\"mouseover\") );\n    }\n  },\n\n  _resizeMenu: function() {\n    var ul = this.menu.element;\n    ul.outerWidth( Math.max(\n      // Firefox wraps long text (possibly a rounding bug)\n      // so we add 1px to avoid the wrapping (#7513)\n      ul.width( \"\" ).outerWidth() + 1,\n      this.element.outerWidth()\n    ) );\n  },\n\n  _renderMenu: function( ul, items ) {\n    var self = this;\n    $.each( items, function( index, item ) {\n      self._renderItem( ul, item );\n    });\n  },\n\n  _renderItem: function( ul, item) {\n    return $( \"<li></li>\" )\n      .data( \"item.autocomplete\", item )\n      .append( $( \"<a></a>\" ).text( item.label ) )\n      .appendTo( ul );\n  },\n\n  _move: function( direction, event ) {\n    if ( !this.menu.element.is(\":visible\") ) {\n      this.search( null, event );\n      return;\n    }\n    if ( this.menu.first() && /^previous/.test(direction) ||\n        this.menu.last() && /^next/.test(direction) ) {\n      this.element.val( this.term );\n      this.menu.deactivate();\n      return;\n    }\n    this.menu[ direction ]( event );\n  },\n\n  widget: function() {\n    return this.menu.element;\n  }\n});\n\n$.extend( $.ui.autocomplete, {\n  escapeRegex: function( value ) {\n    return value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n  },\n  filter: function(array, term) {\n    var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), \"i\" );\n    return $.grep( array, function(value) {\n      return matcher.test( value.label || value.value || value );\n    });\n  }\n});\n\n}( jQuery ));\n\n/*\n * jQuery UI Menu (not officially released)\n * \n * This widget isn't yet finished and the API is subject to change. We plan to finish\n * it for the next release. You're welcome to give it a try anyway and give us feedback,\n * as long as you're okay with migrating your code later on. We can help with that, too.\n *\n * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Menu\n *\n * Depends:\n *  jquery.ui.core.js\n *  jquery.ui.widget.js\n */\n(function($) {\n\n$.widget(\"ui.menu\", {\n  _create: function() {\n    var self = this;\n    this.element\n      .addClass(\"ui-menu ui-widget ui-widget-content ui-corner-all\")\n      .attr({\n        role: \"listbox\",\n        \"aria-activedescendant\": \"ui-active-menuitem\"\n      })\n      .click(function( event ) {\n        if ( !$( event.target ).closest( \".ui-menu-item a\" ).length ) {\n          return;\n        }\n        // temporary\n        event.preventDefault();\n        self.select( event );\n      });\n    this.refresh();\n  },\n  \n  refresh: function() {\n    var self = this;\n\n    // don't refresh list items that are already adapted\n    var items = this.element.children(\"li:not(.ui-menu-item):has(a)\")\n      .addClass(\"ui-menu-item\")\n      .attr(\"role\", \"menuitem\");\n    \n    items.children(\"a\")\n      .addClass(\"ui-corner-all\")\n      .attr(\"tabindex\", -1)\n      // mouseenter doesn't work with event delegation\n      .mouseenter(function( event ) {\n        self.activate( event, $(this).parent() );\n      })\n      .mouseleave(function() {\n        self.deactivate();\n      });\n  },\n\n  activate: function( event, item ) {\n    this.deactivate();\n    if (this.hasScroll()) {\n      var offset = item.offset().top - this.element.offset().top,\n        scroll = this.element.scrollTop(),\n        elementHeight = this.element.height();\n      if (offset < 0) {\n        this.element.scrollTop( scroll + offset);\n      } else if (offset >= elementHeight) {\n        this.element.scrollTop( scroll + offset - elementHeight + item.height());\n      }\n    }\n    this.active = item.eq(0)\n      .children(\"a\")\n        .addClass(\"ui-state-hover\")\n        .attr(\"id\", \"ui-active-menuitem\")\n      .end();\n    this._trigger(\"focus\", event, { item: item });\n  },\n\n  deactivate: function() {\n    if (!this.active) { return; }\n\n    this.active.children(\"a\")\n      .removeClass(\"ui-state-hover\")\n      .removeAttr(\"id\");\n    this._trigger(\"blur\");\n    this.active = null;\n  },\n\n  next: function(event) {\n    this.move(\"next\", \".ui-menu-item:first\", event);\n  },\n\n  previous: function(event) {\n    this.move(\"prev\", \".ui-menu-item:last\", event);\n  },\n\n  first: function() {\n    return this.active && !this.active.prevAll(\".ui-menu-item\").length;\n  },\n\n  last: function() {\n    return this.active && !this.active.nextAll(\".ui-menu-item\").length;\n  },\n\n  move: function(direction, edge, event) {\n    if (!this.active) {\n      this.activate(event, this.element.children(edge));\n      return;\n    }\n    var next = this.active[direction + \"All\"](\".ui-menu-item\").eq(0);\n    if (next.length) {\n      this.activate(event, next);\n    } else {\n      this.activate(event, this.element.children(edge));\n    }\n  },\n\n  // TODO merge with previousPage\n  nextPage: function(event) {\n    if (this.hasScroll()) {\n      // TODO merge with no-scroll-else\n      if (!this.active || this.last()) {\n        this.activate(event, this.element.children(\".ui-menu-item:first\"));\n        return;\n      }\n      var base = this.active.offset().top,\n        height = this.element.height(),\n        result = this.element.children(\".ui-menu-item\").filter(function() {\n          var close = $(this).offset().top - base - height + $(this).height();\n          // TODO improve approximation\n          return close < 10 && close > -10;\n        });\n\n      // TODO try to catch this earlier when scrollTop indicates the last page anyway\n      if (!result.length) {\n        result = this.element.children(\".ui-menu-item:last\");\n      }\n      this.activate(event, result);\n    } else {\n      this.activate(event, this.element.children(\".ui-menu-item\")\n        .filter(!this.active || this.last() ? \":first\" : \":last\"));\n    }\n  },\n\n  // TODO merge with nextPage\n  previousPage: function(event) {\n    if (this.hasScroll()) {\n      // TODO merge with no-scroll-else\n      if (!this.active || this.first()) {\n        this.activate(event, this.element.children(\".ui-menu-item:last\"));\n        return;\n      }\n\n      var base = this.active.offset().top,\n        height = this.element.height();\n        result = this.element.children(\".ui-menu-item\").filter(function() {\n          var close = $(this).offset().top - base + height - $(this).height();\n          // TODO improve approximation\n          return close < 10 && close > -10;\n        });\n\n      // TODO try to catch this earlier when scrollTop indicates the last page anyway\n      if (!result.length) {\n        result = this.element.children(\".ui-menu-item:first\");\n      }\n      this.activate(event, result);\n    } else {\n      this.activate(event, this.element.children(\".ui-menu-item\")\n        .filter(!this.active || this.first() ? \":last\" : \":first\"));\n    }\n  },\n\n  hasScroll: function() {\n    return this.element.height() < this.element[ $.fn.prop ? \"prop\" : \"attr\" ](\"scrollHeight\");\n  },\n\n  select: function( event ) {\n    this._trigger(\"selected\", event, { item: this.active });\n  }\n});\n\n}(jQuery));\n/*\n * jQuery UI Datepicker 1.8.18\n *\n * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n *\n * http://docs.jquery.com/UI/Datepicker\n *\n * Depends:\n *  jquery.ui.core.js\n */\n(function( $, undefined ) {\n\n$.extend($.ui, { datepicker: { version: \"1.8.18\" } });\n\nvar PROP_NAME = 'datepicker';\nvar dpuuid = new Date().getTime();\nvar instActive;\n\n/* Date picker manager.\n   Use the singleton instance of this class, $.datepicker, to interact with the date picker.\n   Settings for (groups of) date pickers are maintained in an instance object,\n   allowing multiple different settings on the same page. */\n\nfunction Datepicker() {\n  this.debug = false; // Change this to true to start debugging\n  this._curInst = null; // The current instance in use\n  this._keyEvent = false; // If the last event was a key event\n  this._disabledInputs = []; // List of date picker inputs that have been disabled\n  this._datepickerShowing = false; // True if the popup picker is showing , false if not\n  this._inDialog = false; // True if showing within a \"dialog\", false if not\n  this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division\n  this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class\n  this._appendClass = 'ui-datepicker-append'; // The name of the append marker class\n  this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class\n  this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class\n  this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class\n  this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class\n  this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class\n  this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class\n  this.regional = []; // Available regional settings, indexed by language code\n  this.regional[''] = { // Default regional settings\n    closeText: 'Done', // Display text for close link\n    prevText: 'Prev', // Display text for previous month link\n    nextText: 'Next', // Display text for next month link\n    currentText: 'Today', // Display text for current month link\n    monthNames: ['January','February','March','April','May','June',\n      'July','August','September','October','November','December'], // Names of months for drop-down and formatting\n    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting\n    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting\n    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting\n    dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday\n    weekHeader: 'Wk', // Column header for week of the year\n    dateFormat: 'mm/dd/yy', // See format options on parseDate\n    firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...\n    isRTL: false, // True if right-to-left language, false if left-to-right\n    showMonthAfterYear: false, // True if the year select precedes month, false for month then year\n    yearSuffix: '' // Additional text to append to the year in the month headers\n  };\n  this._defaults = { // Global defaults for all the date picker instances\n    showOn: 'focus', // 'focus' for popup on focus,\n      // 'button' for trigger button, or 'both' for either\n    showAnim: 'fadeIn', // Name of jQuery animation for popup\n    showOptions: {}, // Options for enhanced animations\n    defaultDate: null, // Used when field is blank: actual date,\n      // +/-number for offset from today, null for today\n    appendText: '', // Display text following the input box, e.g. showing the format\n    buttonText: '...', // Text for trigger button\n    buttonImage: '', // URL for trigger button image\n    buttonImageOnly: false, // True if the image appears alone, false if it appears on a button\n    hideIfNoPrevNext: false, // True to hide next/previous month links\n      // if not applicable, false to just disable them\n    navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links\n    gotoCurrent: false, // True if today link goes back to current selection instead\n    changeMonth: false, // True if month can be selected directly, false if only prev/next\n    changeYear: false, // True if year can be selected directly, false if only prev/next\n    yearRange: 'c-10:c+10', // Range of years to display in drop-down,\n      // either relative to today's year (-nn:+nn), relative to currently displayed year\n      // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\n    showOtherMonths: false, // True to show dates in other months, false to leave blank\n    selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable\n    showWeek: false, // True to show week of the year, false to not show it\n    calculateWeek: this.iso8601Week, // How to calculate the week of the year,\n      // takes a Date and returns the number of the week for it\n    shortYearCutoff: '+10', // Short year values < this are in the current century,\n      // > this are in the previous century,\n      // string value starting with '+' for current year + value\n    minDate: null, // The earliest selectable date, or null for no limit\n    maxDate: null, // The latest selectable date, or null for no limit\n    duration: 'fast', // Duration of display/closure\n    beforeShowDay: null, // Function that takes a date and returns an array with\n      // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',\n      // [2] = cell title (optional), e.g. $.datepicker.noWeekends\n    beforeShow: null, // Function that takes an input field and\n      // returns a set of custom settings for the date picker\n    onSelect: null, // Define a callback function when a date is selected\n    onChangeMonthYear: null, // Define a callback function when the month or year is changed\n    onClose: null, // Define a callback function when the datepicker is closed\n    numberOfMonths: 1, // Number of months to show at a time\n    showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)\n    stepMonths: 1, // Number of months to step back/forward\n    stepBigMonths: 12, // Number of months to step back/forward for the big links\n    altField: '', // Selector for an alternate field to store selected dates into\n    altFormat: '', // The date format to use for the alternate field\n    constrainInput: true, // The input is constrained by the current date format\n    showButtonPanel: false, // True to show button panel, false to not show it\n    autoSize: false, // True to size the input for the date format, false to leave as is\n    disabled: false // The initial disabled state\n  };\n  $.extend(this._defaults, this.regional['']);\n  this.dpDiv = bindHover($('<div id=\"' + this._mainDivId + '\" class=\"ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\"></div>'));\n}\n\n$.extend(Datepicker.prototype, {\n  /* Class name added to elements to indicate already configured with a date picker. */\n  markerClassName: 'hasDatepicker',\n  \n  //Keep track of the maximum number of rows displayed (see #7043)\n  maxRows: 4,\n\n  /* Debug logging (if enabled). */\n  log: function () {\n    if (this.debug)\n      console.log.apply('', arguments);\n  },\n  \n  // TODO rename to \"widget\" when switching to widget factory\n  _widgetDatepicker: function() {\n    return this.dpDiv;\n  },\n\n  /* Override the default settings for all instances of the date picker.\n     @param  settings  object - the new settings to use as defaults (anonymous object)\n     @return the manager object */\n  setDefaults: function(settings) {\n    extendRemove(this._defaults, settings || {});\n    return this;\n  },\n\n  /* Attach the date picker to a jQuery selection.\n     @param  target    element - the target input field or division or span\n     @param  settings  object - the new settings to use for this date picker instance (anonymous) */\n  _attachDatepicker: function(target, settings) {\n    // check for settings on the control itself - in namespace 'date:'\n    var inlineSettings = null;\n    for (var attrName in this._defaults) {\n      var attrValue = target.getAttribute('date:' + attrName);\n      if (attrValue) {\n        inlineSettings = inlineSettings || {};\n        try {\n          inlineSettings[attrName] = eval(attrValue);\n        } catch (err) {\n          inlineSettings[attrName] = attrValue;\n        }\n      }\n    }\n    var nodeName = target.nodeName.toLowerCase();\n    var inline = (nodeName == 'div' || nodeName == 'span');\n    if (!target.id) {\n      this.uuid += 1;\n      target.id = 'dp' + this.uuid;\n    }\n    var inst = this._newInst($(target), inline);\n    inst.settings = $.extend({}, settings || {}, inlineSettings || {});\n    if (nodeName == 'input') {\n      this._connectDatepicker(target, inst);\n    } else if (inline) {\n      this._inlineDatepicker(target, inst);\n    }\n  },\n\n  /* Create a new instance object. */\n  _newInst: function(target, inline) {\n    var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\\\\\$1'); // escape jQuery meta chars\n    return {id: id, input: target, // associated target\n      selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection\n      drawMonth: 0, drawYear: 0, // month being drawn\n      inline: inline, // is datepicker inline or not\n      dpDiv: (!inline ? this.dpDiv : // presentation div\n      bindHover($('<div class=\"' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\"></div>')))};\n  },\n\n  /* Attach the date picker to an input field. */\n  _connectDatepicker: function(target, inst) {\n    var input = $(target);\n    inst.append = $([]);\n    inst.trigger = $([]);\n    if (input.hasClass(this.markerClassName))\n      return;\n    this._attachments(input, inst);\n    input.addClass(this.markerClassName).keydown(this._doKeyDown).\n      keypress(this._doKeyPress).keyup(this._doKeyUp).\n      bind(\"setData.datepicker\", function(event, key, value) {\n        inst.settings[key] = value;\n      }).bind(\"getData.datepicker\", function(event, key) {\n        return this._get(inst, key);\n      });\n    this._autoSize(inst);\n    $.data(target, PROP_NAME, inst);\n    //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\n    if( inst.settings.disabled ) {\n      this._disableDatepicker( target );\n    }\n  },\n\n  /* Make attachments based on settings. */\n  _attachments: function(input, inst) {\n    var appendText = this._get(inst, 'appendText');\n    var isRTL = this._get(inst, 'isRTL');\n    if (inst.append)\n      inst.append.remove();\n    if (appendText) {\n      inst.append = $('<span class=\"' + this._appendClass + '\">' + appendText + '</span>');\n      input[isRTL ? 'before' : 'after'](inst.append);\n    }\n    input.unbind('focus', this._showDatepicker);\n    if (inst.trigger)\n      inst.trigger.remove();\n    var showOn = this._get(inst, 'showOn');\n    if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field\n      input.focus(this._showDatepicker);\n    if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked\n      var buttonText = this._get(inst, 'buttonText');\n      var buttonImage = this._get(inst, 'buttonImage');\n      inst.trigger = $(this._get(inst, 'buttonImageOnly') ?\n        $('<img/>').addClass(this._triggerClass).\n          attr({ src: buttonImage, alt: buttonText, title: buttonText }) :\n        $('<button type=\"button\"></button>').addClass(this._triggerClass).\n          html(buttonImage == '' ? buttonText : $('<img/>').attr(\n          { src:buttonImage, alt:buttonText, title:buttonText })));\n      input[isRTL ? 'before' : 'after'](inst.trigger);\n      inst.trigger.click(function() {\n        if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])\n          $.datepicker._hideDatepicker();\n        else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {\n          $.datepicker._hideDatepicker(); \n          $.datepicker._showDatepicker(input[0]);\n        } else\n          $.datepicker._showDatepicker(input[0]);\n        return false;\n      });\n    }\n  },\n\n  /* Apply the maximum length for the date format. */\n  _autoSize: function(inst) {\n    if (this._get(inst, 'autoSize') && !inst.inline) {\n      var date = new Date(2009, 12 - 1, 20); // Ensure double digits\n      var dateFormat = this._get(inst, 'dateFormat');\n      if (dateFormat.match(/[DM]/)) {\n        var findMax = function(names) {\n          var max = 0;\n          var maxI = 0;\n          for (var i = 0; i < names.length; i++) {\n            if (names[i].length > max) {\n              max = names[i].length;\n              maxI = i;\n            }\n          }\n          return maxI;\n        };\n        date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?\n          'monthNames' : 'monthNamesShort'))));\n        date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?\n          'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());\n      }\n      inst.input.attr('size', this._formatDate(inst, date).length);\n    }\n  },\n\n  /* Attach an inline date picker to a div. */\n  _inlineDatepicker: function(target, inst) {\n    var divSpan = $(target);\n    if (divSpan.hasClass(this.markerClassName))\n      return;\n    divSpan.addClass(this.markerClassName).append(inst.dpDiv).\n      bind(\"setData.datepicker\", function(event, key, value){\n        inst.settings[key] = value;\n      }).bind(\"getData.datepicker\", function(event, key){\n        return this._get(inst, key);\n      });\n    $.data(target, PROP_NAME, inst);\n    this._setDate(inst, this._getDefaultDate(inst), true);\n    this._updateDatepicker(inst);\n    this._updateAlternate(inst);\n    //If disabled option is true, disable the datepicker before showing it (see ticket #5665)\n    if( inst.settings.disabled ) {\n      this._disableDatepicker( target );\n    }\n    // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements\n    // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\n    inst.dpDiv.css( \"display\", \"block\" );\n  },\n\n  /* Pop-up the date picker in a \"dialog\" box.\n     @param  input     element - ignored\n     @param  date      string or Date - the initial date to display\n     @param  onSelect  function - the function to call when a date is selected\n     @param  settings  object - update the dialog date picker instance's settings (anonymous object)\n     @param  pos       int[2] - coordinates for the dialog's position within the screen or\n                       event - with x/y coordinates or\n                       leave empty for default (screen centre)\n     @return the manager object */\n  _dialogDatepicker: function(input, date, onSelect, settings, pos) {\n    var inst = this._dialogInst; // internal instance\n    if (!inst) {\n      this.uuid += 1;\n      var id = 'dp' + this.uuid;\n      this._dialogInput = $('<input type=\"text\" id=\"' + id +\n        '\" style=\"position: absolute; top: -100px; width: 0px; z-index: -10;\"/>');\n      this._dialogInput.keydown(this._doKeyDown);\n      $('body').append(this._dialogInput);\n      inst = this._dialogInst = this._newInst(this._dialogInput, false);\n      inst.settings = {};\n      $.data(this._dialogInput[0], PROP_NAME, inst);\n    }\n    extendRemove(inst.settings, settings || {});\n    date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);\n    this._dialogInput.val(date);\n\n    this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);\n    if (!this._pos) {\n      var browserWidth = document.documentElement.clientWidth;\n      var browserHeight = document.documentElement.clientHeight;\n      var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n      var scrollY = document.documentElement.scrollTop || document.body.scrollTop;\n      this._pos = // should use actual width/height below\n        [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];\n    }\n\n    // move input on screen for focus, but hidden behind dialog\n    this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');\n    inst.settings.onSelect = onSelect;\n    this._inDialog = true;\n    this.dpDiv.addClass(this._dialogClass);\n    this._showDatepicker(this._dialogInput[0]);\n    if ($.blockUI)\n      $.blockUI(this.dpDiv);\n    $.data(this._dialogInput[0], PROP_NAME, inst);\n    return this;\n  },\n\n  /* Detach a datepicker from its control.\n     @param  target    element - the target input field or division or span */\n  _destroyDatepicker: function(target) {\n    var $target = $(target);\n    var inst = $.data(target, PROP_NAME);\n    if (!$target.hasClass(this.markerClassName)) {\n      return;\n    }\n    var nodeName = target.nodeName.toLowerCase();\n    $.removeData(target, PROP_NAME);\n    if (nodeName == 'input') {\n      inst.append.remove();\n      inst.trigger.remove();\n      $target.removeClass(this.markerClassName).\n        unbind('focus', this._showDatepicker).\n        unbind('keydown', this._doKeyDown).\n        unbind('keypress', this._doKeyPress).\n        unbind('keyup', this._doKeyUp);\n    } else if (nodeName == 'div' || nodeName == 'span')\n      $target.removeClass(this.markerClassName).empty();\n  },\n\n  /* Enable the date picker to a jQuery selection.\n     @param  target    element - the target input field or division or span */\n  _enableDatepicker: function(target) {\n    var $target = $(target);\n    var inst = $.data(target, PROP_NAME);\n    if (!$target.hasClass(this.markerClassName)) {\n      return;\n    }\n    var nodeName = target.nodeName.toLowerCase();\n    if (nodeName == 'input') {\n      target.disabled = false;\n      inst.trigger.filter('button').\n        each(function() { this.disabled = false; }).end().\n        filter('img').css({opacity: '1.0', cursor: ''});\n    }\n    else if (nodeName == 'div' || nodeName == 'span') {\n      var inline = $target.children('.' + this._inlineClass);\n      inline.children().removeClass('ui-state-disabled');\n      inline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").\n        removeAttr(\"disabled\");\n    }\n    this._disabledInputs = $.map(this._disabledInputs,\n      function(value) { return (value == target ? null : value); }); // delete entry\n  },\n\n  /* Disable the date picker to a jQuery selection.\n     @param  target    element - the target input field or division or span */\n  _disableDatepicker: function(target) {\n    var $target = $(target);\n    var inst = $.data(target, PROP_NAME);\n    if (!$target.hasClass(this.markerClassName)) {\n      return;\n    }\n    var nodeName = target.nodeName.toLowerCase();\n    if (nodeName == 'input') {\n      target.disabled = true;\n      inst.trigger.filter('button').\n        each(function() { this.disabled = true; }).end().\n        filter('img').css({opacity: '0.5', cursor: 'default'});\n    }\n    else if (nodeName == 'div' || nodeName == 'span') {\n      var inline = $target.children('.' + this._inlineClass);\n      inline.children().addClass('ui-state-disabled');\n      inline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").\n        attr(\"disabled\", \"disabled\");\n    }\n    this._disabledInputs = $.map(this._disabledInputs,\n      function(value) { return (value == target ? null : value); }); // delete entry\n    this._disabledInputs[this._disabledInputs.length] = target;\n  },\n\n  /* Is the first field in a jQuery collection disabled as a datepicker?\n     @param  target    element - the target input field or division or span\n     @return boolean - true if disabled, false if enabled */\n  _isDisabledDatepicker: function(target) {\n    if (!target) {\n      return false;\n    }\n    for (var i = 0; i < this._disabledInputs.length; i++) {\n      if (this._disabledInputs[i] == target)\n        return true;\n    }\n    return false;\n  },\n\n  /* Retrieve the instance data for the target control.\n     @param  target  element - the target input field or division or span\n     @return  object - the associated instance data\n     @throws  error if a jQuery problem getting data */\n  _getInst: function(target) {\n    try {\n      return $.data(target, PROP_NAME);\n    }\n    catch (err) {\n      throw 'Missing instance data for this datepicker';\n    }\n  },\n\n  /* Update or retrieve the settings for a date picker attached to an input field or division.\n     @param  target  element - the target input field or division or span\n     @param  name    object - the new settings to update or\n                     string - the name of the setting to change or retrieve,\n                     when retrieving also 'all' for all instance settings or\n                     'defaults' for all global defaults\n     @param  value   any - the new value for the setting\n                     (omit if above is an object or to retrieve a value) */\n  _optionDatepicker: function(target, name, value) {\n    var inst = this._getInst(target);\n    if (arguments.length == 2 && typeof name == 'string') {\n      return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :\n        (inst ? (name == 'all' ? $.extend({}, inst.settings) :\n        this._get(inst, name)) : null));\n    }\n    var settings = name || {};\n    if (typeof name == 'string') {\n      settings = {};\n      settings[name] = value;\n    }\n    if (inst) {\n      if (this._curInst == inst) {\n        this._hideDatepicker();\n      }\n      var date = this._getDateDatepicker(target, true);\n      var minDate = this._getMinMaxDate(inst, 'min');\n      var maxDate = this._getMinMaxDate(inst, 'max');\n      extendRemove(inst.settings, settings);\n      // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided\n      if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)\n        inst.settings.minDate = this._formatDate(inst, minDate);\n      if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)\n        inst.settings.maxDate = this._formatDate(inst, maxDate);\n      this._attachments($(target), inst);\n      this._autoSize(inst);\n      this._setDate(inst, date);\n      this._updateAlternate(inst);\n      this._updateDatepicker(inst);\n    }\n  },\n\n  // change method deprecated\n  _changeDatepicker: function(target, name, value) {\n    this._optionDatepicker(target, name, value);\n  },\n\n  /* Redraw the date picker attached to an input field or division.\n     @param  target  element - the target input field or division or span */\n  _refreshDatepicker: function(target) {\n    var inst = this._getInst(target);\n    if (inst) {\n      this._updateDatepicker(inst);\n    }\n  },\n\n  /* Set the dates for a jQuery selection.\n     @param  target   element - the target input field or division or span\n     @param  date     Date - the new date */\n  _setDateDatepicker: function(target, date) {\n    var inst = this._getInst(target);\n    if (inst) {\n      this._setDate(inst, date);\n      this._updateDatepicker(inst);\n      this._updateAlternate(inst);\n    }\n  },\n\n  /* Get the date(s) for the first entry in a jQuery selection.\n     @param  target     element - the target input field or division or span\n     @param  noDefault  boolean - true if no default date is to be used\n     @return Date - the current date */\n  _getDateDatepicker: function(target, noDefault) {\n    var inst = this._getInst(target);\n    if (inst && !inst.inline)\n      this._setDateFromField(inst, noDefault);\n    return (inst ? this._getDate(inst) : null);\n  },\n\n  /* Handle keystrokes. */\n  _doKeyDown: function(event) {\n    var inst = $.datepicker._getInst(event.target);\n    var handled = true;\n    var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');\n    inst._keyEvent = true;\n    if ($.datepicker._datepickerShowing)\n      switch (event.keyCode) {\n        case 9: $.datepicker._hideDatepicker();\n            handled = false;\n            break; // hide on tab out\n        case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + \n                  $.datepicker._currentClass + ')', inst.dpDiv);\n            if (sel[0])\n              $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\n              var onSelect = $.datepicker._get(inst, 'onSelect');\n              if (onSelect) {\n                var dateStr = $.datepicker._formatDate(inst);\n\n                // trigger custom callback\n                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);\n              }\n            else\n              $.datepicker._hideDatepicker();\n            return false; // don't submit the form\n            break; // select the value on enter\n        case 27: $.datepicker._hideDatepicker();\n            break; // hide on escape\n        case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n              -$.datepicker._get(inst, 'stepBigMonths') :\n              -$.datepicker._get(inst, 'stepMonths')), 'M');\n            break; // previous month/year on page up/+ ctrl\n        case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n              +$.datepicker._get(inst, 'stepBigMonths') :\n              +$.datepicker._get(inst, 'stepMonths')), 'M');\n            break; // next month/year on page down/+ ctrl\n        case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);\n            handled = event.ctrlKey || event.metaKey;\n            break; // clear on ctrl or command +end\n        case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);\n            handled = event.ctrlKey || event.metaKey;\n            break; // current on ctrl or command +home\n        case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');\n            handled = event.ctrlKey || event.metaKey;\n            // -1 day on ctrl or command +left\n            if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n                  -$.datepicker._get(inst, 'stepBigMonths') :\n                  -$.datepicker._get(inst, 'stepMonths')), 'M');\n            // next month/year on alt +left on Mac\n            break;\n        case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');\n            handled = event.ctrlKey || event.metaKey;\n            break; // -1 week on ctrl or command +up\n        case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');\n            handled = event.ctrlKey || event.metaKey;\n            // +1 day on ctrl or command +right\n            if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n                  +$.datepicker._get(inst, 'stepBigMonths') :\n                  +$.datepicker._get(inst, 'stepMonths')), 'M');\n            // next month/year on alt +right\n            break;\n        case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');\n            handled = event.ctrlKey || event.metaKey;\n            break; // +1 week on ctrl or command +down\n        default: handled = false;\n      }\n    else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home\n      $.datepicker._showDatepicker(this);\n    else {\n      handled = false;\n    }\n    if (handled) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  },\n\n  /* Filter entered characters - based on date format. */\n  _doKeyPress: function(event) {\n    var inst = $.datepicker._getInst(event.target);\n    if ($.datepicker._get(inst, 'constrainInput')) {\n      var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));\n      var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);\n      return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);\n    }\n  },\n\n  /* Synchronise manual entry and field/alternate field. */\n  _doKeyUp: function(event) {\n    var inst = $.datepicker._getInst(event.target);\n    if (inst.input.val() != inst.lastVal) {\n      try {\n        var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),\n          (inst.input ? inst.input.val() : null),\n          $.datepicker._getFormatConfig(inst));\n        if (date) { // only if valid\n          $.datepicker._setDateFromField(inst);\n          $.datepicker._updateAlternate(inst);\n          $.datepicker._updateDatepicker(inst);\n        }\n      }\n      catch (event) {\n        $.datepicker.log(event);\n      }\n    }\n    return true;\n  },\n\n  /* Pop-up the date picker for a given input field.\n       If false returned from beforeShow event handler do not show. \n     @param  input  element - the input field attached to the date picker or\n                    event - if triggered by focus */\n  _showDatepicker: function(input) {\n    input = input.target || input;\n    if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger\n      input = $('input', input.parentNode)[0];\n    if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here\n      return;\n    var inst = $.datepicker._getInst(input);\n    if ($.datepicker._curInst && $.datepicker._curInst != inst) {\n      $.datepicker._curInst.dpDiv.stop(true, true);\n      if ( inst && $.datepicker._datepickerShowing ) {\n        $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );\n      }\n    }\n    var beforeShow = $.datepicker._get(inst, 'beforeShow');\n    var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\n    if(beforeShowSettings === false){\n            //false\n      return;\n    }\n    extendRemove(inst.settings, beforeShowSettings);\n    inst.lastVal = null;\n    $.datepicker._lastInput = input;\n    $.datepicker._setDateFromField(inst);\n    if ($.datepicker._inDialog) // hide cursor\n      input.value = '';\n    if (!$.datepicker._pos) { // position below input\n      $.datepicker._pos = $.datepicker._findPos(input);\n      $.datepicker._pos[1] += input.offsetHeight; // add the height\n    }\n    var isFixed = false;\n    $(input).parents().each(function() {\n      isFixed |= $(this).css('position') == 'fixed';\n      return !isFixed;\n    });\n    if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled\n      $.datepicker._pos[0] -= document.documentElement.scrollLeft;\n      $.datepicker._pos[1] -= document.documentElement.scrollTop;\n    }\n    var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};\n    $.datepicker._pos = null;\n    //to avoid flashes on Firefox\n    inst.dpDiv.empty();\n    // determine sizing offscreen\n    inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});\n    $.datepicker._updateDatepicker(inst);\n    // fix width for dynamic number of date pickers\n    // and adjust position before showing\n    offset = $.datepicker._checkOffset(inst, offset, isFixed);\n    inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?\n      'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',\n      left: offset.left + 'px', top: offset.top + 'px'});\n    if (!inst.inline) {\n      var showAnim = $.datepicker._get(inst, 'showAnim');\n      var duration = $.datepicker._get(inst, 'duration');\n      var postProcess = function() {\n        var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only\n        if( !! cover.length ){\n          var borders = $.datepicker._getBorders(inst.dpDiv);\n          cover.css({left: -borders[0], top: -borders[1],\n            width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});\n        }\n      };\n      inst.dpDiv.zIndex($(input).zIndex()+1);\n      $.datepicker._datepickerShowing = true;\n      if ($.effects && $.effects[showAnim])\n        inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);\n      else\n        inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);\n      if (!showAnim || !duration)\n        postProcess();\n      if (inst.input.is(':visible') && !inst.input.is(':disabled'))\n        inst.input.focus();\n      $.datepicker._curInst = inst;\n    }\n  },\n\n  /* Generate the date picker content. */\n  _updateDatepicker: function(inst) {\n    var self = this;\n    self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\n    var borders = $.datepicker._getBorders(inst.dpDiv);\n    instActive = inst; // for delegate hover events\n    inst.dpDiv.empty().append(this._generateHTML(inst));\n    var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only\n    if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6\n      cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})\n    }\n    inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();\n    var numMonths = this._getNumberOfMonths(inst);\n    var cols = numMonths[1];\n    var width = 17;\n    inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');\n    if (cols > 1)\n      inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');\n    inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +\n      'Class']('ui-datepicker-multi');\n    inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +\n      'Class']('ui-datepicker-rtl');\n    if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&\n        // #6694 - don't focus the input if it's already focused\n        // this breaks the change event in IE\n        inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)\n      inst.input.focus();\n    // deffered render of the years select (to avoid flashes on Firefox) \n    if( inst.yearshtml ){\n      var origyearshtml = inst.yearshtml;\n      setTimeout(function(){\n        //assure that inst.yearshtml didn't change.\n        if( origyearshtml === inst.yearshtml && inst.yearshtml ){\n          inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);\n        }\n        origyearshtml = inst.yearshtml = null;\n      }, 0);\n    }\n  },\n\n  /* Retrieve the size of left and top borders for an element.\n     @param  elem  (jQuery object) the element of interest\n     @return  (number[2]) the left and top borders */\n  _getBorders: function(elem) {\n    var convert = function(value) {\n      return {thin: 1, medium: 2, thick: 3}[value] || value;\n    };\n    return [parseFloat(convert(elem.css('border-left-width'))),\n      parseFloat(convert(elem.css('border-top-width')))];\n  },\n\n  /* Check positioning to remain on screen. */\n  _checkOffset: function(inst, offset, isFixed) {\n    var dpWidth = inst.dpDiv.outerWidth();\n    var dpHeight = inst.dpDiv.outerHeight();\n    var inputWidth = inst.input ? inst.input.outerWidth() : 0;\n    var inputHeight = inst.input ? inst.input.outerHeight() : 0;\n    var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();\n    var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();\n\n    offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);\n    offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;\n    offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;\n\n    // now check if datepicker is showing outside window viewport - move to a better place if so.\n    offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?\n      Math.abs(offset.left + dpWidth - viewWidth) : 0);\n    offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?\n      Math.abs(dpHeight + inputHeight) : 0);\n\n    return offset;\n  },\n\n  /* Find an object's position on the screen. */\n  _findPos: function(obj) {\n    var inst = this._getInst(obj);\n    var isRTL = this._get(inst, 'isRTL');\n        while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {\n            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];\n        }\n        var position = $(obj).offset();\n      return [position.left, position.top];\n  },\n\n  /* Hide the date picker from view.\n     @param  input  element - the input field attached to the date picker */\n  _hideDatepicker: function(input) {\n    var inst = this._curInst;\n    if (!inst || (input && inst != $.data(input, PROP_NAME)))\n      return;\n    if (this._datepickerShowing) {\n      var showAnim = this._get(inst, 'showAnim');\n      var duration = this._get(inst, 'duration');\n      var self = this;\n      var postProcess = function() {\n        $.datepicker._tidyDialog(inst);\n        self._curInst = null;\n      };\n      if ($.effects && $.effects[showAnim])\n        inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);\n      else\n        inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :\n          (showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);\n      if (!showAnim)\n        postProcess();\n      this._datepickerShowing = false;\n      var onClose = this._get(inst, 'onClose');\n      if (onClose)\n        onClose.apply((inst.input ? inst.input[0] : null),\n          [(inst.input ? inst.input.val() : ''), inst]);\n      this._lastInput = null;\n      if (this._inDialog) {\n        this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });\n        if ($.blockUI) {\n          $.unblockUI();\n          $('body').append(this.dpDiv);\n        }\n      }\n      this._inDialog = false;\n    }\n  },\n\n  /* Tidy up after a dialog display. */\n  _tidyDialog: function(inst) {\n    inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');\n  },\n\n  /* Close date picker if clicked elsewhere. */\n  _checkExternalClick: function(event) {\n    if (!$.datepicker._curInst)\n      return;\n\n    var $target = $(event.target),\n      inst = $.datepicker._getInst($target[0]);\n\n    if ( ( ( $target[0].id != $.datepicker._mainDivId &&\n        $target.parents('#' + $.datepicker._mainDivId).length == 0 &&\n        !$target.hasClass($.datepicker.markerClassName) &&\n        !$target.closest(\".\" + $.datepicker._triggerClass).length &&\n        $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||\n      ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )\n      $.datepicker._hideDatepicker();\n  },\n\n  /* Adjust one of the date sub-fields. */\n  _adjustDate: function(id, offset, period) {\n    var target = $(id);\n    var inst = this._getInst(target[0]);\n    if (this._isDisabledDatepicker(target[0])) {\n      return;\n    }\n    this._adjustInstDate(inst, offset +\n      (period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning\n      period);\n    this._updateDatepicker(inst);\n  },\n\n  /* Action for current link. */\n  _gotoToday: function(id) {\n    var target = $(id);\n    var inst = this._getInst(target[0]);\n    if (this._get(inst, 'gotoCurrent') && inst.currentDay) {\n      inst.selectedDay = inst.currentDay;\n      inst.drawMonth = inst.selectedMonth = inst.currentMonth;\n      inst.drawYear = inst.selectedYear = inst.currentYear;\n    }\n    else {\n      var date = new Date();\n      inst.selectedDay = date.getDate();\n      inst.drawMonth = inst.selectedMonth = date.getMonth();\n      inst.drawYear = inst.selectedYear = date.getFullYear();\n    }\n    this._notifyChange(inst);\n    this._adjustDate(target);\n  },\n\n  /* Action for selecting a new month/year. */\n  _selectMonthYear: function(id, select, period) {\n    var target = $(id);\n    var inst = this._getInst(target[0]);\n    inst['selected' + (period == 'M' ? 'Month' : 'Year')] =\n    inst['draw' + (period == 'M' ? 'Month' : 'Year')] =\n      parseInt(select.options[select.selectedIndex].value,10);\n    this._notifyChange(inst);\n    this._adjustDate(target);\n  },\n\n  /* Action for selecting a day. */\n  _selectDay: function(id, month, year, td) {\n    var target = $(id);\n    if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\n      return;\n    }\n    var inst = this._getInst(target[0]);\n    inst.selectedDay = inst.currentDay = $('a', td).html();\n    inst.selectedMonth = inst.currentMonth = month;\n    inst.selectedYear = inst.currentYear = year;\n    this._selectDate(id, this._formatDate(inst,\n      inst.currentDay, inst.currentMonth, inst.currentYear));\n  },\n\n  /* Erase the input field and hide the date picker. */\n  _clearDate: function(id) {\n    var target = $(id);\n    var inst = this._getInst(target[0]);\n    this._selectDate(target, '');\n  },\n\n  /* Update the input field with the selected date. */\n  _selectDate: function(id, dateStr) {\n    var target = $(id);\n    var inst = this._getInst(target[0]);\n    dateStr = (dateStr != null ? dateStr : this._formatDate(inst));\n    if (inst.input)\n      inst.input.val(dateStr);\n    this._updateAlternate(inst);\n    var onSelect = this._get(inst, 'onSelect');\n    if (onSelect)\n      onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback\n    else if (inst.input)\n      inst.input.trigger('change'); // fire the change event\n    if (inst.inline)\n      this._updateDatepicker(inst);\n    else {\n      this._hideDatepicker();\n      this._lastInput = inst.input[0];\n      if (typeof(inst.input[0]) != 'object')\n        inst.input.focus(); // restore focus\n      this._lastInput = null;\n    }\n  },\n\n  /* Update any alternate field to synchronise with the main field. */\n  _updateAlternate: function(inst) {\n    var altField = this._get(inst, 'altField');\n    if (altField) { // update alternate field too\n      var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');\n      var date = this._getDate(inst);\n      var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\n      $(altField).each(function() { $(this).val(dateStr); });\n    }\n  },\n\n  /* Set as beforeShowDay function to prevent selection of weekends.\n     @param  date  Date - the date to customise\n     @return [boolean, string] - is this date selectable?, what is its CSS class? */\n  noWeekends: function(date) {\n    var day = date.getDay();\n    return [(day > 0 && day < 6), ''];\n  },\n\n  /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\n     @param  date  Date - the date to get the week for\n     @return  number - the number of the week within the year that contains this date */\n  iso8601Week: function(date) {\n    var checkDate = new Date(date.getTime());\n    // Find Thursday of this week starting on Monday\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  },\n\n  /* Parse a string value into a date object.\n     See formatDate below for the possible formats.\n\n     @param  format    string - the expected format of the date\n     @param  value     string - the date in the above format\n     @param  settings  Object - attributes include:\n                       shortYearCutoff  number - the cutoff year for determining the century (optional)\n                       dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)\n                       dayNames         string[7] - names of the days from Sunday (optional)\n                       monthNamesShort  string[12] - abbreviated names of the months (optional)\n                       monthNames       string[12] - names of the months (optional)\n     @return  Date - the extracted date value or null if value is blank */\n  parseDate: function (format, value, settings) {\n    if (format == null || value == null)\n      throw 'Invalid arguments';\n    value = (typeof value == 'object' ? value.toString() : value + '');\n    if (value == '')\n      return null;\n    var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;\n    shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :\n        new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));\n    var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;\n    var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;\n    var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;\n    var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;\n    var year = -1;\n    var month = -1;\n    var day = -1;\n    var doy = -1;\n    var literal = false;\n    // Check whether a format character is doubled\n    var lookAhead = function(match) {\n      var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);\n      if (matches)\n        iFormat++;\n      return matches;\n    };\n    // Extract a number from the string value\n    var getNumber = function(match) {\n      var isDoubled = lookAhead(match);\n      var size = (match == '@' ? 14 : (match == '!' ? 20 :\n        (match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));\n      var digits = new RegExp('^\\\\d{1,' + size + '}');\n      var num = value.substring(iValue).match(digits);\n      if (!num)\n        throw 'Missing number at position ' + iValue;\n      iValue += num[0].length;\n      return parseInt(num[0], 10);\n    };\n    // Extract a name from the string value and convert to an index\n    var getName = function(match, shortNames, longNames) {\n      var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\n        return [ [k, v] ];\n      }).sort(function (a, b) {\n        return -(a[1].length - b[1].length);\n      });\n      var index = -1;\n      $.each(names, function (i, pair) {\n        var name = pair[1];\n        if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {\n          index = pair[0];\n          iValue += name.length;\n          return false;\n        }\n      });\n      if (index != -1)\n        return index + 1;\n      else\n        throw 'Unknown name at position ' + iValue;\n    };\n    // Confirm that a literal character matches the string value\n    var checkLiteral = function() {\n      if (value.charAt(iValue) != format.charAt(iFormat))\n        throw 'Unexpected literal at position ' + iValue;\n      iValue++;\n    };\n    var iValue = 0;\n    for (var iFormat = 0; iFormat < format.length; iFormat++) {\n      if (literal)\n        if (format.charAt(iFormat) == \"'\" && !lookAhead(\"'\"))\n          literal = false;\n        else\n          checkLiteral();\n      else\n        switch (format.charAt(iFormat)) {\n          case 'd':\n            day = getNumber('d');\n            break;\n          case 'D':\n            getName('D', dayNamesShort, dayNames);\n            break;\n          case 'o':\n            doy = getNumber('o');\n            break;\n          case 'm':\n            month = getNumber('m');\n            break;\n          case 'M':\n            month = getName('M', monthNamesShort, monthNames);\n            break;\n          case 'y':\n            year = getNumber('y');\n            break;\n          case '@':\n            var date = new Date(getNumber('@'));\n            year = date.getFullYear();\n            month = date.getMonth() + 1;\n            day = date.getDate();\n            break;\n          case '!':\n            var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);\n            year = date.getFullYear();\n            month = date.getMonth() + 1;\n            day = date.getDate();\n            break;\n          case \"'\":\n            if (lookAhead(\"'\"))\n              checkLiteral();\n            else\n              literal = true;\n            break;\n          default:\n            checkLiteral();\n        }\n    }\n    if (iValue < value.length){\n      throw \"Extra/unparsed characters found in date: \" + value.substring(iValue);\n    }\n    if (year == -1)\n      year = new Date().getFullYear();\n    else if (year < 100)\n      year += new Date().getFullYear() - new Date().getFullYear() % 100 +\n        (year <= shortYearCutoff ? 0 : -100);\n    if (doy > -1) {\n      month = 1;\n      day = doy;\n      do {\n        var dim = this._getDaysInMonth(year, month - 1);\n        if (day <= dim)\n          break;\n        month++;\n        day -= dim;\n      } while (true);\n    }\n    var date = this._daylightSavingAdjust(new Date(year, month - 1, day));\n    if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)\n      throw 'Invalid date'; // E.g. 31/02/00\n    return date;\n  },\n\n  /* Standard date formats. */\n  ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)\n  COOKIE: 'D, dd M yy',\n  ISO_8601: 'yy-mm-dd',\n  RFC_822: 'D, d M y',\n  RFC_850: 'DD, dd-M-y',\n  RFC_1036: 'D, d M y',\n  RFC_1123: 'D, d M yy',\n  RFC_2822: 'D, d M yy',\n  RSS: 'D, d M y', // RFC 822\n  TICKS: '!',\n  TIMESTAMP: '@',\n  W3C: 'yy-mm-dd', // ISO 8601\n\n  _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +\n    Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),\n\n  /* Format a date object into a string value.\n     The format can be combinations of the following:\n     d  - day of month (no leading zero)\n     dd - day of month (two digit)\n     o  - day of year (no leading zeros)\n     oo - day of year (three digit)\n     D  - day name short\n     DD - day name long\n     m  - month of year (no leading zero)\n     mm - month of year (two digit)\n     M  - month name short\n     MM - month name long\n     y  - year (two digit)\n     yy - year (four digit)\n     @ - Unix timestamp (ms since 01/01/1970)\n     ! - Windows ticks (100ns since 01/01/0001)\n     '...' - literal text\n     '' - single quote\n\n     @param  format    string - the desired format of the date\n     @param  date      Date - the date value to format\n     @param  settings  Object - attributes include:\n                       dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)\n                       dayNames         string[7] - names of the days from Sunday (optional)\n                       monthNamesShort  string[12] - abbreviated names of the months (optional)\n                       monthNames       string[12] - names of the months (optional)\n     @return  string - the date in the above format */\n  formatDate: function (format, date, settings) {\n    if (!date)\n      return '';\n    var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;\n    var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;\n    var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;\n    var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;\n    // Check whether a format character is doubled\n    var lookAhead = function(match) {\n      var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);\n      if (matches)\n        iFormat++;\n      return matches;\n    };\n    // Format a number, with leading zero if necessary\n    var formatNumber = function(match, value, len) {\n      var num = '' + value;\n      if (lookAhead(match))\n        while (num.length < len)\n          num = '0' + num;\n      return num;\n    };\n    // Format a name, short or long as requested\n    var formatName = function(match, value, shortNames, longNames) {\n      return (lookAhead(match) ? longNames[value] : shortNames[value]);\n    };\n    var output = '';\n    var literal = false;\n    if (date)\n      for (var iFormat = 0; iFormat < format.length; iFormat++) {\n        if (literal)\n          if (format.charAt(iFormat) == \"'\" && !lookAhead(\"'\"))\n            literal = false;\n          else\n            output += format.charAt(iFormat);\n        else\n          switch (format.charAt(iFormat)) {\n            case 'd':\n              output += formatNumber('d', date.getDate(), 2);\n              break;\n            case 'D':\n              output += formatName('D', date.getDay(), dayNamesShort, dayNames);\n              break;\n            case 'o':\n              output += formatNumber('o',\n                Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\n              break;\n            case 'm':\n              output += formatNumber('m', date.getMonth() + 1, 2);\n              break;\n            case 'M':\n              output += formatName('M', date.getMonth(), monthNamesShort, monthNames);\n              break;\n            case 'y':\n              output += (lookAhead('y') ? date.getFullYear() :\n                (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);\n              break;\n            case '@':\n              output += date.getTime();\n              break;\n            case '!':\n              output += date.getTime() * 10000 + this._ticksTo1970;\n              break;\n            case \"'\":\n              if (lookAhead(\"'\"))\n                output += \"'\";\n              else\n                literal = true;\n              break;\n            default:\n              output += format.charAt(iFormat);\n          }\n      }\n    return output;\n  },\n\n  /* Extract all possible characters from the date format. */\n  _possibleChars: function (format) {\n    var chars = '';\n    var literal = false;\n    // Check whether a format character is doubled\n    var lookAhead = function(match) {\n      var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);\n      if (matches)\n        iFormat++;\n      return matches;\n    };\n    for (var iFormat = 0; iFormat < format.length; iFormat++)\n      if (literal)\n        if (format.charAt(iFormat) == \"'\" && !lookAhead(\"'\"))\n          literal = false;\n        else\n          chars += format.charAt(iFormat);\n      else\n        switch (format.charAt(iFormat)) {\n          case 'd': case 'm': case 'y': case '@':\n            chars += '0123456789';\n            break;\n          case 'D': case 'M':\n            return null; // Accept anything\n          case \"'\":\n            if (lookAhead(\"'\"))\n              chars += \"'\";\n            else\n              literal = true;\n            break;\n          default:\n            chars += format.charAt(iFormat);\n        }\n    return chars;\n  },\n\n  /* Get a setting value, defaulting if necessary. */\n  _get: function(inst, name) {\n    return inst.settings[name] !== undefined ?\n      inst.settings[name] : this._defaults[name];\n  },\n\n  /* Parse existing date and initialise date picker. */\n  _setDateFromField: function(inst, noDefault) {\n    if (inst.input.val() == inst.lastVal) {\n      return;\n    }\n    var dateFormat = this._get(inst, 'dateFormat');\n    var dates = inst.lastVal = inst.input ? inst.input.val() : null;\n    var date, defaultDate;\n    date = defaultDate = this._getDefaultDate(inst);\n    var settings = this._getFormatConfig(inst);\n    try {\n      date = this.parseDate(dateFormat, dates, settings) || defaultDate;\n    } catch (event) {\n      this.log(event);\n      dates = (noDefault ? '' : dates);\n    }\n    inst.selectedDay = date.getDate();\n    inst.drawMonth = inst.selectedMonth = date.getMonth();\n    inst.drawYear = inst.selectedYear = date.getFullYear();\n    inst.currentDay = (dates ? date.getDate() : 0);\n    inst.currentMonth = (dates ? date.getMonth() : 0);\n    inst.currentYear = (dates ? date.getFullYear() : 0);\n    this._adjustInstDate(inst);\n  },\n\n  /* Retrieve the default date shown on opening. */\n  _getDefaultDate: function(inst) {\n    return this._restrictMinMax(inst,\n      this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));\n  },\n\n  /* A date may be specified as an exact value or a relative one. */\n  _determineDate: function(inst, date, defaultDate) {\n    var offsetNumeric = function(offset) {\n      var date = new Date();\n      date.setDate(date.getDate() + offset);\n      return date;\n    };\n    var offsetString = function(offset) {\n      try {\n        return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),\n          offset, $.datepicker._getFormatConfig(inst));\n      }\n      catch (e) {\n        // Ignore\n      }\n      var date = (offset.toLowerCase().match(/^c/) ?\n        $.datepicker._getDate(inst) : null) || new Date();\n      var year = date.getFullYear();\n      var month = date.getMonth();\n      var day = date.getDate();\n      var pattern = /([+-]?[0-9]+)\\s*(d|D|w|W|m|M|y|Y)?/g;\n      var matches = pattern.exec(offset);\n      while (matches) {\n        switch (matches[2] || 'd') {\n          case 'd' : case 'D' :\n            day += parseInt(matches[1],10); break;\n          case 'w' : case 'W' :\n            day += parseInt(matches[1],10) * 7; break;\n          case 'm' : case 'M' :\n            month += parseInt(matches[1],10);\n            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n            break;\n          case 'y': case 'Y' :\n            year += parseInt(matches[1],10);\n            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n            break;\n        }\n        matches = pattern.exec(offset);\n      }\n      return new Date(year, month, day);\n    };\n    var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :\n      (typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));\n    newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);\n    if (newDate) {\n      newDate.setHours(0);\n      newDate.setMinutes(0);\n      newDate.setSeconds(0);\n      newDate.setMilliseconds(0);\n    }\n    return this._daylightSavingAdjust(newDate);\n  },\n\n  /* Handle switch to/from daylight saving.\n     Hours may be non-zero on daylight saving cut-over:\n     > 12 when midnight changeover, but then cannot generate\n     midnight datetime, so jump to 1AM, otherwise reset.\n     @param  date  (Date) the date to check\n     @return  (Date) the corrected date */\n  _daylightSavingAdjust: function(date) {\n    if (!date) return null;\n    date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n    return date;\n  },\n\n  /* Set the date(s) directly. */\n  _setDate: function(inst, date, noChange) {\n    var clear = !date;\n    var origMonth = inst.selectedMonth;\n    var origYear = inst.selectedYear;\n    var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\n    inst.selectedDay = inst.currentDay = newDate.getDate();\n    inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\n    inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\n    if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)\n      this._notifyChange(inst);\n    this._adjustInstDate(inst);\n    if (inst.input) {\n      inst.input.val(clear ? '' : this._formatDate(inst));\n    }\n  },\n\n  /* Retrieve the date(s) directly. */\n  _getDate: function(inst) {\n    var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :\n      this._daylightSavingAdjust(new Date(\n      inst.currentYear, inst.currentMonth, inst.currentDay)));\n      return startDate;\n  },\n\n  /* Generate the HTML for the current state of the date picker. */\n  _generateHTML: function(inst) {\n    var today = new Date();\n    today = this._daylightSavingAdjust(\n      new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time\n    var isRTL = this._get(inst, 'isRTL');\n    var showButtonPanel = this._get(inst, 'showButtonPanel');\n    var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');\n    var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');\n    var numMonths = this._getNumberOfMonths(inst);\n    var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');\n    var stepMonths = this._get(inst, 'stepMonths');\n    var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);\n    var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :\n      new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));\n    var minDate = this._getMinMaxDate(inst, 'min');\n    var maxDate = this._getMinMaxDate(inst, 'max');\n    var drawMonth = inst.drawMonth - showCurrentAtPos;\n    var drawYear = inst.drawYear;\n    if (drawMonth < 0) {\n      drawMonth += 12;\n      drawYear--;\n    }\n    if (maxDate) {\n      var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),\n        maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));\n      maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);\n      while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n        drawMonth--;\n        if (drawMonth < 0) {\n          drawMonth = 11;\n          drawYear--;\n        }\n      }\n    }\n    inst.drawMonth = drawMonth;\n    inst.drawYear = drawYear;\n    var prevText = this._get(inst, 'prevText');\n    prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,\n      this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),\n      this._getFormatConfig(inst)));\n    var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?\n      '<a class=\"ui-datepicker-prev ui-corner-all\" onclick=\"DP_jQuery_' + dpuuid +\n      '.datepicker._adjustDate(\\'#' + inst.id + '\\', -' + stepMonths + ', \\'M\\');\"' +\n      ' title=\"' + prevText + '\"><span class=\"ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '\">' + prevText + '</span></a>' :\n      (hideIfNoPrevNext ? '' : '<a class=\"ui-datepicker-prev ui-corner-all ui-state-disabled\" title=\"'+ prevText +'\"><span class=\"ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '\">' + prevText + '</span></a>'));\n    var nextText = this._get(inst, 'nextText');\n    nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,\n      this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),\n      this._getFormatConfig(inst)));\n    var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?\n      '<a class=\"ui-datepicker-next ui-corner-all\" onclick=\"DP_jQuery_' + dpuuid +\n      '.datepicker._adjustDate(\\'#' + inst.id + '\\', +' + stepMonths + ', \\'M\\');\"' +\n      ' title=\"' + nextText + '\"><span class=\"ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '\">' + nextText + '</span></a>' :\n      (hideIfNoPrevNext ? '' : '<a class=\"ui-datepicker-next ui-corner-all ui-state-disabled\" title=\"'+ nextText + '\"><span class=\"ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '\">' + nextText + '</span></a>'));\n    var currentText = this._get(inst, 'currentText');\n    var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);\n    currentText = (!navigationAsDateFormat ? currentText :\n      this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));\n    var controls = (!inst.inline ? '<button type=\"button\" class=\"ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\" onclick=\"DP_jQuery_' + dpuuid +\n      '.datepicker._hideDatepicker();\">' + this._get(inst, 'closeText') + '</button>' : '');\n    var buttonPanel = (showButtonPanel) ? '<div class=\"ui-datepicker-buttonpane ui-widget-content\">' + (isRTL ? controls : '') +\n      (this._isInRange(inst, gotoDate) ? '<button type=\"button\" class=\"ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\" onclick=\"DP_jQuery_' + dpuuid +\n      '.datepicker._gotoToday(\\'#' + inst.id + '\\');\"' +\n      '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';\n    var firstDay = parseInt(this._get(inst, 'firstDay'),10);\n    firstDay = (isNaN(firstDay) ? 0 : firstDay);\n    var showWeek = this._get(inst, 'showWeek');\n    var dayNames = this._get(inst, 'dayNames');\n    var dayNamesShort = this._get(inst, 'dayNamesShort');\n    var dayNamesMin = this._get(inst, 'dayNamesMin');\n    var monthNames = this._get(inst, 'monthNames');\n    var monthNamesShort = this._get(inst, 'monthNamesShort');\n    var beforeShowDay = this._get(inst, 'beforeShowDay');\n    var showOtherMonths = this._get(inst, 'showOtherMonths');\n    var selectOtherMonths = this._get(inst, 'selectOtherMonths');\n    var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;\n    var defaultDate = this._getDefaultDate(inst);\n    var html = '';\n    for (var row = 0; row < numMonths[0]; row++) {\n      var group = '';\n      this.maxRows = 4;\n      for (var col = 0; col < numMonths[1]; col++) {\n        var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n        var cornerClass = ' ui-corner-all';\n        var calender = '';\n        if (isMultiMonth) {\n          calender += '<div class=\"ui-datepicker-group';\n          if (numMonths[1] > 1)\n            switch (col) {\n              case 0: calender += ' ui-datepicker-group-first';\n                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;\n              case numMonths[1]-1: calender += ' ui-datepicker-group-last';\n                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;\n              default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;\n            }\n          calender += '\">';\n        }\n        calender += '<div class=\"ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '\">' +\n          (/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +\n          (/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +\n          this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,\n          row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n          '</div><table class=\"ui-datepicker-calendar\"><thead>' +\n          '<tr>';\n        var thead = (showWeek ? '<th class=\"ui-datepicker-week-col\">' + this._get(inst, 'weekHeader') + '</th>' : '');\n        for (var dow = 0; dow < 7; dow++) { // days of the week\n          var day = (dow + firstDay) % 7;\n          thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class=\"ui-datepicker-week-end\"' : '') + '>' +\n            '<span title=\"' + dayNames[day] + '\">' + dayNamesMin[day] + '</span></th>';\n        }\n        calender += thead + '</tr></thead><tbody>';\n        var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n        if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)\n          inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n        var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n        var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n        var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)\n        this.maxRows = numRows;\n        var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n        for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows\n          calender += '<tr>';\n          var tbody = (!showWeek ? '' : '<td class=\"ui-datepicker-week-col\">' +\n            this._get(inst, 'calculateWeek')(printDate) + '</td>');\n          for (var dow = 0; dow < 7; dow++) { // create date picker days\n            var daySettings = (beforeShowDay ?\n              beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);\n            var otherMonth = (printDate.getMonth() != drawMonth);\n            var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||\n              (minDate && printDate < minDate) || (maxDate && printDate > maxDate);\n            tbody += '<td class=\"' +\n              ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends\n              (otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months\n              ((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key\n              (defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?\n              // or defaultDate is current printedDate and defaultDate is selectedDate\n              ' ' + this._dayOverClass : '') + // highlight selected day\n              (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days\n              (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates\n              (printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day\n              (printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '\"' + // highlight today (if different)\n              ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title=\"' + daySettings[2] + '\"' : '') + // cell title\n              (unselectable ? '' : ' onclick=\"DP_jQuery_' + dpuuid + '.datepicker._selectDay(\\'#' +\n              inst.id + '\\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;\"') + '>' + // actions\n              (otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months\n              (unselectable ? '<span class=\"ui-state-default\">' + printDate.getDate() + '</span>' : '<a class=\"ui-state-default' +\n              (printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +\n              (printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day\n              (otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months\n              '\" href=\"#\">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date\n            printDate.setDate(printDate.getDate() + 1);\n            printDate = this._daylightSavingAdjust(printDate);\n          }\n          calender += tbody + '</tr>';\n        }\n        drawMonth++;\n        if (drawMonth > 11) {\n          drawMonth = 0;\n          drawYear++;\n        }\n        calender += '</tbody></table>' + (isMultiMonth ? '</div>' + \n              ((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class=\"ui-datepicker-row-break\"></div>' : '') : '');\n        group += calender;\n      }\n      html += group;\n    }\n    html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?\n      '<iframe src=\"javascript:false;\" class=\"ui-datepicker-cover\" frameborder=\"0\"></iframe>' : '');\n    inst._keyEvent = false;\n    return html;\n  },\n\n  /* Generate the month and year header. */\n  _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,\n      secondary, monthNames, monthNamesShort) {\n    var changeMonth = this._get(inst, 'changeMonth');\n    var changeYear = this._get(inst, 'changeYear');\n    var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');\n    var html = '<div class=\"ui-datepicker-title\">';\n    var monthHtml = '';\n    // month selection\n    if (secondary || !changeMonth)\n      monthHtml += '<span class=\"ui-datepicker-month\">' + monthNames[drawMonth] + '</span>';\n    else {\n      var inMinYear = (minDate && minDate.getFullYear() == drawYear);\n      var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);\n      monthHtml += '<select class=\"ui-datepicker-month\" ' +\n        'onchange=\"DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\\'#' + inst.id + '\\', this, \\'M\\');\" ' +\n        '>';\n      for (var month = 0; month < 12; month++) {\n        if ((!inMinYear || month >= minDate.getMonth()) &&\n            (!inMaxYear || month <= maxDate.getMonth()))\n          monthHtml += '<option value=\"' + month + '\"' +\n            (month == drawMonth ? ' selected=\"selected\"' : '') +\n            '>' + monthNamesShort[month] + '</option>';\n      }\n      monthHtml += '</select>';\n    }\n    if (!showMonthAfterYear)\n      html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');\n    // year selection\n    if ( !inst.yearshtml ) {\n      inst.yearshtml = '';\n      if (secondary || !changeYear)\n        html += '<span class=\"ui-datepicker-year\">' + drawYear + '</span>';\n      else {\n        // determine range of years to display\n        var years = this._get(inst, 'yearRange').split(':');\n        var thisYear = new Date().getFullYear();\n        var determineYear = function(value) {\n          var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :\n            (value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :\n            parseInt(value, 10)));\n          return (isNaN(year) ? thisYear : year);\n        };\n        var year = determineYear(years[0]);\n        var endYear = Math.max(year, determineYear(years[1] || ''));\n        year = (minDate ? Math.max(year, minDate.getFullYear()) : year);\n        endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);\n        inst.yearshtml += '<select class=\"ui-datepicker-year\" ' +\n          'onchange=\"DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\\'#' + inst.id + '\\', this, \\'Y\\');\" ' +\n          '>';\n        for (; year <= endYear; year++) {\n          inst.yearshtml += '<option value=\"' + year + '\"' +\n            (year == drawYear ? ' selected=\"selected\"' : '') +\n            '>' + year + '</option>';\n        }\n        inst.yearshtml += '</select>';\n        \n        html += inst.yearshtml;\n        inst.yearshtml = null;\n      }\n    }\n    html += this._get(inst, 'yearSuffix');\n    if (showMonthAfterYear)\n      html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;\n    html += '</div>'; // Close datepicker_header\n    return html;\n  },\n\n  /* Adjust one of the date sub-fields. */\n  _adjustInstDate: function(inst, offset, period) {\n    var year = inst.drawYear + (period == 'Y' ? offset : 0);\n    var month = inst.drawMonth + (period == 'M' ? offset : 0);\n    var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +\n      (period == 'D' ? offset : 0);\n    var date = this._restrictMinMax(inst,\n      this._daylightSavingAdjust(new Date(year, month, day)));\n    inst.selectedDay = date.getDate();\n    inst.drawMonth = inst.selectedMonth = date.getMonth();\n    inst.drawYear = inst.selectedYear = date.getFullYear();\n    if (period == 'M' || period == 'Y')\n      this._notifyChange(inst);\n  },\n\n  /* Ensure a date is within any min/max bounds. */\n  _restrictMinMax: function(inst, date) {\n    var minDate = this._getMinMaxDate(inst, 'min');\n    var maxDate = this._getMinMaxDate(inst, 'max');\n    var newDate = (minDate && date < minDate ? minDate : date);\n    newDate = (maxDate && newDate > maxDate ? maxDate : newDate);\n    return newDate;\n  },\n\n  /* Notify change of month/year. */\n  _notifyChange: function(inst) {\n    var onChange = this._get(inst, 'onChangeMonthYear');\n    if (onChange)\n      onChange.apply((inst.input ? inst.input[0] : null),\n        [inst.selectedYear, inst.selectedMonth + 1, inst]);\n  },\n\n  /* Determine the number of months to show. */\n  _getNumberOfMonths: function(inst) {\n    var numMonths = this._get(inst, 'numberOfMonths');\n    return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));\n  },\n\n  /* Determine the current maximum date - ensure no time components are set. */\n  _getMinMaxDate: function(inst, minMax) {\n    return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);\n  },\n\n  /* Find the number of days in a given month. */\n  _getDaysInMonth: function(year, month) {\n    return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\n  },\n\n  /* Find the day of the week of the first of a month. */\n  _getFirstDayOfMonth: function(year, month) {\n    return new Date(year, month, 1).getDay();\n  },\n\n  /* Determines if we should allow a \"next/prev\" month display change. */\n  _canAdjustMonth: function(inst, offset, curYear, curMonth) {\n    var numMonths = this._getNumberOfMonths(inst);\n    var date = this._daylightSavingAdjust(new Date(curYear,\n      curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\n    if (offset < 0)\n      date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\n    return this._isInRange(inst, date);\n  },\n\n  /* Is the given date in the accepted range? */\n  _isInRange: function(inst, date) {\n    var minDate = this._getMinMaxDate(inst, 'min');\n    var maxDate = this._getMinMaxDate(inst, 'max');\n    return ((!minDate || date.getTime() >= minDate.getTime()) &&\n      (!maxDate || date.getTime() <= maxDate.getTime()));\n  },\n\n  /* Provide the configuration settings for formatting/parsing. */\n  _getFormatConfig: function(inst) {\n    var shortYearCutoff = this._get(inst, 'shortYearCutoff');\n    shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :\n      new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));\n    return {shortYearCutoff: shortYearCutoff,\n      dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),\n      monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};\n  },\n\n  /* Format the given date for display. */\n  _formatDate: function(inst, day, month, year) {\n    if (!day) {\n      inst.currentDay = inst.selectedDay;\n      inst.currentMonth = inst.selectedMonth;\n      inst.currentYear = inst.selectedYear;\n    }\n    var date = (day ? (typeof day == 'object' ? day :\n      this._daylightSavingAdjust(new Date(year, month, day))) :\n      this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));\n    return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));\n  }\n});\n\n/*\n * Bind hover events for datepicker elements.\n * Done via delegate so the binding only occurs once in the lifetime of the parent div.\n * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\n */ \nfunction bindHover(dpDiv) {\n  var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';\n  return dpDiv.bind('mouseout', function(event) {\n      var elem = $( event.target ).closest( selector );\n      if ( !elem.length ) {\n        return;\n      }\n      elem.removeClass( \"ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover\" );\n    })\n    .bind('mouseover', function(event) {\n      var elem = $( event.target ).closest( selector );\n      if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||\n          !elem.length ) {\n        return;\n      }\n      elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');\n      elem.addClass('ui-state-hover');\n      if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover');\n      if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover');\n    });\n}\n\n/* jQuery extend now ignores nulls! */\nfunction extendRemove(target, props) {\n  $.extend(target, props);\n  for (var name in props)\n    if (props[name] == null || props[name] == undefined)\n      target[name] = props[name];\n  return target;\n};\n\n/* Determine whether an object is an array. */\nfunction isArray(a) {\n  return (a && (($.browser.safari && typeof a == 'object' && a.length) ||\n    (a.constructor && a.constructor.toString().match(/\\Array\\(\\)/))));\n};\n\n/* Invoke the datepicker functionality.\n   @param  options  string - a command, optionally followed by additional parameters or\n                    Object - settings for attaching new datepicker functionality\n   @return  jQuery object */\n$.fn.datepicker = function(options){\n  \n  /* Verify an empty collection wasn't passed - Fixes #6976 */\n  if ( !this.length ) {\n    return this;\n  }\n  \n  /* Initialise the date picker. */\n  if (!$.datepicker.initialized) {\n    $(document).mousedown($.datepicker._checkExternalClick).\n      find('body').append($.datepicker.dpDiv);\n    $.datepicker.initialized = true;\n  }\n\n  var otherArgs = Array.prototype.slice.call(arguments, 1);\n  if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))\n    return $.datepicker['_' + options + 'Datepicker'].\n      apply($.datepicker, [this[0]].concat(otherArgs));\n  if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')\n    return $.datepicker['_' + options + 'Datepicker'].\n      apply($.datepicker, [this[0]].concat(otherArgs));\n  return this.each(function() {\n    typeof options == 'string' ?\n      $.datepicker['_' + options + 'Datepicker'].\n        apply($.datepicker, [this].concat(otherArgs)) :\n      $.datepicker._attachDatepicker(this, options);\n  });\n};\n\n$.datepicker = new Datepicker(); // singleton instance\n$.datepicker.initialized = false;\n$.datepicker.uuid = new Date().getTime();\n$.datepicker.version = \"1.8.18\";\n\n// Workaround for #4055\n// Add another global to avoid noConflict issues with inline event handlers\nwindow['DP_jQuery_' + dpuuid] = $;\n\n})(jQuery);\n\n})();\n//@ sourceURL=jquery-ui");