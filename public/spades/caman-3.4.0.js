minispade.register('caman', "(function() {// Generated by CoffeeScript 1.4.0\n(function() {\n  var $, Analyze, Blender, Calculate, Caman, CamanInstance, CamanParser, Canvas, Convert, Event, Fiber, Filter, IO, Image, Layer, Log, Logger, PixelInfo, Plugin, RenderJob, Root, Store, Util, fs, slice, vignetteFilters,\n    __hasProp = {}.hasOwnProperty,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  slice = Array.prototype.slice;\n\n  $ = function(sel, root) {\n    if (root == null) {\n      root = document;\n    }\n    if (typeof sel === \"object\") {\n      return sel;\n    }\n    return root.querySelector(sel);\n  };\n\n  Util = (function() {\n\n    function Util() {}\n\n    Util.uniqid = (function() {\n      var id;\n      id = 0;\n      return {\n        get: function() {\n          return id++;\n        }\n      };\n    })();\n\n    Util.extend = function(obj) {\n      var copy, dest, prop, src, _i, _len;\n      dest = obj;\n      src = slice.call(arguments, 1);\n      for (_i = 0, _len = src.length; _i < _len; _i++) {\n        copy = src[_i];\n        for (prop in copy) {\n          if (!__hasProp.call(copy, prop)) continue;\n          dest[prop] = copy[prop];\n        }\n      }\n      return dest;\n    };\n\n    Util.clampRGB = function(val) {\n      if (val < 0) {\n        return 0;\n      }\n      if (val > 255) {\n        return 255;\n      }\n      return val;\n    };\n\n    return Util;\n\n  })();\n\n  if (typeof exports !== \"undefined\" && exports !== null) {\n    Root = exports;\n    Canvas = require('canvas');\n    Image = Canvas.Image;\n    Fiber = require('fibers');\n    fs = require('fs');\n  } else {\n    Root = window;\n  }\n\n  Root.Caman = Caman = function() {\n    if (arguments.length === 0) {\n      throw \"Invalid arguments given\";\n    }\n    if (typeof exports !== \"undefined\" && exports !== null) {\n      return new CamanInstance(arguments, CamanInstance.Type.Node);\n    }\n    switch (arguments.length) {\n      case 1:\n        if (Store.has(arguments[0])) {\n          return Store.get(arguments[0]);\n        }\n        return new CamanInstance(arguments, CamanInstance.Type.Unknown);\n      case 2:\n        if (Store.has(arguments[0])) {\n          return Store.execute(arguments[0], arguments[1]);\n        }\n        if (typeof arguments[1] === 'function') {\n          return new CamanInstance(arguments, CamanInstance.Type.Unknown);\n        } else {\n          return new CamanInstance(arguments, CamanInstance.Type.Canvas);\n        }\n        break;\n      case 3:\n        if (Store.has(arguments[0])) {\n          return Store.execute(arguments[1], arguments[2]);\n        }\n        return new CamanInstance(arguments, CamanInstance.Type.Canvas);\n    }\n  };\n\n  Caman.version = {\n    release: \"3.3.0\",\n    date: \"12/13/12\"\n  };\n\n  Caman.DEBUG = false;\n\n  Caman.NodeJS = typeof exports !== \"undefined\" && exports !== null;\n\n  Caman.autoload = !Caman.NodeJS;\n\n  Caman.crossOrigin = \"anonymous\";\n\n  Caman.toString = function() {\n    return \"Version \" + Caman.version.release + \", Released \" + Caman.version.date;\n  };\n\n  Caman.remoteProxy = \"\";\n\n  Caman.Util = Util;\n\n  CamanInstance = (function() {\n\n    CamanInstance.Type = {\n      Image: 1,\n      Canvas: 2,\n      Unknown: 3,\n      Node: 4\n    };\n\n    CamanInstance.toString = Caman.toString;\n\n    function CamanInstance(args, type) {\n      var listener,\n        _this = this;\n      if (type == null) {\n        type = CamanInstance.Type.Canvas;\n      }\n      this.id = Util.uniqid.get();\n      this.analyze = new Analyze(this);\n      this.originalPixelData = [];\n      this.pixelStack = [];\n      this.layerStack = [];\n      this.renderQueue = [];\n      this.canvasQueue = [];\n      this.currentLayer = null;\n      if (type === CamanInstance.Type.Node) {\n        this.loadNode.apply(this, args);\n      } else {\n        if (document.readyState === \"complete\") {\n          this.domLoaded(args, type);\n        } else {\n          listener = function() {\n            if (document.readyState === \"complete\") {\n              return _this.domLoaded(args, type);\n            }\n          };\n          document.addEventListener(\"readystatechange\", listener, false);\n        }\n      }\n    }\n\n    CamanInstance.prototype.domLoaded = function(args, type) {\n      switch (type) {\n        case CamanInstance.Type.Image:\n          return this.loadImage.apply(this, args);\n        case CamanInstance.Type.Canvas:\n          return this.loadCanvas.apply(this, args);\n        case CamanInstance.Type.Unknown:\n          return this.loadUnknown(args);\n      }\n    };\n\n    CamanInstance.prototype.loadUnknown = function(args) {\n      var e;\n      e = $(args[0]);\n      switch (e.nodeName.toLowerCase()) {\n        case \"img\":\n          return this.loadImage.apply(this, args);\n        case \"canvas\":\n          return this.loadCanvas(null, args[0], args[1]);\n      }\n    };\n\n    CamanInstance.prototype.loadImage = function(id, callback) {\n      var image, proxyURL, _ref,\n        _this = this;\n      if (typeof id === \"object\" && ((_ref = id.nodeName) != null ? _ref.toLowerCase() : void 0) === \"img\") {\n        image = id;\n        if (!image.id) {\n          image.id = \"caman-\" + (Util.uniqid.get());\n        }\n      } else {\n        if ($(id) != null) {\n          image = $(id);\n        } else {\n          throw \"Could not find element \" + id;\n        }\n      }\n      proxyURL = IO.remoteCheck(image.src);\n      if (proxyURL) {\n        image.onload = function() {\n          return _this.imageLoaded(id, image, callback);\n        };\n        return image.src = proxyURL;\n      } else {\n        if (image.complete) {\n          return this.imageLoaded(id, image, callback);\n        } else {\n          return image.onload = function() {\n            return _this.imageLoaded(id, image, callback);\n          };\n        }\n      }\n    };\n\n    CamanInstance.prototype.imageLoaded = function(id, image, callback) {\n      var attr, _i, _len, _ref;\n      this.image = image;\n      if (!image || image.nodeName.toLowerCase() !== \"img\") {\n        throw \"Given element ID isn't an image: \" + id;\n      }\n      this.canvas = document.createElement('canvas');\n      this.canvas.id = image.id;\n      _ref = ['data-camanwidth', 'data-camanheight'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        attr = _ref[_i];\n        if (this.image.getAttribute(attr)) {\n          this.canvas.setAttribute(attr, this.image.getAttribute(attr));\n        }\n      }\n      if (image.parentNode != null) {\n        image.parentNode.replaceChild(this.canvas, this.image);\n      }\n      this.canvasID = id;\n      this.options = {\n        canvas: id,\n        image: this.image.src\n      };\n      if (this.image.crossOrigin) {\n        this.options.crossOrigin = this.image.crossOrigin;\n      }\n      return this.finishInit(callback);\n    };\n\n    CamanInstance.prototype.loadCanvas = function(url, id, callback) {\n      var element, _ref;\n      if (typeof id === \"object\" && ((_ref = id.nodeName) != null ? _ref.toLowerCase() : void 0) === \"canvas\") {\n        element = id;\n        if (!element.id) {\n          element.id = \"caman-\" + (Util.uniqid.get());\n        }\n      } else {\n        if ($(id) != null) {\n          element = $(id);\n        } else {\n          throw \"Could not find element \" + id;\n        }\n      }\n      return this.canvasLoaded(url, element, callback);\n    };\n\n    CamanInstance.prototype.canvasLoaded = function(url, canvas, callback) {\n      var proxyURL,\n        _this = this;\n      this.canvas = canvas;\n      if (!canvas || canvas.nodeName.toLowerCase() !== \"canvas\") {\n        throw \"Given element ID isn't a canvas: \" + id;\n      }\n      if (url != null) {\n        this.image = document.createElement('img');\n        this.image.onload = function() {\n          return _this.finishInit(callback);\n        };\n        proxyURL = IO.remoteCheck(url);\n        if (proxyURL) {\n          url = proxyURL;\n        }\n        this.canvasID = this.canvas.id;\n        this.options = {\n          canvas: canvas.id,\n          image: url\n        };\n        if (IO.isRemote(url)) {\n          this.image.crossOrigin = Caman.crossOrigin;\n        }\n        return this.image.src = url;\n      } else {\n        return this.finishInit(callback);\n      }\n    };\n\n    CamanInstance.prototype.loadNode = function(file, callback) {\n      var img,\n        _this = this;\n      img = new Image();\n      if (typeof file === \"string\") {\n        file = fs.realpathSync(file);\n      }\n      img.onload = function() {\n        var context;\n        _this.canvasID = Util.uniqid.get();\n        _this.canvas = new Canvas(img.width, img.height);\n        context = _this.canvas.getContext('2d');\n        context.drawImage(img, 0, 0);\n        return _this.finishInit(callback);\n      };\n      img.onerror = function(err) {\n        throw err;\n      };\n      return img.src = file;\n    };\n\n    CamanInstance.prototype.finishInit = function(callback) {\n      var newHeight, newWidth, oldHeight, oldWidth, pixel, _i, _len, _ref;\n      if (callback == null) {\n        callback = function() {};\n      }\n      this.context = this.canvas.getContext(\"2d\");\n      if (this.image != null) {\n        oldWidth = this.image.width;\n        oldHeight = this.image.height;\n        newWidth = this.canvas.getAttribute('data-camanwidth');\n        newHeight = this.canvas.getAttribute('data-camanheight');\n        if (newWidth || newHeight) {\n          if (newWidth) {\n            this.image.width = parseInt(newWidth, 10);\n            if (newHeight) {\n              this.image.height = parseInt(newHeight, 10);\n            } else {\n              this.image.height = this.image.width * oldHeight / oldWidth;\n            }\n          } else if (newHeight) {\n            this.image.height = parseInt(newHeight, 10);\n            this.image.width = this.image.height * oldWidth / oldHeight;\n          }\n        }\n        this.canvas.width = this.image.width;\n        this.canvas.height = this.image.height;\n        if (window.devicePixelRatio) {\n          this.canvas.style.width = \"\" + this.image.width + \"px\";\n          this.canvas.style.height = \"\" + this.image.height + \"px\";\n          this.canvas.width = this.image.width * window.devicePixelRatio;\n          this.canvas.height = this.image.height * window.devicePixelRatio;\n          this.context.scale(window.devicePixelRatio, window.devicePixelRatio);\n        }\n        this.context.drawImage(this.image, 0, 0, this.image.width, this.image.height);\n      }\n      this.imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n      this.pixelData = this.imageData.data;\n      _ref = this.pixelData;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        pixel = _ref[_i];\n        this.originalPixelData.push(pixel);\n      }\n      this.dimensions = {\n        width: this.canvas.width,\n        height: this.canvas.height\n      };\n      Store.put(this.canvasID, this);\n      callback.call(this, this);\n      return this;\n    };\n\n    CamanInstance.prototype.replaceCanvas = function(newCanvas) {\n      var oldCanvas;\n      oldCanvas = this.canvas;\n      this.canvas = newCanvas;\n      if (oldCanvas.parentNode != null) {\n        oldCanvas.parentNode.replaceChild(this.canvas, oldCanvas);\n      }\n      this.context = this.canvas.getContext('2d');\n      this.imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n      this.pixelData = this.imageData.data;\n      return this.dimensions = {\n        width: this.canvas.width,\n        height: this.canvas.height\n      };\n    };\n\n    return CamanInstance;\n\n  })();\n\n  Analyze = (function() {\n\n    function Analyze(c) {\n      this.c = c;\n    }\n\n    Analyze.prototype.calculateLevels = function() {\n      var i, levels, numPixels, _i, _j, _k, _ref;\n      levels = {\n        r: {},\n        g: {},\n        b: {}\n      };\n      for (i = _i = 0; _i <= 255; i = ++_i) {\n        levels.r[i] = 0;\n        levels.g[i] = 0;\n        levels.b[i] = 0;\n      }\n      for (i = _j = 0, _ref = this.c.pixelData.length; _j < _ref; i = _j += 4) {\n        levels.r[this.c.pixelData[i]]++;\n        levels.g[this.c.pixelData[i + 1]]++;\n        levels.b[this.c.pixelData[i + 2]]++;\n      }\n      numPixels = this.c.pixelData.length / 4;\n      for (i = _k = 0; _k <= 255; i = ++_k) {\n        levels.r[i] /= numPixels;\n        levels.g[i] /= numPixels;\n        levels.b[i] /= numPixels;\n      }\n      return levels;\n    };\n\n    return Analyze;\n\n  })();\n\n  Caman.DOMUpdated = function() {\n    var img, imgs, parser, _i, _len, _results;\n    imgs = document.querySelectorAll(\"img[data-caman]\");\n    if (!(imgs.length > 0)) {\n      return;\n    }\n    _results = [];\n    for (_i = 0, _len = imgs.length; _i < _len; _i++) {\n      img = imgs[_i];\n      _results.push(parser = new CamanParser(img, function() {\n        this.parse();\n        return this.execute();\n      }));\n    }\n    return _results;\n  };\n\n  if (Caman.autoload) {\n    (function() {\n      if (document.readyState === \"complete\") {\n        return Caman.DOMUpdated();\n      } else {\n        return document.addEventListener(\"DOMContentLoaded\", Caman.DOMUpdated, false);\n      }\n    })();\n  }\n\n  CamanParser = (function() {\n    var INST_REGEX;\n\n    INST_REGEX = \"(\\\\w+)\\\\((.*?)\\\\)\";\n\n    function CamanParser(ele, ready) {\n      this.dataStr = ele.getAttribute('data-caman');\n      this.caman = Caman(ele, ready.bind(this));\n    }\n\n    CamanParser.prototype.parse = function() {\n      var args, filter, func, inst, instFunc, m, r, unparsedInstructions, _i, _len, _ref, _results;\n      this.ele = this.caman.canvas;\n      r = new RegExp(INST_REGEX, 'g');\n      unparsedInstructions = this.dataStr.match(r);\n      if (!(unparsedInstructions.length > 0)) {\n        return;\n      }\n      r = new RegExp(INST_REGEX);\n      _results = [];\n      for (_i = 0, _len = unparsedInstructions.length; _i < _len; _i++) {\n        inst = unparsedInstructions[_i];\n        _ref = inst.match(r), m = _ref[0], filter = _ref[1], args = _ref[2];\n        instFunc = new Function(\"return function() {        this.\" + filter + \"(\" + args + \");      };\");\n        try {\n          func = instFunc();\n          _results.push(func.call(this.caman));\n        } catch (e) {\n          _results.push(Log.debug(e));\n        }\n      }\n      return _results;\n    };\n\n    CamanParser.prototype.execute = function() {\n      var ele;\n      ele = this.ele;\n      return this.caman.render(function() {\n        return ele.parentNode.replaceChild(this.toImage(), ele);\n      });\n    };\n\n    return CamanParser;\n\n  })();\n\n  Blender = (function() {\n\n    function Blender() {}\n\n    Blender.blenders = {};\n\n    Blender.register = function(name, func) {\n      return this.blenders[name] = func;\n    };\n\n    Blender.execute = function(name, rgbaLayer, rgbaParent) {\n      return this.blenders[name](rgbaLayer, rgbaParent);\n    };\n\n    return Blender;\n\n  })();\n\n  Caman.Blender = Blender;\n\n  Calculate = (function() {\n\n    function Calculate() {}\n\n    Calculate.distance = function(x1, y1, x2, y2) {\n      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    };\n\n    Calculate.randomRange = function(min, max, getFloat) {\n      var rand;\n      if (getFloat == null) {\n        getFloat = false;\n      }\n      rand = min + (Math.random() * (max - min));\n      if (getFloat) {\n        return rand.toFixed(getFloat);\n      } else {\n        return Math.round(rand);\n      }\n    };\n\n    Calculate.luminance = function(rgba) {\n      return (0.27 * rgba.r) + (0.67 * rgba.g) + (0.06 * rgba.b);\n    };\n\n    Calculate.bezier = function(start, ctrl1, ctrl2, end, lowBound, highBound) {\n      var Ax, Ay, Bx, By, Cx, Cy, bezier, curveX, curveY, i, j, leftCoord, rightCoord, t, x0, x1, x2, x3, y0, y1, y2, y3, _i, _j, _k, _ref, _ref1;\n      x0 = start[0];\n      y0 = start[1];\n      x1 = ctrl1[0];\n      y1 = ctrl1[1];\n      x2 = ctrl2[0];\n      y2 = ctrl2[1];\n      x3 = end[0];\n      y3 = end[1];\n      bezier = {};\n      Cx = parseInt(3 * (x1 - x0), 10);\n      Bx = 3 * (x2 - x1) - Cx;\n      Ax = x3 - x0 - Cx - Bx;\n      Cy = 3 * (y1 - y0);\n      By = 3 * (y2 - y1) - Cy;\n      Ay = y3 - y0 - Cy - By;\n      for (i = _i = 0; _i < 1000; i = ++_i) {\n        t = i / 1000;\n        curveX = Math.round((Ax * Math.pow(t, 3)) + (Bx * Math.pow(t, 2)) + (Cx * t) + x0);\n        curveY = Math.round((Ay * Math.pow(t, 3)) + (By * Math.pow(t, 2)) + (Cy * t) + y0);\n        if (lowBound && curveY < lowBound) {\n          curveY = lowBound;\n        } else if (highBound && curveY > highBound) {\n          curveY = highBound;\n        }\n        bezier[curveX] = curveY;\n      }\n      if (bezier.length < end[0] + 1) {\n        for (i = _j = 0, _ref = end[0]; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {\n          if (!(bezier[i] != null)) {\n            leftCoord = [i - 1, bezier[i - 1]];\n            for (j = _k = i, _ref1 = end[0]; i <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = i <= _ref1 ? ++_k : --_k) {\n              if (bezier[j] != null) {\n                rightCoord = [j, bezier[j]];\n                break;\n              }\n            }\n            bezier[i] = leftCoord[1] + ((rightCoord[1] - leftCoord[1]) / (rightCoord[0] - leftCoord[0])) * (i - leftCoord[0]);\n          }\n        }\n      }\n      if (!(bezier[end[0]] != null)) {\n        bezier[end[0]] = bezier[end[0] - 1];\n      }\n      return bezier;\n    };\n\n    return Calculate;\n\n  })();\n\n  Convert = (function() {\n\n    function Convert() {}\n\n    Convert.hexToRGB = function(hex) {\n      var b, g, r;\n      if (hex.charAt(0) === \"#\") {\n        hex = hex.substr(1);\n      }\n      r = parseInt(hex.substr(0, 2), 16);\n      g = parseInt(hex.substr(2, 2), 16);\n      b = parseInt(hex.substr(4, 2), 16);\n      return {\n        r: r,\n        g: g,\n        b: b\n      };\n    };\n\n    Convert.rgbToHSL = function(r, g, b) {\n      var d, h, l, max, min, s;\n      if (typeof r === \"object\") {\n        g = r.g;\n        b = r.b;\n        r = r.r;\n      }\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      max = Math.max(r, g, b);\n      min = Math.min(r, g, b);\n      l = (max + min) / 2;\n      if (max === min) {\n        h = s = 0;\n      } else {\n        d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        h = (function() {\n          switch (max) {\n            case r:\n              return (g - b) / d + (g < b ? 6 : 0);\n            case g:\n              return (b - r) / d + 2;\n            case b:\n              return (r - g) / d + 4;\n          }\n        })();\n        h /= 6;\n      }\n      return {\n        h: h,\n        s: s,\n        l: l\n      };\n    };\n\n    Convert.hslToRGB = function(h, s, l) {\n      var b, g, p, q, r;\n      if (typeof h === \"object\") {\n        s = h.s;\n        l = h.l;\n        h = h.h;\n      }\n      if (s === 0) {\n        r = g = b = l;\n      } else {\n        q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        p = 2 * l - q;\n        r = this.hueToRGB(p, q, h + 1 / 3);\n        g = this.hueToRGB(p, q, h);\n        b = this.hueToRGB(p, q, h - 1 / 3);\n      }\n      return {\n        r: r * 255,\n        g: g * 255,\n        b: b * 255\n      };\n    };\n\n    Convert.hueToRGB = function(p, q, t) {\n      if (t < 0) {\n        t += 1;\n      }\n      if (t > 1) {\n        t -= 1;\n      }\n      if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n      }\n      if (t < 1 / 2) {\n        return q;\n      }\n      if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      }\n      return p;\n    };\n\n    Convert.rgbToHSV = function(r, g, b) {\n      var d, h, max, min, s, v;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      max = Math.max(r, g, b);\n      min = Math.min(r, g, b);\n      v = max;\n      d = max - min;\n      s = max === 0 ? 0 : d / max;\n      if (max === min) {\n        h = 0;\n      } else {\n        h = (function() {\n          switch (max) {\n            case r:\n              return (g - b) / d + (g < b ? 6 : 0);\n            case g:\n              return (b - r) / d + 2;\n            case b:\n              return (r - g) / d + 4;\n          }\n        })();\n        h /= 6;\n      }\n      return {\n        h: h,\n        s: s,\n        v: v\n      };\n    };\n\n    Convert.hsvToRGB = function(h, s, v) {\n      var b, f, g, i, p, q, r, t;\n      i = Math.floor(h * 6);\n      f = h * 6 - i;\n      p = v * (1 - s);\n      q = v * (1 - f * s);\n      t = v * (1 - (1 - f) * s);\n      switch (i % 6) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = p;\n          b = q;\n      }\n      return {\n        r: r * 255,\n        g: g * 255,\n        b: b * 255\n      };\n    };\n\n    Convert.rgbToXYZ = function(r, g, b) {\n      var x, y, z;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      if (r > 0.04045) {\n        r = Math.pow((r + 0.055) / 1.055, 2.4);\n      } else {\n        r /= 12.92;\n      }\n      if (g > 0.04045) {\n        g = Math.pow((g + 0.055) / 1.055, 2.4);\n      } else {\n        g /= 12.92;\n      }\n      if (b > 0.04045) {\n        b = Math.pow((b + 0.055) / 1.055, 2.4);\n      } else {\n        b /= 12.92;\n      }\n      x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return {\n        x: x * 100,\n        y: y * 100,\n        z: z * 100\n      };\n    };\n\n    Convert.xyzToRGB = function(x, y, z) {\n      var b, g, r;\n      x /= 100;\n      y /= 100;\n      z /= 100;\n      r = (3.2406 * x) + (-1.5372 * y) + (-0.4986 * z);\n      g = (-0.9689 * x) + (1.8758 * y) + (0.0415 * z);\n      b = (0.0557 * x) + (-0.2040 * y) + (1.0570 * z);\n      if (r > 0.0031308) {\n        r = (1.055 * Math.pow(r, 0.4166666667)) - 0.055;\n      } else {\n        r *= 12.92;\n      }\n      if (g > 0.0031308) {\n        g = (1.055 * Math.pow(g, 0.4166666667)) - 0.055;\n      } else {\n        g *= 12.92;\n      }\n      if (b > 0.0031308) {\n        b = (1.055 * Math.pow(b, 0.4166666667)) - 0.055;\n      } else {\n        b *= 12.92;\n      }\n      return {\n        r: r * 255,\n        g: g * 255,\n        b: b * 255\n      };\n    };\n\n    Convert.xyzToLab = function(x, y, z) {\n      var a, b, l, whiteX, whiteY, whiteZ;\n      if (typeof x === \"object\") {\n        y = x.y;\n        z = x.z;\n        x = x.x;\n      }\n      whiteX = 95.047;\n      whiteY = 100.0;\n      whiteZ = 108.883;\n      x /= whiteX;\n      y /= whiteY;\n      z /= whiteZ;\n      if (x > 0.008856451679) {\n        x = Math.pow(x, 0.3333333333);\n      } else {\n        x = (7.787037037 * x) + 0.1379310345;\n      }\n      if (y > 0.008856451679) {\n        y = Math.pow(y, 0.3333333333);\n      } else {\n        y = (7.787037037 * y) + 0.1379310345;\n      }\n      if (z > 0.008856451679) {\n        z = Math.pow(z, 0.3333333333);\n      } else {\n        z = (7.787037037 * z) + 0.1379310345;\n      }\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return {\n        l: l,\n        a: a,\n        b: b\n      };\n    };\n\n    Convert.labToXYZ = function(l, a, b) {\n      var x, y, z;\n      if (typeof l === \"object\") {\n        a = l.a;\n        b = l.b;\n        l = l.l;\n      }\n      y = (l + 16) / 116;\n      x = y + (a / 500);\n      z = y - (b / 200);\n      if (x > 0.2068965517) {\n        x = x * x * x;\n      } else {\n        x = 0.1284185493 * (x - 0.1379310345);\n      }\n      if (y > 0.2068965517) {\n        y = y * y * y;\n      } else {\n        y = 0.1284185493 * (y - 0.1379310345);\n      }\n      if (z > 0.2068965517) {\n        z = z * z * z;\n      } else {\n        z = 0.1284185493 * (z - 0.1379310345);\n      }\n      return {\n        x: x * 95.047,\n        y: y * 100.0,\n        z: z * 108.883\n      };\n    };\n\n    Convert.rgbToLab = function(r, g, b) {\n      var xyz;\n      if (typeof r === \"object\") {\n        g = r.g;\n        b = r.b;\n        r = r.r;\n      }\n      xyz = this.rgbToXYZ(r, g, b);\n      return this.xyzToLab(xyz);\n    };\n\n    Convert.labToRGB = function(l, a, b) {};\n\n    return Convert;\n\n  })();\n\n  Event = (function() {\n\n    function Event() {}\n\n    Event.events = {};\n\n    Event.types = [\"processStart\", \"processComplete\", \"renderStart\", \"renderFinished\", \"blockStarted\", \"blockFinished\"];\n\n    Event.trigger = function(target, type, data) {\n      var event, _i, _len, _ref, _results;\n      if (this.events[type] && this.events[type].length) {\n        _ref = this.events[type];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          event = _ref[_i];\n          if (event.target === null || target.id === event.target.id) {\n            _results.push(event.fn.call(target, data));\n          } else {\n            _results.push(void 0);\n          }\n        }\n        return _results;\n      }\n    };\n\n    Event.listen = function(target, type, fn) {\n      var _fn, _type;\n      if (typeof target === \"string\") {\n        _type = target;\n        _fn = type;\n        target = null;\n        type = _type;\n        fn = _fn;\n      }\n      if (__indexOf.call(this.types, type) < 0) {\n        return false;\n      }\n      if (!this.events[type]) {\n        this.events[type] = [];\n      }\n      this.events[type].push({\n        target: target,\n        fn: fn\n      });\n      return true;\n    };\n\n    return Event;\n\n  })();\n\n  Caman.Event = Event;\n\n  Filter = (function() {\n\n    function Filter() {}\n\n    Filter.Type = {\n      Single: 1,\n      Kernel: 2,\n      LayerDequeue: 3,\n      LayerFinished: 4,\n      LoadOverlay: 5,\n      Plugin: 6\n    };\n\n    Filter.register = function(name, filterFunc) {\n      return CamanInstance.prototype[name] = filterFunc;\n    };\n\n    Filter.prototype.render = function(callback) {\n      var _this = this;\n      if (callback == null) {\n        callback = function() {};\n      }\n      Event.trigger(this, \"renderStart\");\n      return this.processNext(function() {\n        _this.context.putImageData(_this.imageData, 0, 0);\n        return callback.call(_this);\n      });\n    };\n\n    Filter.prototype.revert = function(ready) {\n      var i, pixel, _i, _len, _ref;\n      if (ready == null) {\n        ready = function() {};\n      }\n      _ref = this.originalPixelData;\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        pixel = _ref[i];\n        this.pixelData[i] = pixel;\n      }\n      this.context.putImageData(this.imageData, 0, 0);\n      return ready.call(this);\n    };\n\n    Filter.prototype.process = function(name, processFn) {\n      this.renderQueue.push({\n        type: Filter.Type.Single,\n        name: name,\n        processFn: processFn\n      });\n      return this;\n    };\n\n    Filter.prototype.processKernel = function(name, adjust, divisor, bias) {\n      var i, _i, _ref;\n      if (!divisor) {\n        divisor = 0;\n        for (i = _i = 0, _ref = adjust.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          divisor += adjust[i];\n        }\n      }\n      this.renderQueue.push({\n        type: Filter.Type.Kernel,\n        name: name,\n        adjust: adjust,\n        divisor: divisor,\n        bias: bias || 0\n      });\n      return this;\n    };\n\n    Filter.prototype.processPlugin = function(plugin, args) {\n      this.renderQueue.push({\n        type: Filter.Type.Plugin,\n        plugin: plugin,\n        args: args\n      });\n      return this;\n    };\n\n    Filter.prototype.processNext = function(finishedFn) {\n      var next,\n        _this = this;\n      if (typeof finishedFn === \"function\") {\n        this.finishedFn = finishedFn;\n      }\n      if (this.renderQueue.length === 0) {\n        if (this.finishedFn != null) {\n          Event.trigger(this, \"renderFinished\");\n          this.finishedFn.call(this);\n        }\n        return this;\n      }\n      next = this.renderQueue.shift();\n      return RenderJob.execute(this, next, function() {\n        return _this.processNext();\n      });\n    };\n\n    Filter.prototype.newLayer = function(callback) {\n      var layer;\n      layer = new Layer(this);\n      this.canvasQueue.push(layer);\n      this.renderQueue.push({\n        type: Filter.Type.LayerDequeue\n      });\n      callback.call(layer);\n      this.renderQueue.push({\n        type: Filter.Type.LayerFinished\n      });\n      return this;\n    };\n\n    Filter.prototype.executeLayer = function(layer) {\n      this.pushContext(layer);\n      return this.processNext();\n    };\n\n    Filter.prototype.pushContext = function(layer) {\n      this.layerStack.push(this.currentLayer);\n      this.pixelStack.push(this.pixelData);\n      this.currentLayer = layer;\n      return this.pixelData = layer.pixelData;\n    };\n\n    Filter.prototype.popContext = function() {\n      this.pixelData = this.pixelStack.pop();\n      return this.currentLayer = this.layerStack.pop();\n    };\n\n    Filter.prototype.applyCurrentLayer = function() {\n      return this.currentLayer.applyToParent();\n    };\n\n    return Filter;\n\n  })();\n\n  Util.extend(CamanInstance.prototype, Filter.prototype);\n\n  Caman.Filter = Filter;\n\n  IO = (function() {\n\n    function IO() {}\n\n    IO.domainRegex = /(?:(?:http|https):\\/\\/)((?:\\w+)\\.(?:(?:\\w|\\.)+))/;\n\n    IO.isRemote = function(url) {\n      var matches;\n      if (!url) {\n        return;\n      }\n      matches = url.match(this.domainRegex);\n      if (matches) {\n        return matches[1] !== document.domain;\n      } else {\n        return false;\n      }\n    };\n\n    IO.remoteCheck = function(src) {\n      if (this.isRemote(src)) {\n        if (!Caman.remoteProxy.length) {\n          Log.info(\"Attempting to load a remote image without a configured proxy. URL: \" + src);\n        } else {\n          if (this.isRemote(Caman.remoteProxy)) {\n            Log.info(\"Cannot use a remote proxy for loading images.\");\n            return;\n          }\n          return \"\" + Caman.remoteProxy + \"?camanProxyUrl=\" + (encodeURIComponent(src));\n        }\n      }\n    };\n\n    IO.useProxy = function(lang) {\n      var langToExt;\n      langToExt = {\n        ruby: 'rb',\n        python: 'py',\n        perl: 'pl',\n        javascript: 'js'\n      };\n      lang = lang.toLowerCase();\n      if (langToExt[lang] != null) {\n        lang = langToExt[lang];\n      }\n      return \"proxies/caman_proxy.\" + lang;\n    };\n\n    IO.prototype.save = function() {\n      if (typeof exports !== \"undefined\" && exports !== null) {\n        return this.nodeSave.apply(this, arguments);\n      } else {\n        return this.browserSave.apply(this, arguments);\n      }\n    };\n\n    IO.prototype.browserSave = function(type) {\n      var image;\n      if (type == null) {\n        type = \"png\";\n      }\n      type = type.toLowerCase();\n      image = this.toBase64(type).replace(\"image/\" + type, \"image/octet-stream\");\n      return document.location.href = image;\n    };\n\n    IO.prototype.nodeSave = function(file, overwrite) {\n      var stats;\n      if (overwrite == null) {\n        overwrite = true;\n      }\n      try {\n        stats = fs.statSync(file);\n        if (stats.isFile() && !overwrite) {\n          return false;\n        }\n      } catch (e) {\n        Log.debug(\"Creating output file \" + file);\n      }\n      return fs.writeFile(file, this.canvas.toBuffer(), function() {\n        return Log.debug(\"Finished writing to \" + file);\n      });\n    };\n\n    IO.prototype.toImage = function(type) {\n      var img;\n      img = document.createElement('img');\n      img.src = this.toBase64(type);\n      img.width = this.dimensions.width;\n      img.height = this.dimensions.height;\n      if (window.devicePixelRatio) {\n        img.width /= window.devicePixelRatio;\n        img.height /= window.devicePixelRatio;\n      }\n      return img;\n    };\n\n    IO.prototype.toBase64 = function(type) {\n      if (type == null) {\n        type = \"png\";\n      }\n      type = type.toLowerCase();\n      return this.canvas.toDataURL(\"image/\" + type);\n    };\n\n    return IO;\n\n  })();\n\n  Util.extend(CamanInstance.prototype, IO.prototype);\n\n  Caman.IO = IO;\n\n  Layer = (function() {\n\n    function Layer(c) {\n      this.c = c;\n      this.filter = this.c;\n      this.options = {\n        blendingMode: 'normal',\n        opacity: 1.0\n      };\n      this.layerID = Util.uniqid.get();\n      this.canvas = typeof exports !== \"undefined\" && exports !== null ? new Canvas() : document.createElement('canvas');\n      this.canvas.width = this.c.dimensions.width;\n      this.canvas.height = this.c.dimensions.height;\n      this.context = this.canvas.getContext('2d');\n      this.context.createImageData(this.canvas.width, this.canvas.height);\n      this.imageData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);\n      this.pixelData = this.imageData.data;\n    }\n\n    Layer.prototype.newLayer = function(cb) {\n      return this.c.newLayer.call(this.c, cb);\n    };\n\n    Layer.prototype.setBlendingMode = function(mode) {\n      this.options.blendingMode = mode;\n      return this;\n    };\n\n    Layer.prototype.opacity = function(opacity) {\n      this.options.opacity = opacity / 100;\n      return this;\n    };\n\n    Layer.prototype.copyParent = function() {\n      var i, parentData, _i, _ref;\n      parentData = this.c.pixelData;\n      for (i = _i = 0, _ref = this.c.pixelData.length; _i < _ref; i = _i += 4) {\n        this.pixelData[i] = parentData[i];\n        this.pixelData[i + 1] = parentData[i + 1];\n        this.pixelData[i + 2] = parentData[i + 2];\n        this.pixelData[i + 3] = parentData[i + 3];\n      }\n      return this;\n    };\n\n    Layer.prototype.fillColor = function() {\n      return this.c.fillColor.apply(this.c, arguments);\n    };\n\n    Layer.prototype.overlayImage = function(image) {\n      if (typeof image === \"object\") {\n        image = image.src;\n      } else if (typeof image === \"string\" && image[0] === \"#\") {\n        image = $(image).src;\n      }\n      if (!image) {\n        return this;\n      }\n      this.c.renderQueue.push({\n        type: Filter.Type.LoadOverlay,\n        src: image,\n        layer: this\n      });\n      return this;\n    };\n\n    Layer.prototype.applyToParent = function() {\n      var i, layerData, parentData, result, rgbaLayer, rgbaParent, _i, _ref, _results;\n      parentData = this.c.pixelStack[this.c.pixelStack.length - 1];\n      layerData = this.c.pixelData;\n      _results = [];\n      for (i = _i = 0, _ref = layerData.length; _i < _ref; i = _i += 4) {\n        rgbaParent = {\n          r: parentData[i],\n          g: parentData[i + 1],\n          b: parentData[i + 2],\n          a: parentData[i + 3]\n        };\n        rgbaLayer = {\n          r: layerData[i],\n          g: layerData[i + 1],\n          b: layerData[i + 2],\n          a: layerData[i + 3]\n        };\n        result = Blender.execute(this.options.blendingMode, rgbaLayer, rgbaParent);\n        result.r = Util.clampRGB(result.r);\n        result.g = Util.clampRGB(result.g);\n        result.b = Util.clampRGB(result.b);\n        if (!(result.a != null)) {\n          result.a = rgbaLayer.a;\n        }\n        parentData[i] = rgbaParent.r - ((rgbaParent.r - result.r) * (this.options.opacity * (result.a / 255)));\n        parentData[i + 1] = rgbaParent.g - ((rgbaParent.g - result.g) * (this.options.opacity * (result.a / 255)));\n        _results.push(parentData[i + 2] = rgbaParent.b - ((rgbaParent.b - result.b) * (this.options.opacity * (result.a / 255))));\n      }\n      return _results;\n    };\n\n    return Layer;\n\n  })();\n\n  Logger = (function() {\n\n    function Logger() {\n      var name, _i, _len, _ref;\n      _ref = ['log', 'info', 'warn', 'error'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        this[name] = (function(name) {\n          return function() {\n            if (!Caman.DEBUG) {\n              return;\n            }\n            return console[name].apply(console, arguments);\n          };\n        })(name);\n      }\n      this.debug = this.log;\n    }\n\n    return Logger;\n\n  })();\n\n  Log = new Logger();\n\n  PixelInfo = (function() {\n\n    function PixelInfo(c) {\n      this.c = c;\n      this.loc = 0;\n    }\n\n    PixelInfo.prototype.locationXY = function() {\n      var x, y;\n      y = this.c.dimensions.height - Math.floor(this.loc / (this.c.dimensions.width * 4));\n      x = (this.loc % (this.c.dimensions.width * 4)) / 4;\n      return {\n        x: x,\n        y: y\n      };\n    };\n\n    PixelInfo.prototype.getPixelRelative = function(horiz, vert) {\n      var newLoc;\n      newLoc = this.loc + (this.c.dimensions.width * 4 * (vert * -1)) + (4 * horiz);\n      if (newLoc > this.c.pixelData.length || newLoc < 0) {\n        return {\n          r: 0,\n          g: 0,\n          b: 0,\n          a: 0\n        };\n      }\n      return {\n        r: this.c.pixelData[newLoc],\n        g: this.c.pixelData[newLoc + 1],\n        b: this.c.pixelData[newLoc + 2],\n        a: this.c.pixelData[newLoc + 3]\n      };\n    };\n\n    PixelInfo.prototype.putPixelRelative = function(horiz, vert, rgba) {\n      var nowLoc;\n      nowLoc = this.loc + (this.c.dimensions.width * 4 * (vert * -1)) + (4 * horiz);\n      if (newLoc > this.c.pixelData.length || newLoc < 0) {\n        return;\n      }\n      this.c.pixelData[newLoc] = rgba.r;\n      this.c.pixelData[newLoc + 1] = rgba.g;\n      this.c.pixelData[newLoc + 2] = rgba.b;\n      this.c.pixelData[newLoc + 3] = rgba.a;\n      return true;\n    };\n\n    PixelInfo.prototype.getPixel = function(x, y) {\n      var loc;\n      loc = (y * this.c.dimensions.width + x) * 4;\n      return {\n        r: this.c.pixelData[loc],\n        g: this.c.pixelData[loc + 1],\n        b: this.c.pixelData[loc + 2],\n        a: this.c.pixelData[loc + 3]\n      };\n    };\n\n    PixelInfo.prototype.putPixel = function(x, y, rgba) {\n      var loc;\n      loc = (y * this.c.dimensions.width + x) * 4;\n      this.c.pixelData[loc] = rgba.r;\n      this.c.pixelData[loc + 1] = rgba.g;\n      this.c.pixelData[loc + 2] = rgba.b;\n      return this.c.pixelData[loc + 3] = rgba.a;\n    };\n\n    return PixelInfo;\n\n  })();\n\n  Plugin = (function() {\n\n    function Plugin() {}\n\n    Plugin.plugins = {};\n\n    Plugin.register = function(name, plugin) {\n      return this.plugins[name] = plugin;\n    };\n\n    Plugin.execute = function(context, name, args) {\n      return this.plugins[name].apply(context, args);\n    };\n\n    return Plugin;\n\n  })();\n\n  Caman.Plugin = Plugin;\n\n  RenderJob = (function() {\n\n    RenderJob.Blocks = Caman.NodeJS ? require('os').cpus().length : 4;\n\n    RenderJob.execute = function(instance, job, callback) {\n      var layer, rj;\n      rj = new RenderJob(instance, job, callback);\n      switch (job.type) {\n        case Filter.Type.LayerDequeue:\n          layer = instance.canvasQueue.shift();\n          instance.executeLayer(layer);\n          break;\n        case Filter.Type.LayerFinished:\n          instance.applyCurrentLayer();\n          instance.popContext();\n          callback();\n          break;\n        case Filter.Type.LoadOverlay:\n          rj.loadOverlay(job.layer, job.src);\n          break;\n        case Filter.Type.Plugin:\n          rj.executePlugin();\n          break;\n        default:\n          rj.executeFilter();\n      }\n      return instance;\n    };\n\n    function RenderJob(c, job, renderDone) {\n      this.c = c;\n      this.job = job;\n      this.renderDone = renderDone;\n    }\n\n    RenderJob.prototype.executeFilter = function() {\n      var blockN, blockPixelLength, end, f, j, lastBlockN, n, start, _i, _ref, _results,\n        _this = this;\n      this.blocksDone = 0;\n      n = this.c.pixelData.length;\n      blockPixelLength = Math.floor((n / 4) / RenderJob.Blocks);\n      blockN = blockPixelLength * 4;\n      lastBlockN = blockN + ((n / 4) % RenderJob.Blocks) * 4;\n      Event.trigger(this.c, \"processStart\", this.job);\n      if (this.job.type === Filter.Type.Single) {\n        _results = [];\n        for (j = _i = 0, _ref = RenderJob.Blocks; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {\n          start = j * blockN;\n          end = start + (j === RenderJob.Blocks - 1 ? lastBlockN : blockN);\n          if (Caman.NodeJS) {\n            f = Fiber(function() {\n              return _this.renderBlock(j, start, end);\n            });\n            _results.push(f.run());\n          } else {\n            _results.push(setTimeout((function(j, start, end) {\n              return function() {\n                return _this.renderBlock(j, start, end);\n              };\n            })(j, start, end), 0));\n          }\n        }\n        return _results;\n      } else {\n        return this.renderKernel();\n      }\n    };\n\n    RenderJob.prototype.executePlugin = function() {\n      Log.debug(\"Executing plugin \" + this.job.plugin);\n      Plugin.execute(this.c, this.job.plugin, this.job.args);\n      Log.debug(\"Plugin \" + this.job.plugin + \" finished!\");\n      return this.renderDone();\n    };\n\n    RenderJob.prototype.renderBlock = function(bnum, start, end) {\n      var data, i, pixelInfo, res, _i;\n      Log.debug(\"BLOCK #\" + bnum + \" - Filter: \" + this.job.name + \", Start: \" + start + \", End: \" + end);\n      Event.trigger(this.c, \"blockStarted\", {\n        blockNum: bnum,\n        totalBlocks: RenderJob.Blocks,\n        startPixel: start,\n        endPixel: end\n      });\n      data = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n      };\n      pixelInfo = new PixelInfo(this.c);\n      for (i = _i = start; _i < end; i = _i += 4) {\n        pixelInfo.loc = i;\n        data.r = this.c.pixelData[i];\n        data.g = this.c.pixelData[i + 1];\n        data.b = this.c.pixelData[i + 2];\n        data.a = this.c.pixelData[i + 3];\n        res = this.job.processFn.call(pixelInfo, data);\n        if (!(res.a != null)) {\n          res.a = data.a;\n        }\n        this.c.pixelData[i] = Util.clampRGB(res.r);\n        this.c.pixelData[i + 1] = Util.clampRGB(res.g);\n        this.c.pixelData[i + 2] = Util.clampRGB(res.b);\n        this.c.pixelData[i + 3] = Util.clampRGB(res.a);\n      }\n      this.blockFinished(bnum);\n      if (Caman.NodeJS) {\n        return Fiber[\"yield\"]();\n      }\n    };\n\n    RenderJob.prototype.renderKernel = function() {\n      var adjust, adjustSize, bias, builder, builderIndex, divisor, end, i, j, k, kernel, modPixelData, n, name, pixel, pixelInfo, res, start, _i, _j, _k, _l;\n      name = this.job.name;\n      bias = this.job.bias;\n      divisor = this.job.divisor;\n      n = this.c.pixelData.length;\n      adjust = this.job.adjust;\n      adjustSize = Math.sqrt(adjust.length);\n      kernel = [];\n      modPixelData = [];\n      Log.debug(\"Rendering kernel - Filter: \" + this.job.name);\n      start = this.c.dimensions.width * 4 * ((adjustSize - 1) / 2);\n      end = n - (this.c.dimensions.width * 4 * ((adjustSize - 1) / 2));\n      builder = (adjustSize - 1) / 2;\n      pixelInfo = new PixelInfo(this.c);\n      for (i = _i = start; _i < end; i = _i += 4) {\n        pixelInfo.loc = i;\n        builderIndex = 0;\n        for (j = _j = -builder; -builder <= builder ? _j <= builder : _j >= builder; j = -builder <= builder ? ++_j : --_j) {\n          for (k = _k = builder; builder <= -builder ? _k <= -builder : _k >= -builder; k = builder <= -builder ? ++_k : --_k) {\n            pixel = pixelInfo.getPixelRelative(j, k);\n            kernel[builderIndex * 3] = pixel.r;\n            kernel[builderIndex * 3 + 1] = pixel.g;\n            kernel[builderIndex * 3 + 2] = pixel.b;\n            builderIndex++;\n          }\n        }\n        res = this.processKernel(adjust, kernel, divisor, bias);\n        modPixelData[i] = Util.clampRGB(res.r);\n        modPixelData[i + 1] = Util.clampRGB(res.g);\n        modPixelData[i + 2] = Util.clampRGB(res.b);\n        modPixelData[i + 3] = this.c.pixelData[i + 3];\n      }\n      for (i = _l = start; start <= end ? _l < end : _l > end; i = start <= end ? ++_l : --_l) {\n        this.c.pixelData[i] = modPixelData[i];\n      }\n      return this.blockFinished(-1);\n    };\n\n    RenderJob.prototype.blockFinished = function(bnum) {\n      if (bnum >= 0) {\n        Log.debug(\"Block #\" + bnum + \" finished! Filter: \" + this.job.name);\n      }\n      this.blocksDone++;\n      Event.trigger(this.c, \"blockFinished\", {\n        blockNum: bnum,\n        blocksFinished: this.blocksDone,\n        totalBlocks: RenderJob.Blocks\n      });\n      if (this.blocksDone === RenderJob.Blocks || bnum === -1) {\n        if (bnum >= 0) {\n          Log.debug(\"Filter \" + this.job.name + \" finished!\");\n        }\n        if (bnum < 0) {\n          Log.debug(\"Kernel filter \" + this.job.name + \" finished!\");\n        }\n        Event.trigger(this.c, \"processComplete\", this.job);\n        return this.renderDone();\n      }\n    };\n\n    RenderJob.prototype.processKernel = function(adjust, kernel, divisor, bias) {\n      var i, val, _i, _ref;\n      val = {\n        r: 0,\n        g: 0,\n        b: 0\n      };\n      for (i = _i = 0, _ref = adjust.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        val.r += adjust[i] * kernel[i * 3];\n        val.g += adjust[i] * kernel[i * 3 + 1];\n        val.b += adjust[i] * kernel[i * 3 + 2];\n      }\n      val.r = (val.r / divisor) + bias;\n      val.g = (val.g / divisor) + bias;\n      val.b = (val.b / divisor) + bias;\n      return val;\n    };\n\n    RenderJob.prototype.loadOverlay = function(layer, src) {\n      var img, proxyUrl,\n        _this = this;\n      img = document.createElement('img');\n      img.onload = function() {\n        layer.context.drawImage(img, 0, 0, _this.c.dimensions.width, _this.c.dimensions.height);\n        layer.imageData = layer.context.getImageData(0, 0, _this.c.dimensions.width, _this.c.dimensions.height);\n        layer.pixelData = layer.imageData.data;\n        _this.c.pixelData = layer.pixelData;\n        return _this.c.processNext();\n      };\n      proxyUrl = IO.remoteCheck(src);\n      return img.src = proxyUrl != null ? proxyUrl : src;\n    };\n\n    return RenderJob;\n\n  })();\n\n  Store = (function() {\n\n    function Store() {}\n\n    Store.items = {};\n\n    Store.has = function(search) {\n      return this.items[search] != null;\n    };\n\n    Store.get = function(search) {\n      return this.items[search];\n    };\n\n    Store.put = function(name, obj) {\n      return this.items[name] = obj;\n    };\n\n    Store.execute = function(search, callback) {\n      return callback.call(this.get(search), this.get(search));\n    };\n\n    Store.flush = function(name) {\n      if (name == null) {\n        name = false;\n      }\n      if (name) {\n        return delete this.items[name];\n      } else {\n        return this.items = {};\n      }\n    };\n\n    return Store;\n\n  })();\n\n  Caman.Store = Store;\n\n  Blender.register(\"normal\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: rgbaLayer.r,\n      g: rgbaLayer.g,\n      b: rgbaLayer.b\n    };\n  });\n\n  Blender.register(\"multiply\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: (rgbaLayer.r * rgbaParent.r) / 255,\n      g: (rgbaLayer.g * rgbaParent.g) / 255,\n      b: (rgbaLayer.b * rgbaParent.b) / 255\n    };\n  });\n\n  Blender.register(\"screen\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: 255 - (((255 - rgbaLayer.r) * (255 - rgbaParent.r)) / 255),\n      g: 255 - (((255 - rgbaLayer.g) * (255 - rgbaParent.g)) / 255),\n      b: 255 - (((255 - rgbaLayer.b) * (255 - rgbaParent.b)) / 255)\n    };\n  });\n\n  Blender.register(\"overlay\", function(rgbaLayer, rgbaParent) {\n    var result;\n    result = {};\n    result.r = rgbaParent.r > 128 ? 255 - 2 * (255 - rgbaLayer.r) * (255 - rgbaParent.r) / 255 : (rgbaParent.r * rgbaLayer.r * 2) / 255;\n    result.g = rgbaParent.g > 128 ? 255 - 2 * (255 - rgbaLayer.g) * (255 - rgbaParent.g) / 255 : (rgbaParent.g * rgbaLayer.g * 2) / 255;\n    result.b = rgbaParent.b > 128 ? 255 - 2 * (255 - rgbaLayer.b) * (255 - rgbaParent.b) / 255 : (rgbaParent.b * rgbaLayer.b * 2) / 255;\n    return result;\n  });\n\n  Blender.register(\"difference\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: rgbaLayer.r - rgbaParent.r,\n      g: rgbaLayer.g - rgbaParent.g,\n      b: rgbaLayer.b - rgbaParent.b\n    };\n  });\n\n  Blender.register(\"addition\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: rgbaParent.r + rgbaLayer.r,\n      g: rgbaParent.g + rgbaLayer.g,\n      b: rgbaParent.b + rgbaLayer.b\n    };\n  });\n\n  Blender.register(\"exclusion\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: 128 - 2 * (rgbaParent.r - 128) * (rgbaLayer.r - 128) / 255,\n      g: 128 - 2 * (rgbaParent.g - 128) * (rgbaLayer.g - 128) / 255,\n      b: 128 - 2 * (rgbaParent.b - 128) * (rgbaLayer.b - 128) / 255\n    };\n  });\n\n  Blender.register(\"softLight\", function(rgbaLayer, rgbaParent) {\n    var result;\n    result = {};\n    result.r = rgbaParent.r > 128 ? 255 - ((255 - rgbaParent.r) * (255 - (rgbaLayer.r - 128))) / 255 : (rgbaParent.r * (rgbaLayer.r + 128)) / 255;\n    result.g = rgbaParent.g > 128 ? 255 - ((255 - rgbaParent.g) * (255 - (rgbaLayer.g - 128))) / 255 : (rgbaParent.g * (rgbaLayer.g + 128)) / 255;\n    result.b = rgbaParent.b > 128 ? 255 - ((255 - rgbaParent.b) * (255 - (rgbaLayer.b - 128))) / 255 : (rgbaParent.b * (rgbaLayer.b + 128)) / 255;\n    return result;\n  });\n\n  Blender.register(\"lighten\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: rgbaParent.r > rgbaLayer.r ? rgbaParent.r : rgbaLayer.r,\n      g: rgbaParent.g > rgbaLayer.g ? rgbaParent.g : rgbaLayer.g,\n      b: rgbaParent.b > rgbaLayer.b ? rgbaParent.b : rgbaLayer.b\n    };\n  });\n\n  Blender.register(\"darken\", function(rgbaLayer, rgbaParent) {\n    return {\n      r: rgbaParent.r > rgbaLayer.r ? rgbaLayer.r : rgbaParent.r,\n      g: rgbaParent.g > rgbaLayer.g ? rgbaLayer.g : rgbaParent.g,\n      b: rgbaParent.b > rgbaLayer.b ? rgbaLayer.b : rgbaParent.b\n    };\n  });\n\n  Filter.register(\"fillColor\", function() {\n    var color;\n    if (arguments.length === 1) {\n      color = Convert.hexToRGB(arguments[0]);\n    } else {\n      color = {\n        r: arguments[0],\n        g: arguments[1],\n        b: arguments[2]\n      };\n    }\n    return this.process(\"fillColor\", function(rgba) {\n      rgba.r = color.r;\n      rgba.g = color.g;\n      rgba.b = color.b;\n      rgba.a = 255;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"brightness\", function(adjust) {\n    adjust = Math.floor(255 * (adjust / 100));\n    return this.process(\"brightness\", function(rgba) {\n      rgba.r += adjust;\n      rgba.g += adjust;\n      rgba.b += adjust;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"saturation\", function(adjust) {\n    adjust *= -0.01;\n    return this.process(\"saturation\", function(rgba) {\n      var max;\n      max = Math.max(rgba.r, rgba.g, rgba.b);\n      if (rgba.r !== max) {\n        rgba.r += (max - rgba.r) * adjust;\n      }\n      if (rgba.g !== max) {\n        rgba.g += (max - rgba.g) * adjust;\n      }\n      if (rgba.b !== max) {\n        rgba.b += (max - rgba.b) * adjust;\n      }\n      return rgba;\n    });\n  });\n\n  Filter.register(\"vibrance\", function(adjust) {\n    adjust *= -1;\n    return this.process(\"vibrance\", function(rgba) {\n      var amt, avg, max;\n      max = Math.max(rgba.r, rgba.g, rgba.b);\n      avg = (rgba.r + rgba.g + rgba.b) / 3;\n      amt = ((Math.abs(max - avg) * 2 / 255) * adjust) / 100;\n      if (rgba.r !== max) {\n        rgba.r += (max - rgba.r) * amt;\n      }\n      if (rgba.g !== max) {\n        rgba.g += (max - rgba.g) * amt;\n      }\n      if (rgba.b !== max) {\n        rgba.b += (max - rgba.b) * amt;\n      }\n      return rgba;\n    });\n  });\n\n  Filter.register(\"greyscale\", function(adjust) {\n    return this.process(\"greyscale\", function(rgba) {\n      var avg;\n      avg = 0.3 * rgba.r + 0.59 * rgba.g + 0.11 * rgba.b;\n      rgba.r = avg;\n      rgba.g = avg;\n      rgba.b = avg;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"contrast\", function(adjust) {\n    adjust = Math.pow((adjust + 100) / 100, 2);\n    return this.process(\"contrast\", function(rgba) {\n      rgba.r /= 255;\n      rgba.r -= 0.5;\n      rgba.r *= adjust;\n      rgba.r += 0.5;\n      rgba.r *= 255;\n      rgba.g /= 255;\n      rgba.g -= 0.5;\n      rgba.g *= adjust;\n      rgba.g += 0.5;\n      rgba.g *= 255;\n      rgba.b /= 255;\n      rgba.b -= 0.5;\n      rgba.b *= adjust;\n      rgba.b += 0.5;\n      rgba.b *= 255;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"hue\", function(adjust) {\n    return this.process(\"hue\", function(rgba) {\n      var h, hsv, rgb;\n      hsv = Convert.rgbToHSV(rgba.r, rgba.g, rgba.b);\n      h = hsv.h * 100;\n      h += Math.abs(adjust);\n      h = h % 100;\n      h /= 100;\n      hsv.h = h;\n      rgb = Convert.hsvToRGB(hsv.h, hsv.s, hsv.v);\n      rgb.a = rgba.a;\n      return rgb;\n    });\n  });\n\n  Filter.register(\"colorize\", function() {\n    var level, rgb;\n    if (arguments.length === 2) {\n      rgb = Convert.hexToRGB(arguments[0]);\n      level = arguments[1];\n    } else if (arguments.length === 4) {\n      rgb = {\n        r: arguments[0],\n        g: arguments[1],\n        b: arguments[2]\n      };\n      level = arguments[3];\n    }\n    return this.process(\"colorize\", function(rgba) {\n      rgba.r -= (rgba.r - rgb.r) * (level / 100);\n      rgba.g -= (rgba.g - rgb.g) * (level / 100);\n      rgba.b -= (rgba.b - rgb.b) * (level / 100);\n      return rgba;\n    });\n  });\n\n  Filter.register(\"invert\", function() {\n    return this.process(\"invert\", function(rgba) {\n      rgba.r = 255 - rgba.r;\n      rgba.g = 255 - rgba.g;\n      rgba.b = 255 - rgba.b;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"sepia\", function(adjust) {\n    if (adjust == null) {\n      adjust = 100;\n    }\n    adjust /= 100;\n    return this.process(\"sepia\", function(rgba) {\n      rgba.r = Math.min(255, (rgba.r * (1 - (0.607 * adjust))) + (rgba.g * (0.769 * adjust)) + (rgba.b * (0.189 * adjust)));\n      rgba.g = Math.min(255, (rgba.r * (0.349 * adjust)) + (rgba.g * (1 - (0.314 * adjust))) + (rgba.b * (0.168 * adjust)));\n      rgba.b = Math.min(255, (rgba.r * (0.272 * adjust)) + (rgba.g * (0.534 * adjust)) + (rgba.b * (1 - (0.869 * adjust))));\n      return rgba;\n    });\n  });\n\n  Filter.register(\"gamma\", function(adjust) {\n    return this.process(\"gamma\", function(rgba) {\n      rgba.r = Math.pow(rgba.r / 255, adjust) * 255;\n      rgba.g = Math.pow(rgba.g / 255, adjust) * 255;\n      rgba.b = Math.pow(rgba.b / 255, adjust) * 255;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"noise\", function(adjust) {\n    adjust = Math.abs(adjust) * 2.55;\n    return this.process(\"noise\", function(rgba) {\n      var rand;\n      rand = Calculate.randomRange(adjust * -1, adjust);\n      rgba.r += rand;\n      rgba.g += rand;\n      rgba.b += rand;\n      return rgba;\n    });\n  });\n\n  Filter.register(\"clip\", function(adjust) {\n    adjust = Math.abs(adjust) * 2.55;\n    return this.process(\"clip\", function(rgba) {\n      if (rgba.r > 255 - adjust) {\n        rgba.r = 255;\n      } else if (rgba.r < adjust) {\n        rgba.r = 0;\n      }\n      if (rgba.g > 255 - adjust) {\n        rgba.g = 255;\n      } else if (rgba.g < adjust) {\n        rgba.g = 0;\n      }\n      if (rgba.b > 255 - adjust) {\n        rgba.b = 255;\n      } else if (rgba.b < adjust) {\n        rgba.b = 0;\n      }\n      return rgba;\n    });\n  });\n\n  Filter.register(\"channels\", function(options) {\n    var chan, value;\n    if (typeof options !== \"object\") {\n      return this;\n    }\n    for (chan in options) {\n      if (!__hasProp.call(options, chan)) continue;\n      value = options[chan];\n      if (value === 0) {\n        delete options[chan];\n        continue;\n      }\n      options[chan] /= 100;\n    }\n    if (options.length === 0) {\n      return this;\n    }\n    return this.process(\"channels\", function(rgba) {\n      if (options.red != null) {\n        if (options.red > 0) {\n          rgba.r += (255 - rgba.r) * options.red;\n        } else {\n          rgba.r -= rgba.r * Math.abs(options.red);\n        }\n      }\n      if (options.green != null) {\n        if (options.green > 0) {\n          rgba.g += (255 - rgba.g) * options.green;\n        } else {\n          rgba.g -= rgba.g * Math.abs(options.green);\n        }\n      }\n      if (options.blue != null) {\n        if (options.blue > 0) {\n          rgba.b += (255 - rgba.b) * options.blue;\n        } else {\n          rgba.b -= rgba.b * Math.abs(options.blue);\n        }\n      }\n      return rgba;\n    });\n  });\n\n  Filter.register(\"curves\", function() {\n    var bezier, chans, cps, ctrl1, ctrl2, end, i, start, _i, _j, _ref, _ref1;\n    chans = arguments[0], cps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (typeof chans === \"string\") {\n      chans = chans.split(\"\");\n    }\n    if (chans[0] === \"v\") {\n      chans = ['r', 'g', 'b'];\n    }\n    if (cps.length < 3 || cps.length > 4) {\n      throw \"Invalid number of arguments to curves filter\";\n    }\n    start = cps[0];\n    ctrl1 = cps[1];\n    ctrl2 = cps.length === 4 ? cps[2] : cps[1];\n    end = cps[cps.length - 1];\n    bezier = Calculate.bezier(start, ctrl1, ctrl2, end, 0, 255);\n    if (start[0] > 0) {\n      for (i = _i = 0, _ref = start[0]; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        bezier[i] = start[1];\n      }\n    }\n    if (end[0] < 255) {\n      for (i = _j = _ref1 = end[0]; _ref1 <= 255 ? _j <= 255 : _j >= 255; i = _ref1 <= 255 ? ++_j : --_j) {\n        bezier[i] = end[1];\n      }\n    }\n    return this.process(\"curves\", function(rgba) {\n      var _k, _ref2;\n      for (i = _k = 0, _ref2 = chans.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {\n        rgba[chans[i]] = bezier[rgba[chans[i]]];\n      }\n      return rgba;\n    });\n  });\n\n  Filter.register(\"exposure\", function(adjust) {\n    var ctrl1, ctrl2, p;\n    p = Math.abs(adjust) / 100;\n    ctrl1 = [0, 255 * p];\n    ctrl2 = [255 - (255 * p), 255];\n    if (adjust < 0) {\n      ctrl1 = ctrl1.reverse();\n      ctrl2 = ctrl2.reverse();\n    }\n    return this.curves('rgb', [0, 0], ctrl1, ctrl2, [255, 255]);\n  });\n\n  Caman.Filter.register(\"boxBlur\", function() {\n    return this.processKernel(\"Box Blur\", [1, 1, 1, 1, 1, 1, 1, 1, 1]);\n  });\n\n  Caman.Filter.register(\"radialBlur\", function() {\n    return this.processKernel(\"Radial Blur\", [0, 1, 0, 1, 1, 1, 0, 1, 0]);\n  });\n\n  Caman.Filter.register(\"heavyRadialBlur\", function() {\n    return this.processKernel(\"Heavy Radial Blur\", [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0]);\n  });\n\n  Caman.Filter.register(\"gaussianBlur\", function() {\n    return this.processKernel(\"Gaussian Blur\", [1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1]);\n  });\n\n  Caman.Filter.register(\"motionBlur\", function() {\n    var kernel;\n    if (degrees === 0 || degrees === 180) {\n      kernel = [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0];\n    } else if ((degrees > 0 && degrees < 90) || (degrees > 180 && degrees < 270)) {\n      kernel = [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0];\n    } else if (degrees === 90 || degrees === 270) {\n      kernel = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    } else {\n      kernel = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n    }\n    return this.processKernel(\"Motion Blur\", kernel);\n  });\n\n  Caman.Filter.register(\"sharpen\", function(amt) {\n    if (amt == null) {\n      amt = 100;\n    }\n    amt /= 100;\n    return this.processKernel(\"Sharpen\", [0, -amt, 0, -amt, 4 * amt + 1, -amt, 0, -amt, 0]);\n  });\n\n  vignetteFilters = {\n    brightness: function(rgba, amt, opts) {\n      rgba.r = rgba.r - (rgba.r * amt * opts.strength);\n      rgba.g = rgba.g - (rgba.g * amt * opts.strength);\n      rgba.b = rgba.b - (rgba.b * amt * opts.strength);\n      return rgba;\n    },\n    gamma: function(rgba, amt, opts) {\n      rgba.r = Math.pow(rgba.r / 255, Math.max(10 * amt * opts.strength, 1)) * 255;\n      rgba.g = Math.pow(rgba.g / 255, Math.max(10 * amt * opts.strength, 1)) * 255;\n      rgba.b = Math.pow(rgba.b / 255, Math.max(10 * amt * opts.strength, 1)) * 255;\n      return rgba;\n    },\n    colorize: function(rgba, amt, opts) {\n      rgba.r -= (rgba.r - opts.color.r) * amt;\n      rgba.g -= (rgba.g - opts.color.g) * amt;\n      rgba.b -= (rgba.b - opts.color.b) * amt;\n      return rgba;\n    }\n  };\n\n  Filter.register(\"vignette\", function(size, strength) {\n    var bezier, center, end, start;\n    if (strength == null) {\n      strength = 60;\n    }\n    if (typeof size === \"string\" && size.substr(-1) === \"%\") {\n      if (this.dimensions.height > this.dimensions.width) {\n        size = this.dimensions.width * (parseInt(size.substr(0, size.length - 1), 10) / 100);\n      } else {\n        size = this.dimensions.height * (parseInt(size.substr(0, size.length - 1), 10) / 100);\n      }\n    }\n    strength /= 100;\n    center = [this.dimensions.width / 2, this.dimensions.height / 2];\n    start = Math.sqrt(Math.pow(center[0], 2) + Math.pow(center[1], 2));\n    end = start - size;\n    bezier = Calculate.bezier([0, 1], [30, 30], [70, 60], [100, 80]);\n    return this.process(\"vignette\", function(rgba) {\n      var dist, div, loc;\n      loc = this.locationXY();\n      dist = Calculate.distance(loc.x, loc.y, center[0], center[1]);\n      if (dist > end) {\n        div = Math.max(1, (bezier[Math.round(((dist - end) / size) * 100)] / 10) * strength);\n        rgba.r = Math.pow(rgba.r / 255, div) * 255;\n        rgba.g = Math.pow(rgba.g / 255, div) * 255;\n        rgba.b = Math.pow(rgba.b / 255, div) * 255;\n      }\n      return rgba;\n    });\n  });\n\n  Filter.register(\"rectangularVignette\", function(opts) {\n    var defaults, dim, percent, size, _i, _len, _ref;\n    defaults = {\n      strength: 50,\n      cornerRadius: 0,\n      method: 'brightness',\n      color: {\n        r: 0,\n        g: 0,\n        b: 0\n      }\n    };\n    opts = Util.extend(defaults, opts);\n    if (!opts.size) {\n      return this;\n    } else if (typeof opts.size === \"string\") {\n      percent = parseInt(opts.size, 10) / 100;\n      opts.size = {\n        width: this.dimensions.width * percent,\n        height: this.dimensions.height * percent\n      };\n    } else if (typeof opts.size === \"object\") {\n      _ref = [\"width\", \"height\"];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        dim = _ref[_i];\n        if (typeof opts.size[dim] === \"string\") {\n          opts.size[dim] = this.dimensions[dim] * (parseInt(opts.size[dim], 10) / 100);\n        }\n      }\n    } else if (opts.size === \"number\") {\n      size = opts.size;\n      opts.size = {\n        width: size,\n        height: size\n      };\n    }\n    if (typeof opts.cornerRadius === \"string\") {\n      opts.cornerRadius = (opts.size.width / 2) * (parseInt(opts.cornerRadius, 10) / 100);\n    }\n    opts.strength /= 100;\n    opts.size.width = Math.floor(opts.size.width);\n    opts.size.height = Math.floor(opts.size.height);\n    opts.image = {\n      width: this.dimensions.width,\n      height: this.dimensions.height\n    };\n    if (opts.method === \"colorize\" && typeof opts.color === \"string\") {\n      opts.color = Convert.hexToRGB(opts.color);\n    }\n    opts.coords = {\n      left: (this.dimensions.width - opts.size.width) / 2,\n      right: this.dimensions.width - opts.coords.left,\n      bottom: (this.dimensions.height - opts.size.height) / 2,\n      top: this.dimensions.height - opts.coords.bottom\n    };\n    opts.corners = [\n      {\n        x: opts.coords.left + opts.cornerRadius,\n        y: opts.coords.top - opts.cornerRadius\n      }, {\n        x: opts.coords.right - opts.cornerRadius,\n        y: opts.coords.top - opts.cornerRadius\n      }, {\n        x: opts.coords.right - opts.cornerRadius,\n        y: opts.coords.bottom + opts.cornerRadius\n      }, {\n        x: opts.coords.left + opts.cornerRadius,\n        y: opts.coords.bottom + opts.cornerRadius\n      }\n    ];\n    opts.maxDist = Calculate.distance(0, 0, opts.corners[3].x, opts.corners[3].y) - opts.cornerRadius;\n    return this.process(\"rectangularVignette\", function(rgba) {\n      var amt, loc, radialDist;\n      loc = this.locationXY();\n      if ((loc.x > opts.corners[0].x && loc.x < opts.corners[1].x) && (loc.y > opts.coords.bottom && loc.y < opts.coords.top)) {\n        return rgba;\n      }\n      if ((loc.x > opts.coords.left && loc.x < opts.coords.right) && (loc.y > opts.corners[3].y && loc.y < opts.corners[2].y)) {\n        return rgba;\n      }\n      if (loc.x > opts.corners[0].x && loc.x < opts.corners[1].x && loc.y > opts.coords.top) {\n        amt = (loc.y - opts.coords.top) / opts.maxDist;\n      } else if (loc.y > opts.corners[2].y && loc.y < opts.corners[1].y && loc.x > opts.coords.right) {\n        amt = (loc.x - opts.coords.right) / opts.maxDist;\n      } else if (loc.x > opts.corners[0].x && loc.x < opts.corners[1].x && loc.y < opts.coords.bottom) {\n        amt = (opts.coords.bottom - loc.y) / opts.maxDist;\n      } else if (loc.y > opts.corners[2].y && loc.y < opts.corners[1].y && loc.x < opts.coords.left) {\n        amt = (opts.coords.left - loc.x) / opts.maxDist;\n      } else if (loc.x <= opts.corners[0].x && loc.y >= opts.corners[0].y) {\n        radialDist = Caman.distance(loc.x, loc.y, opts.corners[0].x, opts.corners[0].y);\n        amt = (radialDist - opts.cornerRadius) / opts.maxDist;\n      } else if (loc.x >= opts.corners[1].x && loc.y >= opts.corners[1].y) {\n        radialDist = Caman.distance(loc.x, loc.y, opts.corners[1].x, opts.corners[1].y);\n        amt = (radialDist - opts.cornerRadius) / opts.maxDist;\n      } else if (loc.x >= opts.corners[2].x && loc.y <= opts.corners[2].y) {\n        radialDist = Caman.distance(loc.x, loc.y, opts.corners[2].x, opts.corners[2].y);\n        amt = (radialDist - opts.cornerRadius) / opts.maxDist;\n      } else if (loc.x <= opts.corners[3].x && loc.y <= opts.corners[3].y) {\n        radialDist = Caman.distance(loc.x, loc.y, opts.corners[3].x, opts.corners[3].y);\n        amt = (radialDist - opts.cornerRadius) / opts.maxDist;\n      }\n      if (amt < 0) {\n        return rgba;\n      }\n      return vignetteFilters[opts.method](rgba, amt, opts);\n    });\n  });\n\n  /*\n  CompoundBlur - Blurring with varying radii for Canvas\n  \n  Version:   0.1\n  Author:  Mario Klingemann\n  Contact:   mario@quasimondo.com\n  Website:  http://www.quasimondo.com/StackBlurForCanvas\n  Twitter:  @quasimondo\n  Modified By: Ryan LeFevre (@meltingice)\n  \n  In case you find this class useful - especially in commercial projects -\n  I am not totally unhappy for a small donation to my PayPal account\n  mario@quasimondo.de\n  \n  Copyright (c) 2011 Mario Klingemann\n  \n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation\n  files (the \"Software\"), to deal in the Software without\n  restriction, including without limitation the rights to use,\n  copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the\n  Software is furnished to do so, subject to the following\n  conditions:\n  \n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  OTHER DEALINGS IN THE SOFTWARE.\n  */\n\n\n  (function() {\n    var BlurStack, getLinearGradientMap, getRadialGradientMap, mul_table, shg_table;\n    mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];\n    shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\n    getLinearGradientMap = function(width, height, centerX, centerY, angle, length, mirrored) {\n      var cnv, context, gradient, x1, x2, y1, y2;\n      cnv = typeof exports !== \"undefined\" && exports !== null ? new Canvas() : document.createElement('canvas');\n      cnv.width = width;\n      cnv.height = height;\n      x1 = centerX + Math.cos(angle) * length * 0.5;\n      y1 = centerY + Math.sin(angle) * length * 0.5;\n      x2 = centerX - Math.cos(angle) * length * 0.5;\n      y2 = centerY - Math.sin(angle) * length * 0.5;\n      context = cnv.getContext(\"2d\");\n      gradient = context.createLinearGradient(x1, y1, x2, y2);\n      if (!mirrored) {\n        gradient.addColorStop(0, \"white\");\n        gradient.addColorStop(1, \"black\");\n      } else {\n        gradient.addColorStop(0, \"white\");\n        gradient.addColorStop(0.5, \"black\");\n        gradient.addColorStop(1, \"white\");\n      }\n      context.fillStyle = gradient;\n      context.fillRect(0, 0, width, height);\n      return context.getImageData(0, 0, width, height);\n    };\n    getRadialGradientMap = function(width, height, centerX, centerY, radius1, radius2) {\n      var cnv, context, gradient;\n      cnv = typeof exports !== \"undefined\" && exports !== null ? new Canvas() : document.createElement('canvas');\n      cnv.width = width;\n      cnv.height = height;\n      context = cnv.getContext(\"2d\");\n      gradient = context.createRadialGradient(centerX, centerY, radius1, centerX, centerY, radius2);\n      gradient.addColorStop(1, \"white\");\n      gradient.addColorStop(0, \"black\");\n      context.fillStyle = gradient;\n      context.fillRect(0, 0, width, height);\n      return context.getImageData(0, 0, width, height);\n    };\n    BlurStack = function() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n      return this.next = null;\n    };\n    Caman.Plugin.register(\"compoundBlur\", function(radiusData, radius, increaseFactor, blurLevels) {\n      var b_in_sum, b_out_sum, b_sum, blend, currentIndex, div, g_in_sum, g_out_sum, g_sum, height, heightMinus1, i, iblend, idx, imagePixels, index, iradius, lookupValue, mul_sum, p, pb, pg, pixels, pr, r_in_sum, r_out_sum, r_sum, radiusPixels, radiusPlus1, rbs, shg_sum, stack, stackEnd, stackIn, stackOut, stackStart, steps, sumFactor, w4, wh, wh4, width, widthMinus1, x, y, yi, yp, yw, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n      width = this.dimensions.width;\n      height = this.dimensions.height;\n      imagePixels = this.pixelData;\n      radiusPixels = radiusData.data;\n      wh = width * height;\n      wh4 = wh << 2;\n      pixels = [];\n      for (i = _i = 0; 0 <= wh4 ? _i < wh4 : _i > wh4; i = 0 <= wh4 ? ++_i : --_i) {\n        pixels[i] = imagePixels[i];\n      }\n      currentIndex = 0;\n      steps = blurLevels;\n      blurLevels -= 1;\n      while (steps-- >= 0) {\n        iradius = (radius + 0.5) | 0;\n        if (iradius === 0) {\n          continue;\n        }\n        if (iradius > 256) {\n          iradius = 256;\n        }\n        div = iradius + iradius + 1;\n        w4 = width << 2;\n        widthMinus1 = width - 1;\n        heightMinus1 = height - 1;\n        radiusPlus1 = iradius + 1;\n        sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n        stackStart = new BlurStack();\n        stackEnd = void 0;\n        stack = stackStart;\n        for (i = _j = 1; 1 <= div ? _j < div : _j > div; i = 1 <= div ? ++_j : --_j) {\n          stack = stack.next = new BlurStack();\n          if (i === radiusPlus1) {\n            stackEnd = stack;\n          }\n        }\n        stack.next = stackStart;\n        stackIn = null;\n        stackOut = null;\n        yw = yi = 0;\n        mul_sum = mul_table[iradius];\n        shg_sum = shg_table[iradius];\n        for (y = _k = 0; 0 <= height ? _k < height : _k > height; y = 0 <= height ? ++_k : --_k) {\n          r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;\n          r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n          g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n          b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n          r_sum += sumFactor * pr;\n          g_sum += sumFactor * pg;\n          b_sum += sumFactor * pb;\n          stack = stackStart;\n          for (i = _l = 0; 0 <= radiusPlus1 ? _l < radiusPlus1 : _l > radiusPlus1; i = 0 <= radiusPlus1 ? ++_l : --_l) {\n            stack.r = pr;\n            stack.g = pg;\n            stack.b = pb;\n            stack = stack.next;\n          }\n          for (i = _m = 1; 1 <= radiusPlus1 ? _m < radiusPlus1 : _m > radiusPlus1; i = 1 <= radiusPlus1 ? ++_m : --_m) {\n            p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);\n            r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);\n            g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;\n            b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;\n            r_in_sum += pr;\n            g_in_sum += pg;\n            b_in_sum += pb;\n            stack = stack.next;\n          }\n          stackIn = stackStart;\n          stackOut = stackEnd;\n          for (x = _n = 0; 0 <= width ? _n < width : _n > width; x = 0 <= width ? ++_n : --_n) {\n            pixels[yi] = (r_sum * mul_sum) >> shg_sum;\n            pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;\n            pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;\n            r_sum -= r_out_sum;\n            g_sum -= g_out_sum;\n            b_sum -= b_out_sum;\n            r_out_sum -= stackIn.r;\n            g_out_sum -= stackIn.g;\n            b_out_sum -= stackIn.b;\n            p = (yw + ((p = x + radiusPlus1) < widthMinus1 ? p : widthMinus1)) << 2;\n            r_in_sum += (stackIn.r = pixels[p]);\n            g_in_sum += (stackIn.g = pixels[p + 1]);\n            b_in_sum += (stackIn.b = pixels[p + 2]);\n            r_sum += r_in_sum;\n            g_sum += g_in_sum;\n            b_sum += b_in_sum;\n            stackIn = stackIn.next;\n            r_out_sum += (pr = stackOut.r);\n            g_out_sum += (pg = stackOut.g);\n            b_out_sum += (pb = stackOut.b);\n            r_in_sum -= pr;\n            g_in_sum -= pg;\n            b_in_sum -= pb;\n            stackOut = stackOut.next;\n            yi += 4;\n          }\n          yw += width;\n        }\n        for (x = _o = 0; 0 <= width ? _o < width : _o > width; x = 0 <= width ? ++_o : --_o) {\n          g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;\n          yi = x << 2;\n          r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n          g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n          b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n          r_sum += sumFactor * pr;\n          g_sum += sumFactor * pg;\n          b_sum += sumFactor * pb;\n          stack = stackStart;\n          for (i = _p = 0; 0 <= radiusPlus1 ? _p < radiusPlus1 : _p > radiusPlus1; i = 0 <= radiusPlus1 ? ++_p : --_p) {\n            stack.r = pr;\n            stack.g = pg;\n            stack.b = pb;\n            stack = stack.next;\n          }\n          yp = width;\n          for (i = _q = 1; 1 <= radiusPlus1 ? _q < radiusPlus1 : _q > radiusPlus1; i = 1 <= radiusPlus1 ? ++_q : --_q) {\n            yi = (yp + x) << 2;\n            r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);\n            g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;\n            b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;\n            r_in_sum += pr;\n            g_in_sum += pg;\n            b_in_sum += pb;\n            stack = stack.next;\n            if (i < heightMinus1) {\n              yp += width;\n            }\n          }\n          yi = x;\n          stackIn = stackStart;\n          stackOut = stackEnd;\n          for (y = _r = 0; 0 <= height ? _r < height : _r > height; y = 0 <= height ? ++_r : --_r) {\n            p = yi << 2;\n            pixels[p] = (r_sum * mul_sum) >> shg_sum;\n            pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;\n            pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;\n            r_sum -= r_out_sum;\n            g_sum -= g_out_sum;\n            b_sum -= b_out_sum;\n            r_out_sum -= stackIn.r;\n            g_out_sum -= stackIn.g;\n            b_out_sum -= stackIn.b;\n            p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;\n            r_sum += (r_in_sum += (stackIn.r = pixels[p]));\n            g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));\n            b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));\n            stackIn = stackIn.next;\n            r_out_sum += (pr = stackOut.r);\n            g_out_sum += (pg = stackOut.g);\n            b_out_sum += (pb = stackOut.b);\n            r_in_sum -= pr;\n            g_in_sum -= pg;\n            b_in_sum -= pb;\n            stackOut = stackOut.next;\n            yi += width;\n          }\n        }\n        radius *= increaseFactor;\n        i = wh;\n        while (--i > -1) {\n          idx = i << 2;\n          lookupValue = (radiusPixels[idx + 2] & 0xff) / 255.0 * blurLevels;\n          index = lookupValue | 0;\n          if (index === currentIndex) {\n            blend = 256.0 * (lookupValue - (lookupValue | 0));\n            iblend = 256 - blend;\n            imagePixels[idx] = (imagePixels[idx] * iblend + pixels[idx] * blend) >> 8;\n            imagePixels[idx + 1] = (imagePixels[idx + 1] * iblend + pixels[idx + 1] * blend) >> 8;\n            imagePixels[idx + 2] = (imagePixels[idx + 2] * iblend + pixels[idx + 2] * blend) >> 8;\n          } else if (index === currentIndex + 1) {\n            imagePixels[idx] = pixels[idx];\n            imagePixels[idx + 1] = pixels[idx + 1];\n            imagePixels[idx + 2] = pixels[idx + 2];\n          }\n        }\n        currentIndex++;\n      }\n      return this;\n    });\n    Caman.Filter.register(\"tiltShift\", function(opts) {\n      var defaults, gradient;\n      defaults = {\n        center: {\n          x: this.dimensions.width / 2,\n          y: this.dimensions.height / 2\n        },\n        angle: 45,\n        focusWidth: 200,\n        startRadius: 3,\n        radiusFactor: 1.5,\n        steps: 3\n      };\n      opts = Caman.Util.extend(defaults, opts);\n      opts.angle *= Math.PI / 180;\n      gradient = getLinearGradientMap(this.dimensions.width, this.dimensions.height, opts.center.x, opts.center.y, opts.angle, opts.focusWidth, true);\n      return this.processPlugin(\"compoundBlur\", [gradient, opts.startRadius, opts.radiusFactor, opts.steps]);\n    });\n    return Caman.Filter.register(\"radialBlur\", function(opts) {\n      var defaults, gradient, radius1, radius2;\n      defaults = {\n        size: 50,\n        center: {\n          x: this.dimensions.width / 2,\n          y: this.dimensions.height / 2\n        },\n        startRadius: 3,\n        radiusFactor: 1.5,\n        steps: 3,\n        radius: null\n      };\n      opts = Caman.Util.extend(defaults, opts);\n      if (!opts.radius) {\n        opts.radius = this.dimensions.width < this.dimensions.height ? this.dimensions.height : this.dimensions.width;\n      }\n      radius1 = (opts.radius / 2) - opts.size;\n      radius2 = opts.radius / 2;\n      gradient = getRadialGradientMap(this.dimensions.width, this.dimensions.height, opts.center.x, opts.center.y, radius1, radius2);\n      return this.processPlugin(\"compoundBlur\", [gradient, opts.startRadius, opts.radiusFactor, opts.steps]);\n    });\n  })();\n\n  Caman.Filter.register(\"edgeEnhance\", function() {\n    return this.processKernel(\"Edge Enhance\", [0, 0, 0, -1, 1, 0, 0, 0, 0]);\n  });\n\n  Caman.Filter.register(\"edgeDetect\", function() {\n    return this.processKernel(\"Edge Detect\", [-1, -1, -1, -1, 8, -1, -1, -1, -1]);\n  });\n\n  Caman.Filter.register(\"emboss\", function() {\n    return this.processKernel(\"Emboss\", [-2, -1, 0, -1, 1, 1, 0, 1, 2]);\n  });\n\n  Caman.Filter.register(\"posterize\", function(adjust) {\n    var numOfAreas, numOfValues;\n    numOfAreas = 256 / adjust;\n    numOfValues = 255 / (adjust - 1);\n    return this.process(\"posterize\", function(rgba) {\n      rgba.r = Math.floor(Math.floor(rgba.r / numOfAreas) * numOfValues);\n      rgba.g = Math.floor(Math.floor(rgba.g / numOfAreas) * numOfValues);\n      rgba.b = Math.floor(Math.floor(rgba.b / numOfAreas) * numOfValues);\n      return rgba;\n    });\n  });\n\n  Caman.Filter.register(\"vintage\", function(vignette) {\n    if (vignette == null) {\n      vignette = true;\n    }\n    this.greyscale();\n    this.contrast(5);\n    this.noise(3);\n    this.sepia(100);\n    this.channels({\n      red: 8,\n      blue: 2,\n      green: 4\n    });\n    this.gamma(0.87);\n    if (vignette) {\n      return this.vignette(\"40%\", 30);\n    }\n  });\n\n  Caman.Filter.register(\"lomo\", function(vignette) {\n    if (vignette == null) {\n      vignette = true;\n    }\n    this.brightness(15);\n    this.exposure(15);\n    this.curves('rgb', [0, 0], [200, 0], [155, 255], [255, 255]);\n    this.saturation(-20);\n    this.gamma(1.8);\n    if (vignette) {\n      this.vignette(\"50%\", 60);\n    }\n    return this.brightness(5);\n  });\n\n  Caman.Filter.register(\"clarity\", function(grey) {\n    if (grey == null) {\n      grey = false;\n    }\n    this.vibrance(20);\n    this.curves('rgb', [5, 0], [130, 150], [190, 220], [250, 255]);\n    this.sharpen(15);\n    this.vignette(\"45%\", 20);\n    if (grey) {\n      this.greyscale();\n      this.contrast(4);\n    }\n    return this;\n  });\n\n  Caman.Filter.register(\"sinCity\", function() {\n    this.contrast(100);\n    this.brightness(15);\n    this.exposure(10);\n    this.posterize(80);\n    this.clip(30);\n    return this.greyscale();\n  });\n\n  Caman.Filter.register(\"sunrise\", function() {\n    this.exposure(3.5);\n    this.saturation(-5);\n    this.vibrance(50);\n    this.sepia(60);\n    this.colorize(\"#e87b22\", 10);\n    this.channels({\n      red: 8,\n      blue: 8\n    });\n    this.contrast(5);\n    this.gamma(1.2);\n    return this.vignette(\"55%\", 25);\n  });\n\n  Caman.Filter.register(\"crossProcess\", function() {\n    this.exposure(5);\n    this.colorize(\"#e87b22\", 4);\n    this.sepia(20);\n    this.channels({\n      blue: 8,\n      red: 3\n    });\n    this.curves('b', [0, 0], [100, 150], [180, 180], [255, 255]);\n    this.contrast(15);\n    this.vibrance(75);\n    return this.gamma(1.6);\n  });\n\n  Caman.Filter.register(\"orangePeel\", function() {\n    this.curves('rgb', [0, 0], [100, 50], [140, 200], [255, 255]);\n    this.vibrance(-30);\n    this.saturation(-30);\n    this.colorize('#ff9000', 30);\n    this.contrast(-5);\n    return this.gamma(1.4);\n  });\n\n  Caman.Filter.register(\"love\", function() {\n    this.brightness(5);\n    this.exposure(8);\n    this.contrast(4);\n    this.colorize('#c42007', 30);\n    this.vibrance(50);\n    return this.gamma(1.3);\n  });\n\n  Caman.Filter.register(\"grungy\", function() {\n    this.gamma(1.5);\n    this.clip(25);\n    this.saturation(-60);\n    this.contrast(5);\n    this.noise(5);\n    return this.vignette(\"50%\", 30);\n  });\n\n  Caman.Filter.register(\"jarques\", function() {\n    this.saturation(-35);\n    this.curves('b', [20, 0], [90, 120], [186, 144], [255, 230]);\n    this.curves('r', [0, 0], [144, 90], [138, 120], [255, 255]);\n    this.curves('g', [10, 0], [115, 105], [148, 100], [255, 248]);\n    this.curves('rgb', [0, 0], [120, 100], [128, 140], [255, 255]);\n    return this.sharpen(20);\n  });\n\n  Caman.Filter.register(\"pinhole\", function() {\n    this.greyscale();\n    this.sepia(10);\n    this.exposure(10);\n    this.contrast(15);\n    return this.vignette(\"60%\", 35);\n  });\n\n  Caman.Filter.register(\"oldBoot\", function() {\n    this.saturation(-20);\n    this.vibrance(-50);\n    this.gamma(1.1);\n    this.sepia(30);\n    this.channels({\n      red: -10,\n      blue: 5\n    });\n    this.curves('rgb', [0, 0], [80, 50], [128, 230], [255, 255]);\n    return this.vignette(\"60%\", 30);\n  });\n\n  Caman.Filter.register(\"glowingSun\", function(vignette) {\n    if (vignette == null) {\n      vignette = true;\n    }\n    this.brightness(10);\n    this.newLayer(function() {\n      this.setBlendingMode(\"multiply\");\n      this.opacity(80);\n      this.copyParent();\n      this.filter.gamma(0.8);\n      this.filter.contrast(50);\n      return this.filter.exposure(10);\n    });\n    this.newLayer(function() {\n      this.setBlendingMode(\"softLight\");\n      this.opacity(80);\n      return this.fillColor(\"#f49600\");\n    });\n    this.exposure(20);\n    this.gamma(0.8);\n    if (vignette) {\n      return this.vignette(\"45%\", 20);\n    }\n  });\n\n  Caman.Filter.register(\"hazyDays\", function() {\n    this.gamma(1.2);\n    this.newLayer(function() {\n      this.setBlendingMode(\"overlay\");\n      this.opacity(60);\n      this.copyParent();\n      this.filter.channels({\n        red: 5\n      });\n      return this.filter.stackBlur(15);\n    });\n    this.newLayer(function() {\n      this.setBlendingMode(\"addition\");\n      this.opacity(40);\n      return this.fillColor(\"#6899ba\");\n    });\n    this.newLayer(function() {\n      this.setBlendingMode(\"multiply\");\n      this.opacity(35);\n      this.copyParent();\n      this.filter.brightness(40);\n      this.filter.vibrance(40);\n      this.filter.exposure(30);\n      this.filter.contrast(15);\n      this.filter.curves('r', [0, 40], [128, 128], [128, 128], [255, 215]);\n      this.filter.curves('g', [0, 40], [128, 128], [128, 128], [255, 215]);\n      this.filter.curves('b', [0, 40], [128, 128], [128, 128], [255, 215]);\n      return this.filter.stackBlur(5);\n    });\n    this.curves('r', [20, 0], [128, 158], [128, 128], [235, 255]);\n    this.curves('g', [20, 0], [128, 128], [128, 128], [235, 255]);\n    this.curves('b', [20, 0], [128, 108], [128, 128], [235, 255]);\n    return this.vignette(\"45%\", 20);\n  });\n\n  Caman.Filter.register(\"herMajesty\", function() {\n    this.brightness(40);\n    this.colorize(\"#ea1c5d\", 10);\n    this.curves('b', [0, 10], [128, 180], [190, 190], [255, 255]);\n    this.newLayer(function() {\n      this.setBlendingMode('overlay');\n      this.opacity(50);\n      this.copyParent();\n      this.filter.gamma(0.7);\n      return this.newLayer(function() {\n        this.setBlendingMode('normal');\n        this.opacity(60);\n        return this.fillColor('#ea1c5d');\n      });\n    });\n    this.newLayer(function() {\n      this.setBlendingMode('multiply');\n      this.opacity(60);\n      this.copyParent();\n      this.filter.saturation(50);\n      this.filter.hue(90);\n      return this.filter.contrast(10);\n    });\n    this.gamma(1.4);\n    this.vibrance(-30);\n    this.newLayer(function() {\n      this.opacity(10);\n      return this.fillColor('#e5f0ff');\n    });\n    return this;\n  });\n\n  Caman.Filter.register(\"nostalgia\", function() {\n    this.saturation(20);\n    this.gamma(1.4);\n    this.greyscale();\n    this.contrast(5);\n    this.sepia(100);\n    this.channels({\n      red: 8,\n      blue: 2,\n      green: 4\n    });\n    this.gamma(0.8);\n    this.contrast(5);\n    this.exposure(10);\n    this.newLayer(function() {\n      this.setBlendingMode('overlay');\n      this.copyParent();\n      this.opacity(55);\n      return this.filter.stackBlur(10);\n    });\n    return this.vignette(\"50%\", 30);\n  });\n\n  Caman.Filter.register(\"hemingway\", function() {\n    this.greyscale();\n    this.contrast(10);\n    this.gamma(0.9);\n    this.newLayer(function() {\n      this.setBlendingMode(\"multiply\");\n      this.opacity(40);\n      this.copyParent();\n      this.filter.exposure(15);\n      this.filter.contrast(15);\n      return this.filter.channels({\n        green: 10,\n        red: 5\n      });\n    });\n    this.sepia(30);\n    this.curves('rgb', [0, 10], [120, 90], [180, 200], [235, 255]);\n    this.channels({\n      red: 5,\n      green: -2\n    });\n    return this.exposure(15);\n  });\n\n  Caman.Filter.register(\"concentrate\", function() {\n    this.sharpen(40);\n    this.saturation(-50);\n    this.channels({\n      red: 3\n    });\n    this.newLayer(function() {\n      this.setBlendingMode(\"multiply\");\n      this.opacity(80);\n      this.copyParent();\n      this.filter.sharpen(5);\n      this.filter.contrast(50);\n      this.filter.exposure(10);\n      return this.filter.channels({\n        blue: 5\n      });\n    });\n    return this.brightness(10);\n  });\n\n  Caman.Plugin.register(\"crop\", function(width, height, x, y) {\n    var canvas, ctx;\n    if (x == null) {\n      x = 0;\n    }\n    if (y == null) {\n      y = 0;\n    }\n    if (typeof exports !== \"undefined\" && exports !== null) {\n      canvas = new Canvas(width, height);\n    } else {\n      canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n    }\n    ctx = canvas.getContext('2d');\n    ctx.drawImage(this.canvas, x, y, width, height, 0, 0, width, height);\n    return this.replaceCanvas(canvas);\n  });\n\n  Caman.Plugin.register(\"resize\", function(newDims) {\n    var canvas, ctx;\n    if (newDims == null) {\n      newDims = null;\n    }\n    if (newDims === null || (!(newDims.width != null) && !(newDims.height != null))) {\n      Log.error(\"Invalid or missing dimensions given for resize\");\n      return;\n    }\n    if (!(newDims.width != null)) {\n      newDims.width = this.canvas.width * newDims.height / this.canvas.height;\n    } else if (!(newDims.height != null)) {\n      newDims.height = this.canvas.height * newDims.width / this.canvas.width;\n    }\n    if (typeof exports !== \"undefined\" && exports !== null) {\n      canvas = new Canvas(newDims.width, newDims.height);\n    } else {\n      canvas = document.createElement('canvas');\n      canvas.width = newDims.width;\n      canvas.height = newDims.height;\n    }\n    ctx = canvas.getContext('2d');\n    ctx.drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, newDims.width, newDims.height);\n    return this.replaceCanvas(canvas);\n  });\n\n  Caman.Filter.register(\"crop\", function(width, height, x, y) {\n    if (x == null) {\n      x = 0;\n    }\n    if (y == null) {\n      y = 0;\n    }\n    return this.processPlugin(\"crop\", Array.prototype.slice.call(arguments, 0));\n  });\n\n  Caman.Filter.register(\"resize\", function(width, height) {\n    return this.processPlugin(\"resize\", Array.prototype.slice.call(arguments, 0));\n  });\n\n  /*\n  StackBlur - a fast almost Gaussian Blur For Canvas v0.31 modified for CamanJS\n  \n  Version:   0.31\n  Author:    Mario Klingemann\n  Contact:   mario@quasimondo.com\n  Website:  http://www.quasimondo.com/StackBlurForCanvas\n  Twitter:  @quasimondo\n  Modified By: Ryan LeFevre (@meltingice)\n  \n  In case you find this class useful - especially in commercial projects -\n  I am not totally unhappy for a small donation to my PayPal account\n  mario@quasimondo.de\n  \n  Or support me on flattr: \n  https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript\n  \n  Copyright (c) 2010 Mario Klingemann\n  \n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation\n  files (the \"Software\"), to deal in the Software without\n  restriction, including without limitation the rights to use,\n  copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the\n  Software is furnished to do so, subject to the following\n  conditions:\n  \n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  OTHER DEALINGS IN THE SOFTWARE.\n  */\n\n\n  (function() {\n    var BlurStack, mul_table, shg_table;\n    mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];\n    shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];\n    BlurStack = function() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n      return this.next = null;\n    };\n    Caman.Plugin.register(\"stackBlur\", function(radius) {\n      var b_in_sum, b_out_sum, b_sum, div, g_in_sum, g_out_sum, g_sum, height, heightMinus1, i, mul_sum, p, pb, pg, pixels, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, shg_sum, stack, stackEnd, stackIn, stackOut, stackStart, sumFactor, w4, width, widthMinus1, x, y, yi, yp, yw, _i, _j, _k, _l, _m, _n, _o, _p, _q;\n      if (isNaN(radius) || radius < 1) {\n        return;\n      }\n      radius |= 0;\n      pixels = this.pixelData;\n      width = this.dimensions.width;\n      height = this.dimensions.height;\n      div = radius + radius + 1;\n      w4 = width << 2;\n      widthMinus1 = width - 1;\n      heightMinus1 = height - 1;\n      radiusPlus1 = radius + 1;\n      sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;\n      stackStart = new BlurStack();\n      stack = stackStart;\n      for (i = _i = 1; 1 <= div ? _i < div : _i > div; i = 1 <= div ? ++_i : --_i) {\n        stack = stack.next = new BlurStack();\n        if (i === radiusPlus1) {\n          stackEnd = stack;\n        }\n      }\n      stack.next = stackStart;\n      stackIn = null;\n      stackOut = null;\n      yw = yi = 0;\n      mul_sum = mul_table[radius];\n      shg_sum = shg_table[radius];\n      for (y = _j = 0; 0 <= height ? _j < height : _j > height; y = 0 <= height ? ++_j : --_j) {\n        r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;\n        r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n        r_sum += sumFactor * pr;\n        g_sum += sumFactor * pg;\n        b_sum += sumFactor * pb;\n        stack = stackStart;\n        for (i = _k = 0; 0 <= radiusPlus1 ? _k < radiusPlus1 : _k > radiusPlus1; i = 0 <= radiusPlus1 ? ++_k : --_k) {\n          stack.r = pr;\n          stack.g = pg;\n          stack.b = pb;\n          stack = stack.next;\n        }\n        for (i = _l = 1; 1 <= radiusPlus1 ? _l < radiusPlus1 : _l > radiusPlus1; i = 1 <= radiusPlus1 ? ++_l : --_l) {\n          p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);\n          r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);\n          g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;\n          b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;\n          r_in_sum += pr;\n          g_in_sum += pg;\n          b_in_sum += pb;\n          stack = stack.next;\n        }\n        stackIn = stackStart;\n        stackOut = stackEnd;\n        for (x = _m = 0; 0 <= width ? _m < width : _m > width; x = 0 <= width ? ++_m : --_m) {\n          pixels[yi] = (r_sum * mul_sum) >> shg_sum;\n          pixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;\n          pixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;\n          r_sum -= r_out_sum;\n          g_sum -= g_out_sum;\n          b_sum -= b_out_sum;\n          r_out_sum -= stackIn.r;\n          g_out_sum -= stackIn.g;\n          b_out_sum -= stackIn.b;\n          p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;\n          r_in_sum += (stackIn.r = pixels[p]);\n          g_in_sum += (stackIn.g = pixels[p + 1]);\n          b_in_sum += (stackIn.b = pixels[p + 2]);\n          r_sum += r_in_sum;\n          g_sum += g_in_sum;\n          b_sum += b_in_sum;\n          stackIn = stackIn.next;\n          r_out_sum += (pr = stackOut.r);\n          g_out_sum += (pg = stackOut.g);\n          b_out_sum += (pb = stackOut.b);\n          r_in_sum -= pr;\n          g_in_sum -= pg;\n          b_in_sum -= pb;\n          stackOut = stackOut.next;\n          yi += 4;\n        }\n        yw += width;\n      }\n      for (x = _n = 0; 0 <= width ? _n < width : _n > width; x = 0 <= width ? ++_n : --_n) {\n        g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;\n        yi = x << 2;\n        r_out_sum = radiusPlus1 * (pr = pixels[yi]);\n        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);\n        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);\n        r_sum += sumFactor * pr;\n        g_sum += sumFactor * pg;\n        b_sum += sumFactor * pb;\n        stack = stackStart;\n        for (i = _o = 0; 0 <= radiusPlus1 ? _o < radiusPlus1 : _o > radiusPlus1; i = 0 <= radiusPlus1 ? ++_o : --_o) {\n          stack.r = pr;\n          stack.g = pg;\n          stack.b = pb;\n          stack = stack.next;\n        }\n        yp = width;\n        for (i = _p = 1; 1 <= radius ? _p <= radius : _p >= radius; i = 1 <= radius ? ++_p : --_p) {\n          yi = (yp + x) << 2;\n          r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);\n          g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;\n          b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;\n          r_in_sum += pr;\n          g_in_sum += pg;\n          b_in_sum += pb;\n          stack = stack.next;\n          if (i < heightMinus1) {\n            yp += width;\n          }\n        }\n        yi = x;\n        stackIn = stackStart;\n        stackOut = stackEnd;\n        for (y = _q = 0; 0 <= height ? _q < height : _q > height; y = 0 <= height ? ++_q : --_q) {\n          p = yi << 2;\n          pixels[p] = (r_sum * mul_sum) >> shg_sum;\n          pixels[p + 1] = (g_sum * mul_sum) >> shg_sum;\n          pixels[p + 2] = (b_sum * mul_sum) >> shg_sum;\n          r_sum -= r_out_sum;\n          g_sum -= g_out_sum;\n          b_sum -= b_out_sum;\n          r_out_sum -= stackIn.r;\n          g_out_sum -= stackIn.g;\n          b_out_sum -= stackIn.b;\n          p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;\n          r_sum += (r_in_sum += (stackIn.r = pixels[p]));\n          g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));\n          b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));\n          stackIn = stackIn.next;\n          r_out_sum += (pr = stackOut.r);\n          g_out_sum += (pg = stackOut.g);\n          b_out_sum += (pb = stackOut.b);\n          r_in_sum -= pr;\n          g_in_sum -= pg;\n          b_in_sum -= pb;\n          stackOut = stackOut.next;\n          yi += width;\n        }\n      }\n      return this;\n    });\n    return Caman.Filter.register(\"stackBlur\", function(radius) {\n      return this.processPlugin(\"stackBlur\", [radius]);\n    });\n  })();\n\n  Caman.Filter.register(\"threshold\", function(adjust) {\n    return this.process(\"threshold\", function(rgba) {\n      var luminance;\n      luminance = (0.2126 * rgba.r) + (0.7152 * rgba.g) + (0.0722 * rgba.b);\n      if (luminance < adjust) {\n        rgba.r = 0;\n        rgba.g = 0;\n        rgba.b = 0;\n      } else {\n        rgba.r = 255;\n        rgba.g = 255;\n        rgba.b = 255;\n      }\n      return rgba;\n    });\n  });\n\n}).call(this);\n\n})();\n//@ sourceURL=caman");