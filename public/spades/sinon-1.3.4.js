minispade.register('sinon', "(function() {/**\n * Sinon.JS 1.3.4, 2012/04/16\n *\n * @author Christian Johansen (christian@cjohansen.no)\n *\n * (The BSD License)\n * \n * Copyright (c) 2010-2011, Christian Johansen, christian@cjohansen.no\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n *     * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright notice,\n *       this list of conditions and the following disclaimer in the documentation\n *       and/or other materials provided with the distribution.\n *     * Neither the name of Christian Johansen nor the names of his contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\"use strict\";\nvar sinon = (function () {\nvar buster = (function (buster, setTimeout) {\n    function extend(target) {\n        if (!target) {\n            return;\n        }\n\n        for (var i = 1, l = arguments.length, prop; i < l; ++i) {\n            for (prop in arguments[i]) {\n                target[prop] = arguments[i][prop];\n            }\n        }\n\n        return target;\n    }\n\n    var div = typeof document != \"undefined\" && document.createElement(\"div\");\n\n    return extend(buster, {\n        bind: function (obj, methOrProp) {\n            var method = typeof methOrProp == \"string\" ? obj[methOrProp] : methOrProp;\n            var args = Array.prototype.slice.call(arguments, 2);\n\n            return function () {\n                var allArgs = args.concat(Array.prototype.slice.call(arguments));\n                return method.apply(obj, allArgs);\n            };\n        },\n\n        create: (function () {\n            function F() {}\n\n            return function create(object) {\n                F.prototype = object;\n                return new F();\n            }\n        }()),\n\n        extend: extend,\n\n        nextTick: function (callback) {\n            if (typeof process != \"undefined\" && process.nextTick) {\n                return process.nextTick(callback);\n            }\n\n            setTimeout(callback, 0);\n        },\n\n        functionName: function (func) {\n            if (!func) return \"\";\n            if (func.displayName) return func.displayName;\n            if (func.name) return func.name;\n\n            var matches = func.toString().match(/function\\s+([^\\(]+)/m);\n            return matches && matches[1] || \"\";\n        },\n\n        isNode: function (obj) {\n            if (!div) return false;\n\n            try {\n                obj.appendChild(div);\n                obj.removeChild(div);\n            } catch (e) {\n                return false;\n            }\n\n            return true;\n        },\n\n        isElement: function (obj) {\n            return obj && buster.isNode(obj) && obj.nodeType === 1;\n        }\n    });\n}(buster || {}, setTimeout));\n\nif (typeof module == \"object\" && typeof require == \"function\") {\n    module.exports = buster;\n    buster.eventEmitter = require(\"./buster-event-emitter\");\n\n    Object.defineProperty(buster, \"defineVersionGetter\", {\n        get: function () {\n            return require(\"./define-version-getter\");\n        }\n    });\n}\nif (typeof buster === \"undefined\") {\n    var buster = {};\n}\n\nif (typeof module === \"object\" && typeof require === \"function\") {\n    buster = require(\"buster-core\");\n}\n\nbuster.format = buster.format || {};\nbuster.format.excludeConstructors = [\"Object\", /^.$/];\nbuster.format.quoteStrings = true;\n\nbuster.format.ascii = (function () {\n    \n    function keys(object) {\n        var k = Object.keys && Object.keys(object) || [];\n\n        if (k.length == 0) {\n            for (var prop in object) {\n                if (object.hasOwnProperty(prop)) {\n                    k.push(prop);\n                }\n            }\n        }\n\n        return k.sort();\n    }\n\n    function isCircular(object, objects) {\n        if (typeof object != \"object\") {\n            return false;\n        }\n\n        for (var i = 0, l = objects.length; i < l; ++i) {\n            if (objects[i] === object) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function ascii(object, processed, indent) {\n        if (typeof object == \"string\") {\n            var quote = typeof this.quoteStrings != \"boolean\" || this.quoteStrings;\n            return processed || quote ? '\"' + object + '\"' : object;\n        }\n\n        if (typeof object == \"function\" && !(object instanceof RegExp)) {\n            return ascii.func(object);\n        }\n\n        processed = processed || [];\n\n        if (isCircular(object, processed)) {\n            return \"[Circular]\";\n        }\n\n        if (Object.prototype.toString.call(object) == \"[object Array]\") {\n            return ascii.array.call(this, object);\n        }\n\n        if (!object) {\n            return \"\" + object;\n        }\n\n        if (buster.isElement(object)) {\n            return ascii.element(object);\n        }\n\n        if (typeof object.toString == \"function\" &&\n            object.toString !== Object.prototype.toString) {\n            return object.toString();\n        }\n\n        return ascii.object.call(this, object, processed, indent);\n    }\n\n    ascii.func = function (func) {\n        return \"function \" + buster.functionName(func) + \"() {}\";\n    };\n\n    ascii.array = function (array, processed) {\n        processed = processed || [];\n        processed.push(array);\n        var pieces = [];\n\n        for (var i = 0, l = array.length; i < l; ++i) {\n            pieces.push(ascii.call(this, array[i], processed));\n        }\n\n        return \"[\" + pieces.join(\", \") + \"]\";\n    };\n\n    ascii.object = function (object, processed, indent) {\n        processed = processed || [];\n        processed.push(object);\n        indent = indent || 0;\n        var pieces = [], properties = keys(object), prop, str, obj;\n        var is = \"\";\n        var length = 3;\n\n        for (var i = 0, l = indent; i < l; ++i) {\n            is += \" \";\n        }\n\n        for (i = 0, l = properties.length; i < l; ++i) {\n            prop = properties[i];\n            obj = object[prop];\n\n            if (isCircular(obj, processed)) {\n                str = \"[Circular]\";\n            } else {\n                str = ascii.call(this, obj, processed, indent + 2);\n            }\n\n            str = (/\\s/.test(prop) ? '\"' + prop + '\"' : prop) + \": \" + str;\n            length += str.length;\n            pieces.push(str);\n        }\n\n        var cons = ascii.constructorName.call(this, object);\n        var prefix = cons ? \"[\" + cons + \"] \" : \"\"\n\n        return (length + indent) > 80 ?\n            prefix + \"{\\n  \" + is + pieces.join(\",\\n  \" + is) + \"\\n\" + is + \"}\" :\n            prefix + \"{ \" + pieces.join(\", \") + \" }\";\n    };\n\n    ascii.element = function (element) {\n        var tagName = element.tagName.toLowerCase();\n        var attrs = element.attributes, attribute, pairs = [], attrName;\n\n        for (var i = 0, l = attrs.length; i < l; ++i) {\n            attribute = attrs.item(i);\n            attrName = attribute.nodeName.toLowerCase().replace(\"html:\", \"\");\n\n            if (attrName == \"contenteditable\" && attribute.nodeValue == \"inherit\") {\n                continue;\n            }\n\n            if (!!attribute.nodeValue) {\n                pairs.push(attrName + \"=\\\"\" + attribute.nodeValue + \"\\\"\");\n            }\n        }\n\n        var formatted = \"<\" + tagName + (pairs.length > 0 ? \" \" : \"\");\n        var content = element.innerHTML;\n\n        if (content.length > 20) {\n            content = content.substr(0, 20) + \"[...]\";\n        }\n\n        var res = formatted + pairs.join(\" \") + \">\" + content + \"</\" + tagName + \">\";\n\n        return res.replace(/ contentEditable=\"inherit\"/, \"\");\n    };\n\n    ascii.constructorName = function (object) {\n        var name = buster.functionName(object && object.constructor);\n        var excludes = this.excludeConstructors || buster.format.excludeConstructors || [];\n\n        for (var i = 0, l = excludes.length; i < l; ++i) {\n            if (typeof excludes[i] == \"string\" && excludes[i] == name) {\n                return \"\";\n            } else if (excludes[i].test && excludes[i].test(name)) {\n                return \"\";\n            }\n        }\n\n        return name;\n    };\n\n    return ascii;\n}());\n\nif (typeof module != \"undefined\") {\n    module.exports = buster.format;\n}\n/*jslint eqeqeq: false, onevar: false, forin: true, nomen: false, regexp: false, plusplus: false*/\n/*global module, require, __dirname, document*/\n/**\n * Sinon core utilities. For internal use only.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\nvar sinon = (function (buster) {\n    var div = typeof document != \"undefined\" && document.createElement(\"div\");\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    function isDOMNode(obj) {\n        var success = false;\n\n        try {\n            obj.appendChild(div);\n            success = div.parentNode == obj;\n        } catch (e) {\n            return false;\n        } finally {\n            try {\n                obj.removeChild(div);\n            } catch (e) {\n                // Remove failed, not much we can do about that\n            }\n        }\n\n        return success;\n    }\n\n    function isElement(obj) {\n        return div && obj && obj.nodeType === 1 && isDOMNode(obj);\n    }\n\n    function isFunction(obj) {\n        return !!(obj && obj.constructor && obj.call && obj.apply);\n    }\n\n    function mirrorProperties(target, source) {\n        for (var prop in source) {\n            if (!hasOwn.call(target, prop)) {\n                target[prop] = source[prop];\n            }\n        }\n    }\n\n    var sinon = {\n        wrapMethod: function wrapMethod(object, property, method) {\n            if (!object) {\n                throw new TypeError(\"Should wrap property of object\");\n            }\n\n            if (typeof method != \"function\") {\n                throw new TypeError(\"Method wrapper should be function\");\n            }\n\n            var wrappedMethod = object[property];\n\n            if (!isFunction(wrappedMethod)) {\n                throw new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                    property + \" as function\");\n            }\n\n            if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n                throw new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n            }\n\n            if (wrappedMethod.calledBefore) {\n                var verb = !!wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n                throw new TypeError(\"Attempted to wrap \" + property + \" which is already \" + verb);\n            }\n\n            // IE 8 does not support hasOwnProperty on the window object.\n            var owned = hasOwn.call(object, property);\n            object[property] = method;\n            method.displayName = property;\n\n            method.restore = function () {\n                if(owned) {\n                    object[property] = wrappedMethod;\n                } else {\n                    delete object[property];\n                }\n            };\n\n            method.restore.sinon = true;\n            mirrorProperties(method, wrappedMethod);\n\n            return method;\n        },\n\n        extend: function extend(target) {\n            for (var i = 1, l = arguments.length; i < l; i += 1) {\n                for (var prop in arguments[i]) {\n                    if (arguments[i].hasOwnProperty(prop)) {\n                        target[prop] = arguments[i][prop];\n                    }\n\n                    // DONT ENUM bug, only care about toString\n                    if (arguments[i].hasOwnProperty(\"toString\") &&\n                        arguments[i].toString != target.toString) {\n                        target.toString = arguments[i].toString;\n                    }\n                }\n            }\n\n            return target;\n        },\n\n        create: function create(proto) {\n            var F = function () {};\n            F.prototype = proto;\n            return new F();\n        },\n\n        deepEqual: function deepEqual(a, b) {\n            if (typeof a != \"object\" || typeof b != \"object\") {\n                return a === b;\n            }\n\n            if (isElement(a) || isElement(b)) {\n                return a === b;\n            }\n\n            if (a === b) {\n                return true;\n            }\n\n            var aString = Object.prototype.toString.call(a);\n            if (aString != Object.prototype.toString.call(b)) {\n                return false;\n            }\n\n            if (aString == \"[object Array]\") {\n                if (a.length !== b.length) {\n                    return false;\n                }\n\n                for (var i = 0, l = a.length; i < l; i += 1) {\n                    if (!deepEqual(a[i], b[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            var prop, aLength = 0, bLength = 0;\n\n            for (prop in a) {\n                aLength += 1;\n\n                if (!deepEqual(a[prop], b[prop])) {\n                    return false;\n                }\n            }\n\n            for (prop in b) {\n                bLength += 1;\n            }\n\n            if (aLength != bLength) {\n                return false;\n            }\n\n            return true;\n        },\n\n        functionName: function functionName(func) {\n            var name = func.displayName || func.name;\n\n            // Use function decomposition as a last resort to get function\n            // name. Does not rely on function decomposition to work - if it\n            // doesn't debugging will be slightly less informative\n            // (i.e. toString will say 'spy' rather than 'myFunc').\n            if (!name) {\n                var matches = func.toString().match(/function ([^\\s\\(]+)/);\n                name = matches && matches[1];\n            }\n\n            return name;\n        },\n\n        functionToString: function toString() {\n            if (this.getCall && this.callCount) {\n                var thisValue, prop, i = this.callCount;\n\n                while (i--) {\n                    thisValue = this.getCall(i).thisValue;\n\n                    for (prop in thisValue) {\n                        if (thisValue[prop] === this) {\n                            return prop;\n                        }\n                    }\n                }\n            }\n\n            return this.displayName || \"sinon fake\";\n        },\n\n        getConfig: function (custom) {\n            var config = {};\n            custom = custom || {};\n            var defaults = sinon.defaultConfig;\n\n            for (var prop in defaults) {\n                if (defaults.hasOwnProperty(prop)) {\n                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];\n                }\n            }\n\n            return config;\n        },\n\n        format: function (val) {\n            return \"\" + val;\n        },\n\n        defaultConfig: {\n            injectIntoThis: true,\n            injectInto: null,\n            properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n            useFakeTimers: true,\n            useFakeServer: true\n        },\n\n        timesInWords: function timesInWords(count) {\n            return count == 1 && \"once\" ||\n                count == 2 && \"twice\" ||\n                count == 3 && \"thrice\" ||\n                (count || 0) + \" times\";\n        },\n\n        calledInOrder: function (spies) {\n            for (var i = 1, l = spies.length; i < l; i++) {\n                if (!spies[i - 1].calledBefore(spies[i])) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        orderByFirstCall: function (spies) {\n            return spies.sort(function (a, b) {\n                // uuid, won't ever be equal\n                var aCall = a.getCall(0);\n                var bCall = b.getCall(0);\n                var aId = aCall && aCall.callId || -1;\n                var bId = bCall && bCall.callId || -1;\n\n                return aId < bId ? -1 : 1;\n            });\n        },\n\n        log: function () {},\n\n        logError: function (label, err) {\n            var msg = label + \" threw exception: \"\n            sinon.log(msg + \"[\" + err.name + \"] \" + err.message);\n            if (err.stack) { sinon.log(err.stack); }\n\n            setTimeout(function () {\n                err.message = msg + err.message;\n                throw err;\n            }, 0);\n        }\n    };\n\n    var isNode = typeof module == \"object\" && typeof require == \"function\";\n\n    if (isNode) {\n        try {\n            buster = { format: require(\"buster-format\") };\n        } catch (e) {}\n        module.exports = sinon;\n        module.exports.spy = require(\"./sinon/spy\");\n        module.exports.stub = require(\"./sinon/stub\");\n        module.exports.mock = require(\"./sinon/mock\");\n        module.exports.collection = require(\"./sinon/collection\");\n        module.exports.assert = require(\"./sinon/assert\");\n        module.exports.sandbox = require(\"./sinon/sandbox\");\n        module.exports.test = require(\"./sinon/test\");\n        module.exports.testCase = require(\"./sinon/test_case\");\n        module.exports.assert = require(\"./sinon/assert\");\n    }\n\n    if (buster) {\n        var formatter = sinon.create(buster.format);\n        formatter.quoteStrings = false;\n        sinon.format = function () {\n            return formatter.ascii.apply(formatter, arguments);\n        };\n    } else if (isNode) {\n        try {\n            var util = require(\"util\");\n            sinon.format = function (value) {\n                return typeof value == \"object\" ? util.inspect(value) : value;\n            };\n        } catch (e) {\n            /* Node, but no util module - would be very old, but better safe than\n             sorry */\n        }\n    }\n\n    return sinon;\n}(typeof buster == \"object\" && buster));\n\n/* @depend ../sinon.js */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Spy functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n    var spyCall;\n    var callId = 0;\n    var push = [].push;\n    var slice = Array.prototype.slice;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function spy(object, property) {\n        if (!property && typeof object == \"function\") {\n            return spy.create(object);\n        }\n\n        if (!object || !property) {\n            return spy.create(function () {});\n        }\n\n        var method = object[property];\n        return sinon.wrapMethod(object, property, spy.create(method));\n    }\n\n    sinon.extend(spy, (function () {\n\n        function delegateToCalls(api, method, matchAny, actual, notCalled) {\n            api[method] = function () {\n                if (!this.called) {\n                    if (notCalled) {\n                        return notCalled.apply(this, arguments);\n                    }\n                    return false;\n                }\n\n                var currentCall;\n                var matches = 0;\n\n                for (var i = 0, l = this.callCount; i < l; i += 1) {\n                    currentCall = this.getCall(i);\n\n                    if (currentCall[actual || method].apply(currentCall, arguments)) {\n                        matches += 1;\n\n                        if (matchAny) {\n                            return true;\n                        }\n                    }\n                }\n\n                return matches === this.callCount;\n            };\n        }\n\n        function matchingFake(fakes, args, strict) {\n            if (!fakes) {\n                return;\n            }\n\n            var alen = args.length;\n\n            for (var i = 0, l = fakes.length; i < l; i++) {\n                if (fakes[i].matches(args, strict)) {\n                    return fakes[i];\n                }\n            }\n        }\n\n        function incrementCallCount() {\n            this.called = true;\n            this.callCount += 1;\n            this.calledOnce = this.callCount == 1;\n            this.calledTwice = this.callCount == 2;\n            this.calledThrice = this.callCount == 3;\n        }\n\n        function createCallProperties() {\n            this.firstCall = this.getCall(0);\n            this.secondCall = this.getCall(1);\n            this.thirdCall = this.getCall(2);\n            this.lastCall = this.getCall(this.callCount - 1);\n        }\n\n        var uuid = 0;\n\n        // Public API\n        var spyApi = {\n            reset: function () {\n                this.called = false;\n                this.calledOnce = false;\n                this.calledTwice = false;\n                this.calledThrice = false;\n                this.callCount = 0;\n                this.firstCall = null;\n                this.secondCall = null;\n                this.thirdCall = null;\n                this.lastCall = null;\n                this.args = [];\n                this.returnValues = [];\n                this.thisValues = [];\n                this.exceptions = [];\n                this.callIds = [];\n            },\n\n            create: function create(func) {\n                var name;\n\n                if (typeof func != \"function\") {\n                    func = function () {};\n                } else {\n                    name = sinon.functionName(func);\n                }\n\n                function proxy() {\n                    return proxy.invoke(func, this, slice.call(arguments));\n                }\n\n                sinon.extend(proxy, spy);\n                delete proxy.create;\n                sinon.extend(proxy, func);\n\n                proxy.reset();\n                proxy.prototype = func.prototype;\n                proxy.displayName = name || \"spy\";\n                proxy.toString = sinon.functionToString;\n                proxy._create = sinon.spy.create;\n                proxy.id = \"spy#\" + uuid++;\n\n                return proxy;\n            },\n\n            invoke: function invoke(func, thisValue, args) {\n                var matching = matchingFake(this.fakes, args);\n                var exception, returnValue;\n\n                incrementCallCount.call(this);\n                push.call(this.thisValues, thisValue);\n                push.call(this.args, args);\n                push.call(this.callIds, callId++);\n\n                try {\n                    if (matching) {\n                        returnValue = matching.invoke(func, thisValue, args);\n                    } else {\n                        returnValue = (this.func || func).apply(thisValue, args);\n                    }\n                } catch (e) {\n                    push.call(this.returnValues, undefined);\n                    exception = e;\n                    throw e;\n                } finally {\n                    push.call(this.exceptions, exception);\n                }\n\n                push.call(this.returnValues, returnValue);\n\n                createCallProperties.call(this);\n\n                return returnValue;\n            },\n\n            getCall: function getCall(i) {\n                if (i < 0 || i >= this.callCount) {\n                    return null;\n                }\n\n                return spyCall.create(this, this.thisValues[i], this.args[i],\n                                      this.returnValues[i], this.exceptions[i],\n                                      this.callIds[i]);\n            },\n\n            calledBefore: function calledBefore(spyFn) {\n                if (!this.called) {\n                    return false;\n                }\n\n                if (!spyFn.called) {\n                    return true;\n                }\n\n                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];\n            },\n\n            calledAfter: function calledAfter(spyFn) {\n                if (!this.called || !spyFn.called) {\n                    return false;\n                }\n\n                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];\n            },\n\n            withArgs: function () {\n                var args = slice.call(arguments);\n\n                if (this.fakes) {\n                    var match = matchingFake(this.fakes, args, true);\n\n                    if (match) {\n                        return match;\n                    }\n                } else {\n                    this.fakes = [];\n                }\n\n                var original = this;\n                var fake = this._create();\n                fake.matchingAguments = args;\n                push.call(this.fakes, fake);\n\n                fake.withArgs = function () {\n                    return original.withArgs.apply(original, arguments);\n                };\n\n                for (var i = 0; i < this.args.length; i++) {\n                    if (fake.matches(this.args[i])) {\n                        incrementCallCount.call(fake);\n                        push.call(fake.thisValues, this.thisValues[i]);\n                        push.call(fake.args, this.args[i]);\n                        push.call(fake.returnValues, this.returnValues[i]);\n                        push.call(fake.exceptions, this.exceptions[i]);\n                        push.call(fake.callIds, this.callIds[i]);\n                    }\n                }\n                createCallProperties.call(fake);\n\n                return fake;\n            },\n\n            matches: function (args, strict) {\n                var margs = this.matchingAguments;\n\n                if (margs.length <= args.length &&\n                    sinon.deepEqual(margs, args.slice(0, margs.length))) {\n                    return !strict || margs.length == args.length;\n                }\n            },\n\n            printf: function (format) {\n                var spy = this;\n                var args = slice.call(arguments, 1);\n                var formatter;\n\n                return (format || \"\").replace(/%(.)/g, function (match, specifyer) {\n                    formatter = spyApi.formatters[specifyer];\n\n                    if (typeof formatter == \"function\") {\n                        return formatter.call(null, spy, args);\n                    } else if (!isNaN(parseInt(specifyer), 10)) {\n                        return sinon.format(args[specifyer - 1]);\n                    }\n\n                    return \"%\" + specifyer;\n                });\n            }\n        };\n\n        delegateToCalls(spyApi, \"calledOn\", true);\n        delegateToCalls(spyApi, \"alwaysCalledOn\", false, \"calledOn\");\n        delegateToCalls(spyApi, \"calledWith\", true);\n        delegateToCalls(spyApi, \"alwaysCalledWith\", false, \"calledWith\");\n        delegateToCalls(spyApi, \"calledWithExactly\", true);\n        delegateToCalls(spyApi, \"alwaysCalledWithExactly\", false, \"calledWithExactly\");\n        delegateToCalls(spyApi, \"neverCalledWith\", false, \"notCalledWith\",\n            function () { return true; });\n        delegateToCalls(spyApi, \"threw\", true);\n        delegateToCalls(spyApi, \"alwaysThrew\", false, \"threw\");\n        delegateToCalls(spyApi, \"returned\", true);\n        delegateToCalls(spyApi, \"alwaysReturned\", false, \"returned\");\n        delegateToCalls(spyApi, \"calledWithNew\", true);\n        delegateToCalls(spyApi, \"alwaysCalledWithNew\", false, \"calledWithNew\");\n        delegateToCalls(spyApi, \"callArg\", false, \"callArgWith\", function () {\n            throw new Error(this.toString() + \" cannot call arg since it was not yet invoked.\");\n        });\n        spyApi.callArgWith = spyApi.callArg;\n        delegateToCalls(spyApi, \"yield\", false, \"yield\", function () {\n            throw new Error(this.toString() + \" cannot yield since it was not yet invoked.\");\n        });\n        // \"invokeCallback\" is an alias for \"yield\" since \"yield\" is invalid in strict mode.\n        spyApi.invokeCallback = spyApi.yield;\n        delegateToCalls(spyApi, \"yieldTo\", false, \"yieldTo\", function (property) {\n            throw new Error(this.toString() + \" cannot yield to '\" + property +\n                \"' since it was not yet invoked.\");\n        });\n\n        spyApi.formatters = {\n            \"c\": function (spy) {\n                return sinon.timesInWords(spy.callCount);\n            },\n\n            \"n\": function (spy) {\n                return spy.toString();\n            },\n\n            \"C\": function (spy) {\n                var calls = [];\n\n                for (var i = 0, l = spy.callCount; i < l; ++i) {\n                    push.call(calls, \"    \" + spy.getCall(i).toString());\n                }\n\n                return calls.length > 0 ? \"\\n\" + calls.join(\"\\n\") : \"\";\n            },\n\n            \"t\": function (spy) {\n                var objects = [];\n\n                for (var i = 0, l = spy.callCount; i < l; ++i) {\n                    push.call(objects, sinon.format(spy.thisValues[i]));\n                }\n\n                return objects.join(\", \");\n            },\n\n            \"*\": function (spy, args) {\n                return args.join(\", \");\n            }\n        };\n\n        return spyApi;\n    }()));\n\n    spyCall = (function () {\n\n        function throwYieldError(proxy, text, args) {\n            var msg = sinon.functionName(proxy) + text;\n            if (args.length) {\n                msg += \" Received [\" + slice.call(args).join(\", \") + \"]\";\n            }\n            throw new Error(msg);\n        }\n\n        return {\n            create: function create(spy, thisValue, args, returnValue, exception, id) {\n                var proxyCall = sinon.create(spyCall);\n                delete proxyCall.create;\n                proxyCall.proxy = spy;\n                proxyCall.thisValue = thisValue;\n                proxyCall.args = args;\n                proxyCall.returnValue = returnValue;\n                proxyCall.exception = exception;\n                proxyCall.callId = typeof id == \"number\" && id || callId++;\n\n                return proxyCall;\n            },\n\n            calledOn: function calledOn(thisValue) {\n                return this.thisValue === thisValue;\n            },\n\n            calledWith: function calledWith() {\n                for (var i = 0, l = arguments.length; i < l; i += 1) {\n                    if (!sinon.deepEqual(arguments[i], this.args[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n\n            calledWithExactly: function calledWithExactly() {\n                return arguments.length == this.args.length &&\n                    this.calledWith.apply(this, arguments);\n            },\n\n            notCalledWith: function notCalledWith() {\n                for (var i = 0, l = arguments.length; i < l; i += 1) {\n                    if (!sinon.deepEqual(arguments[i], this.args[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n\n            returned: function returned(value) {\n                return this.returnValue === value;\n            },\n\n            threw: function threw(error) {\n                if (typeof error == \"undefined\" || !this.exception) {\n                    return !!this.exception;\n                }\n\n                if (typeof error == \"string\") {\n                    return this.exception.name == error;\n                }\n\n                return this.exception === error;\n            },\n\n            calledWithNew: function calledWithNew(thisValue) {\n                return this.thisValue instanceof this.proxy;\n            },\n\n            calledBefore: function (other) {\n                return this.callId < other.callId;\n            },\n\n            calledAfter: function (other) {\n                return this.callId > other.callId;\n            },\n\n            callArg: function (pos) {\n                this.args[pos]();\n            },\n\n            callArgWith: function (pos) {\n                var args = slice.call(arguments, 1);\n                this.args[pos].apply(null, args);\n            },\n\n            \"yield\": function () {\n                var args = this.args;\n                for (var i = 0, l = args.length; i < l; ++i) {\n                    if (typeof args[i] === \"function\") {\n                        args[i].apply(null, slice.call(arguments));\n                        return;\n                    }\n                }\n                throwYieldError(this.proxy, \" cannot yield since no callback was passed.\", args);\n            },\n\n            yieldTo: function (prop) {\n                var args = this.args;\n                for (var i = 0, l = args.length; i < l; ++i) {\n                    if (args[i] && typeof args[i][prop] === \"function\") {\n                        args[i][prop].apply(null, slice.call(arguments, 1));\n                        return;\n                    }\n                }\n                throwYieldError(this.proxy, \" cannot yield to '\" + prop +\n                    \"' since no callback was passed.\", args);\n            },\n\n            toString: function () {\n                var callStr = this.proxy.toString() + \"(\";\n                var args = [];\n\n                for (var i = 0, l = this.args.length; i < l; ++i) {\n                    push.call(args, sinon.format(this.args[i]));\n                }\n\n                callStr = callStr + args.join(\", \") + \")\";\n\n                if (typeof this.returnValue != \"undefined\") {\n                    callStr += \" => \" + sinon.format(this.returnValue);\n                }\n\n                if (this.exception) {\n                    callStr += \" !\" + this.exception.name;\n\n                    if (this.exception.message) {\n                        callStr += \"(\" + this.exception.message + \")\";\n                    }\n                }\n\n                return callStr;\n            }\n        };\n    }());\n\n    spy.spyCall = spyCall;\n\n    // This steps outside the module sandbox and will be removed\n    sinon.spyCall = spyCall;\n\n    if (commonJSModule) {\n        module.exports = spy;\n    } else {\n        sinon.spy = spy;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend spy.js\n */\n/*jslint eqeqeq: false, onevar: false*/\n/*global module, require, sinon*/\n/**\n * Stub functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function stub(object, property, func) {\n        if (!!func && typeof func != \"function\") {\n            throw new TypeError(\"Custom stub should be function\");\n        }\n\n        var wrapper;\n\n        if (func) {\n            wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;\n        } else {\n            wrapper = stub.create();\n        }\n\n        if (!object && !property) {\n            return sinon.stub.create();\n        }\n\n        if (!property && !!object && typeof object == \"object\") {\n            for (var prop in object) {\n                if (typeof object[prop] === \"function\") {\n                    stub(object, prop);\n                }\n            }\n\n            return object;\n        }\n\n        return sinon.wrapMethod(object, property, wrapper);\n    }\n\n    function getCallback(stub, args) {\n        if (stub.callArgAt < 0) {\n            for (var i = 0, l = args.length; i < l; ++i) {\n                if (!stub.callArgProp && typeof args[i] == \"function\") {\n                    return args[i];\n                }\n\n                if (stub.callArgProp && args[i] &&\n                    typeof args[i][stub.callArgProp] == \"function\") {\n                    return args[i][stub.callArgProp];\n                }\n            }\n\n            return null;\n        }\n\n        return args[stub.callArgAt];\n    }\n\n    var join = Array.prototype.join;\n\n    function getCallbackError(stub, func, args) {\n        if (stub.callArgAt < 0) {\n            var msg;\n\n            if (stub.callArgProp) {\n                msg = sinon.functionName(stub) +\n                    \" expected to yield to '\" + stub.callArgProp +\n                    \"', but no object with such a property was passed.\"\n            } else {\n                msg = sinon.functionName(stub) +\n                            \" expected to yield, but no callback was passed.\"\n            }\n\n            if (args.length > 0) {\n                msg += \" Received [\" + join.call(args, \", \") + \"]\";\n            }\n\n            return msg;\n        }\n\n        return \"argument at index \" + stub.callArgAt + \" is not a function: \" + func;\n    }\n\n    function callCallback(stub, args) {\n        if (typeof stub.callArgAt == \"number\") {\n            var func = getCallback(stub, args);\n\n            if (typeof func != \"function\") {\n                throw new TypeError(getCallbackError(stub, func, args));\n            }\n\n            func.apply(stub.callbackContext, stub.callbackArguments);\n        }\n    }\n\n    var uuid = 0;\n\n    sinon.extend(stub, (function () {\n        var slice = Array.prototype.slice;\n\n        function throwsException(error, message) {\n            if (typeof error == \"string\") {\n                this.exception = new Error(message || \"\");\n                this.exception.name = error;\n            } else if (!error) {\n                this.exception = new Error(\"Error\");\n            } else {\n                this.exception = error;\n            }\n            \n            return this;\n        }\n\n        return {\n            create: function create() {\n                var functionStub = function () {\n                    if (functionStub.exception) {\n                        throw functionStub.exception;\n                    } else if (typeof functionStub.returnArgAt == 'number') {\n                        return arguments[functionStub.returnArgAt];\n                    }\n\n                    callCallback(functionStub, arguments);\n\n                    return functionStub.returnValue;\n                };\n\n                functionStub.id = \"stub#\" + uuid++;\n                var orig = functionStub;\n                functionStub = sinon.spy.create(functionStub);\n                functionStub.func = orig;\n\n                sinon.extend(functionStub, stub);\n                functionStub._create = sinon.stub.create;\n                functionStub.displayName = \"stub\";\n                functionStub.toString = sinon.functionToString;\n\n                return functionStub;\n            },\n\n            returns: function returns(value) {\n                this.returnValue = value;\n\n                return this;\n            },\n\n            returnsArg: function returnsArg(pos) {\n                if (typeof pos != \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n                \n                this.returnArgAt = pos;\n\n                return this;\n            },\n\n            \"throws\": throwsException,\n            throwsException: throwsException,\n\n            callsArg: function callsArg(pos) {\n                if (typeof pos != \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = [];\n\n                return this;\n            },\n\n            callsArgOn: function callsArgOn(pos, context) {\n                if (typeof pos != \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n                if (typeof context != \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = [];\n                this.callbackContext = context;\n\n                return this;\n            },\n\n            callsArgWith: function callsArgWith(pos) {\n                if (typeof pos != \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = slice.call(arguments, 1);\n\n                return this;\n            },\n\n            callsArgOnWith: function callsArgWith(pos, context) {\n                if (typeof pos != \"number\") {\n                    throw new TypeError(\"argument index is not number\");\n                }\n                if (typeof context != \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = pos;\n                this.callbackArguments = slice.call(arguments, 2);\n                this.callbackContext = context;\n\n                return this;\n            },\n\n            yields: function () {\n                this.callArgAt = -1;\n                this.callbackArguments = slice.call(arguments, 0);\n\n                return this;\n            },\n\n            yieldsOn: function (context) {\n                if (typeof context != \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = -1;\n                this.callbackArguments = slice.call(arguments, 1);\n                this.callbackContext = context;\n\n                return this;\n            },\n\n            yieldsTo: function (prop) {\n                this.callArgAt = -1;\n                this.callArgProp = prop;\n                this.callbackArguments = slice.call(arguments, 1);\n\n                return this;\n            },\n\n            yieldsToOn: function (prop, context) {\n                if (typeof context != \"object\") {\n                    throw new TypeError(\"argument context is not an object\");\n                }\n\n                this.callArgAt = -1;\n                this.callArgProp = prop;\n                this.callbackArguments = slice.call(arguments, 2);\n                this.callbackContext = context;\n\n                return this;\n            }\n        };\n    }()));\n\n    if (commonJSModule) {\n        module.exports = stub;\n    } else {\n        sinon.stub = stub;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n */\n/*jslint eqeqeq: false, onevar: false, nomen: false*/\n/*global module, require, sinon*/\n/**\n * Mock functions.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n    var push = [].push;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function mock(object) {\n        if (!object) {\n            return sinon.expectation.create(\"Anonymous mock\");\n        }\n\n        return mock.create(object);\n    }\n\n    sinon.mock = mock;\n\n    sinon.extend(mock, (function () {\n        function each(collection, callback) {\n            if (!collection) {\n                return;\n            }\n\n            for (var i = 0, l = collection.length; i < l; i += 1) {\n                callback(collection[i]);\n            }\n        }\n\n        return {\n            create: function create(object) {\n                if (!object) {\n                    throw new TypeError(\"object is null\");\n                }\n\n                var mockObject = sinon.extend({}, mock);\n                mockObject.object = object;\n                delete mockObject.create;\n\n                return mockObject;\n            },\n\n            expects: function expects(method) {\n                if (!method) {\n                    throw new TypeError(\"method is falsy\");\n                }\n\n                if (!this.expectations) {\n                    this.expectations = {};\n                    this.proxies = [];\n                }\n\n                if (!this.expectations[method]) {\n                    this.expectations[method] = [];\n                    var mockObject = this;\n\n                    sinon.wrapMethod(this.object, method, function () {\n                        return mockObject.invokeMethod(method, this, arguments);\n                    });\n\n                    push.call(this.proxies, method);\n                }\n\n                var expectation = sinon.expectation.create(method);\n                push.call(this.expectations[method], expectation);\n\n                return expectation;\n            },\n\n            restore: function restore() {\n                var object = this.object;\n\n                each(this.proxies, function (proxy) {\n                    if (typeof object[proxy].restore == \"function\") {\n                        object[proxy].restore();\n                    }\n                });\n            },\n\n            verify: function verify() {\n                var expectations = this.expectations || {};\n                var messages = [], met = [];\n\n                each(this.proxies, function (proxy) {\n                    each(expectations[proxy], function (expectation) {\n                        if (!expectation.met()) {\n                            push.call(messages, expectation.toString());\n                        } else {\n                            push.call(met, expectation.toString());\n                        }\n                    });\n                });\n\n                this.restore();\n\n                if (messages.length > 0) {\n                    sinon.expectation.fail(messages.concat(met).join(\"\\n\"));\n                }\n\n                return true;\n            },\n\n            invokeMethod: function invokeMethod(method, thisValue, args) {\n                var expectations = this.expectations && this.expectations[method];\n                var length = expectations && expectations.length || 0;\n\n                for (var i = 0; i < length; i += 1) {\n                    if (!expectations[i].met() &&\n                        expectations[i].allowsCall(thisValue, args)) {\n                        return expectations[i].apply(thisValue, args);\n                    }\n                }\n\n                var messages = [];\n\n                for (i = 0; i < length; i += 1) {\n                    push.call(messages, \"    \" + expectations[i].toString());\n                }\n\n                messages.unshift(\"Unexpected call: \" + sinon.spyCall.toString.call({\n                    proxy: method,\n                    args: args\n                }));\n\n                sinon.expectation.fail(messages.join(\"\\n\"));\n            }\n        };\n    }()));\n\n    var times = sinon.timesInWords;\n\n    sinon.expectation = (function () {\n        var slice = Array.prototype.slice;\n        var _invoke = sinon.spy.invoke;\n\n        function callCountInWords(callCount) {\n            if (callCount == 0) {\n                return \"never called\";\n            } else {\n                return \"called \" + times(callCount);\n            }\n        }\n\n        function expectedCallCountInWords(expectation) {\n            var min = expectation.minCalls;\n            var max = expectation.maxCalls;\n\n            if (typeof min == \"number\" && typeof max == \"number\") {\n                var str = times(min);\n\n                if (min != max) {\n                    str = \"at least \" + str + \" and at most \" + times(max);\n                }\n\n                return str;\n            }\n\n            if (typeof min == \"number\") {\n                return \"at least \" + times(min);\n            }\n\n            return \"at most \" + times(max);\n        }\n\n        function receivedMinCalls(expectation) {\n            var hasMinLimit = typeof expectation.minCalls == \"number\";\n            return !hasMinLimit || expectation.callCount >= expectation.minCalls;\n        }\n\n        function receivedMaxCalls(expectation) {\n            if (typeof expectation.maxCalls != \"number\") {\n                return false;\n            }\n\n            return expectation.callCount == expectation.maxCalls;\n        }\n\n        return {\n            minCalls: 1,\n            maxCalls: 1,\n\n            create: function create(methodName) {\n                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);\n                delete expectation.create;\n                expectation.method = methodName;\n\n                return expectation;\n            },\n\n            invoke: function invoke(func, thisValue, args) {\n                this.verifyCallAllowed(thisValue, args);\n\n                return _invoke.apply(this, arguments);\n            },\n\n            atLeast: function atLeast(num) {\n                if (typeof num != \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not number\");\n                }\n\n                if (!this.limitsSet) {\n                    this.maxCalls = null;\n                    this.limitsSet = true;\n                }\n\n                this.minCalls = num;\n\n                return this;\n            },\n\n            atMost: function atMost(num) {\n                if (typeof num != \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not number\");\n                }\n\n                if (!this.limitsSet) {\n                    this.minCalls = null;\n                    this.limitsSet = true;\n                }\n\n                this.maxCalls = num;\n\n                return this;\n            },\n\n            never: function never() {\n                return this.exactly(0);\n            },\n\n            once: function once() {\n                return this.exactly(1);\n            },\n\n            twice: function twice() {\n                return this.exactly(2);\n            },\n\n            thrice: function thrice() {\n                return this.exactly(3);\n            },\n\n            exactly: function exactly(num) {\n                if (typeof num != \"number\") {\n                    throw new TypeError(\"'\" + num + \"' is not a number\");\n                }\n\n                this.atLeast(num);\n                return this.atMost(num);\n            },\n\n            met: function met() {\n                return !this.failed && receivedMinCalls(this);\n            },\n\n            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {\n                if (receivedMaxCalls(this)) {\n                    this.failed = true;\n                    sinon.expectation.fail(this.method + \" already called \" + times(this.maxCalls));\n                }\n\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n                    sinon.expectation.fail(this.method + \" called with \" + thisValue + \" as thisValue, expected \" +\n                        this.expectedThis);\n                }\n\n                if (!(\"expectedArguments\" in this)) {\n                    return;\n                }\n\n                if (!args || args.length === 0) {\n                    sinon.expectation.fail(this.method + \" received no arguments, expected \" +\n                        this.expectedArguments.join());\n                }\n\n                if (args.length < this.expectedArguments.length) {\n                    sinon.expectation.fail(this.method + \" received too few arguments (\" + args.join() +\n                        \"), expected \" + this.expectedArguments.join());\n                }\n\n                if (this.expectsExactArgCount &&\n                    args.length != this.expectedArguments.length) {\n                    sinon.expectation.fail(this.method + \" received too many arguments (\" + args.join() +\n                        \"), expected \" + this.expectedArguments.join());\n                }\n\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n                        sinon.expectation.fail(this.method + \" received wrong arguments (\" + args.join() +\n                            \"), expected \" + this.expectedArguments.join());\n                    }\n                }\n            },\n\n            allowsCall: function allowsCall(thisValue, args) {\n                if (this.met()) {\n                    return false;\n                }\n\n                if (\"expectedThis\" in this && this.expectedThis !== thisValue) {\n                    return false;\n                }\n\n                if (!(\"expectedArguments\" in this)) {\n                    return true;\n                }\n\n                args = args || [];\n\n                if (args.length < this.expectedArguments.length) {\n                    return false;\n                }\n\n                if (this.expectsExactArgCount &&\n                    args.length != this.expectedArguments.length) {\n                    return false;\n                }\n\n                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {\n                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n\n            withArgs: function withArgs() {\n                this.expectedArguments = slice.call(arguments);\n                return this;\n            },\n\n            withExactArgs: function withExactArgs() {\n                this.withArgs.apply(this, arguments);\n                this.expectsExactArgCount = true;\n                return this;\n            },\n\n            on: function on(thisValue) {\n                this.expectedThis = thisValue;\n                return this;\n            },\n\n            toString: function () {\n                var args = (this.expectedArguments || []).slice();\n\n                if (!this.expectsExactArgCount) {\n                    push.call(args, \"[...]\");\n                }\n\n                var callStr = sinon.spyCall.toString.call({\n                    proxy: this.method, args: args\n                });\n\n                var message = callStr.replace(\", [...\", \"[, ...\") + \" \" +\n                    expectedCallCountInWords(this);\n\n                if (this.met()) {\n                    return \"Expectation met: \" + message;\n                }\n\n                return \"Expected \" + message + \" (\" +\n                    callCountInWords(this.callCount) + \")\";\n            },\n\n            verify: function verify() {\n                if (!this.met()) {\n                    sinon.expectation.fail(this.toString());\n                }\n\n                return true;\n            },\n\n            fail: function (message) {\n                var exception = new Error(message);\n                exception.name = \"ExpectationError\";\n\n                throw exception;\n            }\n        };\n    }());\n\n    if (commonJSModule) {\n        module.exports = mock;\n    } else {\n        sinon.mock = mock;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n * @depend mock.js\n */\n/*jslint eqeqeq: false, onevar: false, forin: true*/\n/*global module, require, sinon*/\n/**\n * Collections of stubs, spies and mocks.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n    var push = [].push;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function getFakes(fakeCollection) {\n        if (!fakeCollection.fakes) {\n            fakeCollection.fakes = [];\n        }\n\n        return fakeCollection.fakes;\n    }\n\n    function each(fakeCollection, method) {\n        var fakes = getFakes(fakeCollection);\n\n        for (var i = 0, l = fakes.length; i < l; i += 1) {\n            if (typeof fakes[i][method] == \"function\") {\n                fakes[i][method]();\n            }\n        }\n    }\n\n    function compact(fakeCollection) {\n        var fakes = getFakes(fakeCollection);\n        var i = 0;\n        while (i < fakes.length) {\n          fakes.splice(i, 1);\n        }\n    }\n\n    var collection = {\n        verify: function resolve() {\n            each(this, \"verify\");\n        },\n\n        restore: function restore() {\n            each(this, \"restore\");\n            compact(this);\n        },\n\n        verifyAndRestore: function verifyAndRestore() {\n            var exception;\n\n            try {\n                this.verify();\n            } catch (e) {\n                exception = e;\n            }\n\n            this.restore();\n\n            if (exception) {\n                throw exception;\n            }\n        },\n\n        add: function add(fake) {\n            push.call(getFakes(this), fake);\n            return fake;\n        },\n\n        spy: function spy() {\n            return this.add(sinon.spy.apply(sinon, arguments));\n        },\n\n        stub: function stub(object, property, value) {\n            if (property) {\n                var original = object[property];\n\n                if (typeof original != \"function\") {\n                    if (!object.hasOwnProperty(property)) {\n                        throw new TypeError(\"Cannot stub non-existent own property \" + property);\n                    }\n\n                    object[property] = value;\n\n                    return this.add({\n                        restore: function () {\n                            object[property] = original;\n                        }\n                    });\n                }\n            }\n\n            return this.add(sinon.stub.apply(sinon, arguments));\n        },\n\n        mock: function mock() {\n            return this.add(sinon.mock.apply(sinon, arguments));\n        },\n\n        inject: function inject(obj) {\n            var col = this;\n\n            obj.spy = function () {\n                return col.spy.apply(col, arguments);\n            };\n\n            obj.stub = function () {\n                return col.stub.apply(col, arguments);\n            };\n\n            obj.mock = function () {\n                return col.mock.apply(col, arguments);\n            };\n\n            return obj;\n        }\n    };\n\n    if (commonJSModule) {\n        module.exports = collection;\n    } else {\n        sinon.collection = collection;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/*jslint eqeqeq: false, plusplus: false, evil: true, onevar: false, browser: true, forin: false*/\n/*global module, require, window*/\n/**\n * Fake timer API\n * setTimeout\n * setInterval\n * clearTimeout\n * clearInterval\n * tick\n * reset\n * Date\n *\n * Inspired by jsUnitMockTimeOut from JsUnit\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    var sinon = {};\n}\n\n(function (global) {\n    var id = 1;\n\n    function addTimer(args, recurring) {\n        if (args.length === 0) {\n            throw new Error(\"Function requires at least 1 parameter\");\n        }\n\n        var toId = id++;\n        var delay = args[1] || 0;\n\n        if (!this.timeouts) {\n            this.timeouts = {};\n        }\n\n        this.timeouts[toId] = {\n            id: toId,\n            func: args[0],\n            callAt: this.now + delay\n        };\n\n        if (recurring === true) {\n            this.timeouts[toId].interval = delay;\n        }\n\n        return toId;\n    }\n\n    function parseTime(str) {\n        if (!str) {\n            return 0;\n        }\n\n        var strings = str.split(\":\");\n        var l = strings.length, i = l;\n        var ms = 0, parsed;\n\n        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n            throw new Error(\"tick only understands numbers and 'h:m:s'\");\n        }\n\n        while (i--) {\n            parsed = parseInt(strings[i], 10);\n\n            if (parsed >= 60) {\n                throw new Error(\"Invalid time \" + str);\n            }\n\n            ms += parsed * Math.pow(60, (l - i - 1));\n        }\n\n        return ms * 1000;\n    }\n\n    function createObject(object) {\n        var newObject;\n\n        if (Object.create) {\n            newObject = Object.create(object);\n        } else {\n            var F = function () {};\n            F.prototype = object;\n            newObject = new F();\n        }\n\n        newObject.Date.clock = newObject;\n        return newObject;\n    }\n\n    sinon.clock = {\n        now: 0,\n\n        create: function create(now) {\n            var clock = createObject(this);\n\n            if (typeof now == \"number\") {\n                clock.now = now;\n            }\n\n            if (!!now && typeof now == \"object\") {\n                throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n            }\n\n            return clock;\n        },\n\n        setTimeout: function setTimeout(callback, timeout) {\n            return addTimer.call(this, arguments, false);\n        },\n\n        clearTimeout: function clearTimeout(timerId) {\n            if (!this.timeouts) {\n                this.timeouts = [];\n            }\n\n            if (timerId in this.timeouts) {\n                delete this.timeouts[timerId];\n            }\n        },\n\n        setInterval: function setInterval(callback, timeout) {\n            return addTimer.call(this, arguments, true);\n        },\n\n        clearInterval: function clearInterval(timerId) {\n            this.clearTimeout(timerId);\n        },\n\n        tick: function tick(ms) {\n            ms = typeof ms == \"number\" ? ms : parseTime(ms);\n            var tickFrom = this.now, tickTo = this.now + ms, previous = this.now;\n            var timer = this.firstTimerInRange(tickFrom, tickTo);\n\n            var firstException;\n            while (timer && tickFrom <= tickTo) {\n                if (this.timeouts[timer.id]) {\n                    tickFrom = this.now = timer.callAt;\n                    try {\n                      this.callTimer(timer);\n                    } catch (e) {\n                      firstException = firstException || e;\n                    }\n                }\n\n                timer = this.firstTimerInRange(previous, tickTo);\n                previous = tickFrom;\n            }\n\n            this.now = tickTo;\n\n            if (firstException) {\n              throw firstException;\n            }\n        },\n\n        firstTimerInRange: function (from, to) {\n            var timer, smallest, originalTimer;\n\n            for (var id in this.timeouts) {\n                if (this.timeouts.hasOwnProperty(id)) {\n                    if (this.timeouts[id].callAt < from || this.timeouts[id].callAt > to) {\n                        continue;\n                    }\n\n                    if (!smallest || this.timeouts[id].callAt < smallest) {\n                        originalTimer = this.timeouts[id];\n                        smallest = this.timeouts[id].callAt;\n\n                        timer = {\n                            func: this.timeouts[id].func,\n                            callAt: this.timeouts[id].callAt,\n                            interval: this.timeouts[id].interval,\n                            id: this.timeouts[id].id\n                        };\n                    }\n                }\n            }\n\n            return timer || null;\n        },\n\n        callTimer: function (timer) {\n            try {\n                if (typeof timer.func == \"function\") {\n                    timer.func.call(null);\n                } else {\n                    eval(timer.func);\n                }\n            } catch (e) {\n              var exception = e;\n            }\n\n            if (!this.timeouts[timer.id]) {\n                if (exception) {\n                  throw exception;\n                }\n                return;\n            }\n\n            if (typeof timer.interval == \"number\") {\n                this.timeouts[timer.id].callAt += timer.interval;\n            } else {\n                delete this.timeouts[timer.id];\n            }\n\n            if (exception) {\n              throw exception;\n            }\n        },\n\n        reset: function reset() {\n            this.timeouts = {};\n        },\n\n        Date: (function () {\n            var NativeDate = Date;\n\n            function ClockDate(year, month, date, hour, minute, second, ms) {\n                // Defensive and verbose to avoid potential harm in passing\n                // explicit undefined when user does not pass argument\n                switch (arguments.length) {\n                case 0:\n                    return new NativeDate(ClockDate.clock.now);\n                case 1:\n                    return new NativeDate(year);\n                case 2:\n                    return new NativeDate(year, month);\n                case 3:\n                    return new NativeDate(year, month, date);\n                case 4:\n                    return new NativeDate(year, month, date, hour);\n                case 5:\n                    return new NativeDate(year, month, date, hour, minute);\n                case 6:\n                    return new NativeDate(year, month, date, hour, minute, second);\n                default:\n                    return new NativeDate(year, month, date, hour, minute, second, ms);\n                }\n            }\n\n            return mirrorDateProperties(ClockDate, NativeDate);\n        }())\n    };\n\n    function mirrorDateProperties(target, source) {\n        if (source.now) {\n            target.now = function now() {\n                return target.clock.now;\n            };\n        } else {\n            delete target.now;\n        }\n\n        if (source.toSource) {\n            target.toSource = function toSource() {\n                return source.toSource();\n            };\n        } else {\n            delete target.toSource;\n        }\n\n        target.toString = function toString() {\n            return source.toString();\n        };\n\n        target.prototype = source.prototype;\n        target.parse = source.parse;\n        target.UTC = source.UTC;\n        target.prototype.toUTCString = source.prototype.toUTCString;\n        return target;\n    }\n\n    var methods = [\"Date\", \"setTimeout\", \"setInterval\",\n                   \"clearTimeout\", \"clearInterval\"];\n\n    function restore() {\n        var method;\n\n        for (var i = 0, l = this.methods.length; i < l; i++) {\n            method = this.methods[i];\n            global[method] = this[\"_\" + method];\n        }\n    }\n\n    function stubGlobal(method, clock) {\n        clock[\"_\" + method] = global[method];\n\n        if (method == \"Date\") {\n            var date = mirrorDateProperties(clock[method], global[method]);\n            global[method] = date;\n        } else {\n            global[method] = function () {\n                return clock[method].apply(clock, arguments);\n            };\n\n            for (var prop in clock[method]) {\n                if (clock[method].hasOwnProperty(prop)) {\n                    global[method][prop] = clock[method][prop];\n                }\n            }\n        }\n\n        global[method].clock = clock;\n    }\n\n    sinon.useFakeTimers = function useFakeTimers(now) {\n        var clock = sinon.clock.create(now);\n        clock.restore = restore;\n        clock.methods = Array.prototype.slice.call(arguments,\n                                                   typeof now == \"number\" ? 1 : 0);\n\n        if (clock.methods.length === 0) {\n            clock.methods = methods;\n        }\n\n        for (var i = 0, l = clock.methods.length; i < l; i++) {\n            stubGlobal(clock.methods[i], clock);\n        }\n\n        return clock;\n    };\n}(typeof global != \"undefined\" && typeof global !== \"function\" ? global : this));\n\nsinon.timers = {\n    setTimeout: setTimeout,\n    clearTimeout: clearTimeout,\n    setInterval: setInterval,\n    clearInterval: clearInterval,\n    Date: Date\n};\n\nif (typeof module == \"object\" && typeof require == \"function\") {\n    module.exports = sinon;\n}\n\n/*jslint eqeqeq: false, onevar: false*/\n/*global sinon, module, require, ActiveXObject, XMLHttpRequest, DOMParser*/\n/**\n * Minimal Event interface implementation\n *\n * Original implementation by Sven Fuchs: https://gist.github.com/995028\n * Modifications and tests by Christian Johansen.\n *\n * @author Sven Fuchs (svenfuchs@artweb-design.de)\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2011 Sven Fuchs, Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    this.sinon = {};\n}\n\n(function () {\n    var push = [].push;\n\n    sinon.Event = function Event(type, bubbles, cancelable) {\n        this.initEvent(type, bubbles, cancelable);\n    };\n\n    sinon.Event.prototype = {\n        initEvent: function(type, bubbles, cancelable) {\n            this.type = type;\n            this.bubbles = bubbles;\n            this.cancelable = cancelable;\n        },\n\n        stopPropagation: function () {},\n\n        preventDefault: function () {\n            this.defaultPrevented = true;\n        }\n    };\n\n    sinon.EventTarget = {\n        addEventListener: function addEventListener(event, listener, useCapture) {\n            this.eventListeners = this.eventListeners || {};\n            this.eventListeners[event] = this.eventListeners[event] || [];\n            push.call(this.eventListeners[event], listener);\n        },\n\n        removeEventListener: function removeEventListener(event, listener, useCapture) {\n            var listeners = this.eventListeners && this.eventListeners[event] || [];\n\n            for (var i = 0, l = listeners.length; i < l; ++i) {\n                if (listeners[i] == listener) {\n                    return listeners.splice(i, 1);\n                }\n            }\n        },\n\n        dispatchEvent: function dispatchEvent(event) {\n            var type = event.type;\n            var listeners = this.eventListeners && this.eventListeners[type] || [];\n\n            for (var i = 0; i < listeners.length; i++) {\n                if (typeof listeners[i] == \"function\") {\n                    listeners[i].call(this, event);\n                } else {\n                    listeners[i].handleEvent(event);\n                }\n            }\n\n            return !!event.defaultPrevented;\n        }\n    };\n}());\n\n/**\n * @depend event.js\n */\n/*jslint eqeqeq: false, onevar: false*/\n/*global sinon, module, require, ActiveXObject, XMLHttpRequest, DOMParser*/\n/**\n * Fake XMLHttpRequest object\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    this.sinon = {};\n}\nsinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };\n\n// wrapper for global\n(function(global) {\n    var xhr = sinon.xhr;\n    xhr.GlobalXMLHttpRequest = global.XMLHttpRequest;\n    xhr.GlobalActiveXObject = global.ActiveXObject;\n    xhr.supportsActiveX = typeof xhr.GlobalActiveXObject != \"undefined\";\n    xhr.supportsXHR = typeof xhr.GlobalXMLHttpRequest != \"undefined\";\n    xhr.workingXHR = xhr.supportsXHR ? xhr.GlobalXMLHttpRequest : xhr.supportsActiveX\n                                     ? function() { return new xhr.GlobalActiveXObject(\"MSXML2.XMLHTTP.3.0\") } : false;\n\n    /*jsl:ignore*/\n    var unsafeHeaders = {\n        \"Accept-Charset\": true,\n        \"Accept-Encoding\": true,\n        \"Connection\": true,\n        \"Content-Length\": true,\n        \"Cookie\": true,\n        \"Cookie2\": true,\n        \"Content-Transfer-Encoding\": true,\n        \"Date\": true,\n        \"Expect\": true,\n        \"Host\": true,\n        \"Keep-Alive\": true,\n        \"Referer\": true,\n        \"TE\": true,\n        \"Trailer\": true,\n        \"Transfer-Encoding\": true,\n        \"Upgrade\": true,\n        \"User-Agent\": true,\n        \"Via\": true\n    };\n    /*jsl:end*/\n\n    function FakeXMLHttpRequest() {\n        this.readyState = FakeXMLHttpRequest.UNSENT;\n        this.requestHeaders = {};\n        this.requestBody = null;\n        this.status = 0;\n        this.statusText = \"\";\n\n        if (typeof FakeXMLHttpRequest.onCreate == \"function\") {\n            FakeXMLHttpRequest.onCreate(this);\n        }\n    }\n\n    function verifyState(xhr) {\n        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n\n        if (xhr.sendFlag) {\n            throw new Error(\"INVALID_STATE_ERR\");\n        }\n    }\n\n    // filtering to enable a white-list version of Sinon FakeXhr,\n    // where whitelisted requests are passed through to real XHR\n    function each(collection, callback) {\n        if (!collection) return;\n        for (var i = 0, l = collection.length; i < l; i += 1) {\n            callback(collection[i]);\n        }\n    }\n    function some(collection, callback) {\n        for (var index = 0; index < collection.length; index++) {\n            if(callback(collection[index]) === true) return true;\n        };\n        return false;\n    }\n    // largest arity in XHR is 5 - XHR#open\n    var apply = function(obj,method,args) {\n        switch(args.length) {\n        case 0: return obj[method]();\n        case 1: return obj[method](args[0]);\n        case 2: return obj[method](args[0],args[1]);\n        case 3: return obj[method](args[0],args[1],args[2]);\n        case 4: return obj[method](args[0],args[1],args[2],args[3]);\n        case 5: return obj[method](args[0],args[1],args[2],args[3],args[4]);\n        };\n    };\n\n    FakeXMLHttpRequest.filters = [];\n    FakeXMLHttpRequest.addFilter = function(fn) {\n        this.filters.push(fn)\n    };\n    var IE6Re = /MSIE 6/;\n    FakeXMLHttpRequest.defake = function(fakeXhr,xhrArgs) {\n        var xhr = new sinon.xhr.workingXHR();\n        each([\"open\",\"setRequestHeader\",\"send\",\"abort\",\"getResponseHeader\",\n              \"getAllResponseHeaders\",\"addEventListener\",\"overrideMimeType\",\"removeEventListener\"],\n             function(method) {\n                 fakeXhr[method] = function() {\n                   return apply(xhr,method,arguments);\n                 };\n             });\n\n        var copyAttrs = function(args) {\n            each(args, function(attr) {\n              try {\n                fakeXhr[attr] = xhr[attr]\n              } catch(e) {\n                if(!IE6Re.test(navigator.userAgent)) throw e;\n              }\n            });\n        };\n\n        var stateChange = function() {\n            fakeXhr.readyState = xhr.readyState;\n            if(xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                copyAttrs([\"status\",\"statusText\"]);\n            }\n            if(xhr.readyState >= FakeXMLHttpRequest.LOADING) {\n                copyAttrs([\"responseText\"]);\n            }\n            if(xhr.readyState === FakeXMLHttpRequest.DONE) {\n                copyAttrs([\"responseXML\"]);\n            }\n            if(fakeXhr.onreadystatechange) fakeXhr.onreadystatechange.call(fakeXhr);\n        };\n        if(xhr.addEventListener) {\n          for(var event in fakeXhr.eventListeners) {\n              if(fakeXhr.eventListeners.hasOwnProperty(event)) {\n                  each(fakeXhr.eventListeners[event],function(handler) {\n                      xhr.addEventListener(event, handler);\n                  });\n              }\n          }\n          xhr.addEventListener(\"readystatechange\",stateChange);\n        } else {\n          xhr.onreadystatechange = stateChange;\n        }\n        apply(xhr,\"open\",xhrArgs);\n    };\n    FakeXMLHttpRequest.useFilters = false;\n\n    function verifyRequestSent(xhr) {\n        if (xhr.readyState == FakeXMLHttpRequest.DONE) {\n            throw new Error(\"Request done\");\n        }\n    }\n\n    function verifyHeadersReceived(xhr) {\n        if (xhr.async && xhr.readyState != FakeXMLHttpRequest.HEADERS_RECEIVED) {\n            throw new Error(\"No headers received\");\n        }\n    }\n\n    function verifyResponseBodyType(body) {\n        if (typeof body != \"string\") {\n            var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\n                                 body + \", which is not a string.\");\n            error.name = \"InvalidBodyException\";\n            throw error;\n        }\n    }\n\n    sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {\n        async: true,\n\n        open: function open(method, url, async, username, password) {\n            this.method = method;\n            this.url = url;\n            this.async = typeof async == \"boolean\" ? async : true;\n            this.username = username;\n            this.password = password;\n            this.responseText = null;\n            this.responseXML = null;\n            this.requestHeaders = {};\n            this.sendFlag = false;\n            if(sinon.FakeXMLHttpRequest.useFilters === true) {\n                var xhrArgs = arguments;\n                var defake = some(FakeXMLHttpRequest.filters,function(filter) {\n                    return filter.apply(this,xhrArgs)\n                });\n                if (defake) {\n                  return sinon.FakeXMLHttpRequest.defake(this,arguments);\n                }\n            }\n            this.readyStateChange(FakeXMLHttpRequest.OPENED);\n        },\n\n        readyStateChange: function readyStateChange(state) {\n            this.readyState = state;\n\n            if (typeof this.onreadystatechange == \"function\") {\n                try {\n                    this.onreadystatechange();\n                } catch (e) {\n                    sinon.logError(\"Fake XHR onreadystatechange handler\", e);\n                }\n            }\n\n            this.dispatchEvent(new sinon.Event(\"readystatechange\"));\n        },\n\n        setRequestHeader: function setRequestHeader(header, value) {\n            verifyState(this);\n\n            if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\n                throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n            }\n\n            if (this.requestHeaders[header]) {\n                this.requestHeaders[header] += \",\" + value;\n            } else {\n                this.requestHeaders[header] = value;\n            }\n        },\n\n        // Helps testing\n        setResponseHeaders: function setResponseHeaders(headers) {\n            this.responseHeaders = {};\n\n            for (var header in headers) {\n                if (headers.hasOwnProperty(header)) {\n                    this.responseHeaders[header] = headers[header];\n                }\n            }\n\n            if (this.async) {\n                this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n            }\n        },\n\n        // Currently treats ALL data as a DOMString (i.e. no Document)\n        send: function send(data) {\n            verifyState(this);\n\n            if (!/^(get|head)$/i.test(this.method)) {\n                if (this.requestHeaders[\"Content-Type\"]) {\n                    var value = this.requestHeaders[\"Content-Type\"].split(\";\");\n                    this.requestHeaders[\"Content-Type\"] = value[0] + \";charset=utf-8\";\n                } else {\n                    this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=utf-8\";\n                }\n\n                this.requestBody = data;\n            }\n\n            this.errorFlag = false;\n            this.sendFlag = this.async;\n            this.readyStateChange(FakeXMLHttpRequest.OPENED);\n\n            if (typeof this.onSend == \"function\") {\n                this.onSend(this);\n            }\n        },\n\n        abort: function abort() {\n            this.aborted = true;\n            this.responseText = null;\n            this.errorFlag = true;\n            this.requestHeaders = {};\n\n            if (this.readyState > sinon.FakeXMLHttpRequest.UNSENT && this.sendFlag) {\n                this.readyStateChange(sinon.FakeXMLHttpRequest.DONE);\n                this.sendFlag = false;\n            }\n\n            this.readyState = sinon.FakeXMLHttpRequest.UNSENT;\n        },\n\n        getResponseHeader: function getResponseHeader(header) {\n            if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                return null;\n            }\n\n            if (/^Set-Cookie2?$/i.test(header)) {\n                return null;\n            }\n\n            header = header.toLowerCase();\n\n            for (var h in this.responseHeaders) {\n                if (h.toLowerCase() == header) {\n                    return this.responseHeaders[h];\n                }\n            }\n\n            return null;\n        },\n\n        getAllResponseHeaders: function getAllResponseHeaders() {\n            if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n                return \"\";\n            }\n\n            var headers = \"\";\n\n            for (var header in this.responseHeaders) {\n                if (this.responseHeaders.hasOwnProperty(header) &&\n                    !/^Set-Cookie2?$/i.test(header)) {\n                    headers += header + \": \" + this.responseHeaders[header] + \"\\r\\n\";\n                }\n            }\n\n            return headers;\n        },\n\n        setResponseBody: function setResponseBody(body) {\n            verifyRequestSent(this);\n            verifyHeadersReceived(this);\n            verifyResponseBodyType(body);\n\n            var chunkSize = this.chunkSize || 10;\n            var index = 0;\n            this.responseText = \"\";\n\n            do {\n                if (this.async) {\n                    this.readyStateChange(FakeXMLHttpRequest.LOADING);\n                }\n\n                this.responseText += body.substring(index, index + chunkSize);\n                index += chunkSize;\n            } while (index < body.length);\n\n            var type = this.getResponseHeader(\"Content-Type\");\n\n            if (this.responseText &&\n                (!type || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(type))) {\n                try {\n                    this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);\n                } catch (e) {\n                    // Unable to parse XML - no biggie\n                }\n            }\n\n            if (this.async) {\n                this.readyStateChange(FakeXMLHttpRequest.DONE);\n            } else {\n                this.readyState = FakeXMLHttpRequest.DONE;\n            }\n        },\n\n        respond: function respond(status, headers, body) {\n            this.setResponseHeaders(headers || {});\n            this.status = typeof status == \"number\" ? status : 200;\n            this.statusText = FakeXMLHttpRequest.statusCodes[this.status];\n            this.setResponseBody(body || \"\");\n        }\n    });\n\n    sinon.extend(FakeXMLHttpRequest, {\n        UNSENT: 0,\n        OPENED: 1,\n        HEADERS_RECEIVED: 2,\n        LOADING: 3,\n        DONE: 4\n    });\n\n    // Borrowed from JSpec\n    FakeXMLHttpRequest.parseXML = function parseXML(text) {\n        var xmlDoc;\n\n        if (typeof DOMParser != \"undefined\") {\n            var parser = new DOMParser();\n            xmlDoc = parser.parseFromString(text, \"text/xml\");\n        } else {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = \"false\";\n            xmlDoc.loadXML(text);\n        }\n\n        return xmlDoc;\n    };\n\n    FakeXMLHttpRequest.statusCodes = {\n        100: \"Continue\",\n        101: \"Switching Protocols\",\n        200: \"OK\",\n        201: \"Created\",\n        202: \"Accepted\",\n        203: \"Non-Authoritative Information\",\n        204: \"No Content\",\n        205: \"Reset Content\",\n        206: \"Partial Content\",\n        300: \"Multiple Choice\",\n        301: \"Moved Permanently\",\n        302: \"Found\",\n        303: \"See Other\",\n        304: \"Not Modified\",\n        305: \"Use Proxy\",\n        307: \"Temporary Redirect\",\n        400: \"Bad Request\",\n        401: \"Unauthorized\",\n        402: \"Payment Required\",\n        403: \"Forbidden\",\n        404: \"Not Found\",\n        405: \"Method Not Allowed\",\n        406: \"Not Acceptable\",\n        407: \"Proxy Authentication Required\",\n        408: \"Request Timeout\",\n        409: \"Conflict\",\n        410: \"Gone\",\n        411: \"Length Required\",\n        412: \"Precondition Failed\",\n        413: \"Request Entity Too Large\",\n        414: \"Request-URI Too Long\",\n        415: \"Unsupported Media Type\",\n        416: \"Requested Range Not Satisfiable\",\n        417: \"Expectation Failed\",\n        422: \"Unprocessable Entity\",\n        500: \"Internal Server Error\",\n        501: \"Not Implemented\",\n        502: \"Bad Gateway\",\n        503: \"Service Unavailable\",\n        504: \"Gateway Timeout\",\n        505: \"HTTP Version Not Supported\"\n    };\n\n    sinon.useFakeXMLHttpRequest = function () {\n        sinon.FakeXMLHttpRequest.restore = function restore(keepOnCreate) {\n            if (xhr.supportsXHR) {\n                global.XMLHttpRequest = xhr.GlobalXMLHttpRequest;\n            }\n\n            if (xhr.supportsActiveX) {\n                global.ActiveXObject = xhr.GlobalActiveXObject;\n            }\n\n            delete sinon.FakeXMLHttpRequest.restore;\n\n            if (keepOnCreate !== true) {\n                delete sinon.FakeXMLHttpRequest.onCreate;\n            }\n        };\n        if (xhr.supportsXHR) {\n            global.XMLHttpRequest = sinon.FakeXMLHttpRequest;\n        }\n\n        if (xhr.supportsActiveX) {\n            global.ActiveXObject = function ActiveXObject(objId) {\n                if (objId == \"Microsoft.XMLHTTP\" || /^Msxml2\\.XMLHTTP/i.test(objId)) {\n\n                    return new sinon.FakeXMLHttpRequest();\n                }\n\n                return new xhr.GlobalActiveXObject(objId);\n            };\n        }\n\n        return sinon.FakeXMLHttpRequest;\n    };\n\n    sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;\n})(this);\n\nif (typeof module == \"object\" && typeof require == \"function\") {\n    module.exports = sinon;\n}\n\n/**\n * @depend fake_xml_http_request.js\n */\n/*jslint eqeqeq: false, onevar: false, regexp: false, plusplus: false*/\n/*global module, require, window*/\n/**\n * The Sinon \"server\" mimics a web server that receives requests from\n * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,\n * both synchronously and asynchronously. To respond synchronuously, canned\n * answers have to be provided upfront.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\nif (typeof sinon == \"undefined\") {\n    var sinon = {};\n}\n\nsinon.fakeServer = (function () {\n    var push = [].push;\n    function F() {}\n\n    function create(proto) {\n        F.prototype = proto;\n        return new F();\n    }\n\n    function responseArray(handler) {\n        var response = handler;\n\n        if (Object.prototype.toString.call(handler) != \"[object Array]\") {\n            response = [200, {}, handler];\n        }\n\n        if (typeof response[2] != \"string\") {\n            throw new TypeError(\"Fake server response body should be string, but was \" +\n                                typeof response[2]);\n        }\n\n        return response;\n    }\n\n    var wloc = window.location;\n    var rCurrLoc = new RegExp(\"^\" + wloc.protocol + \"//\" + wloc.host);\n\n    function matchOne(response, reqMethod, reqUrl) {\n        var rmeth = response.method;\n        var matchMethod = !rmeth || rmeth.toLowerCase() == reqMethod.toLowerCase();\n        var url = response.url;\n        var matchUrl = !url || url == reqUrl || (typeof url.test == \"function\" && url.test(reqUrl));\n\n        return matchMethod && matchUrl;\n    }\n\n    function match(response, request) {\n        var requestMethod = this.getHTTPMethod(request);\n        var requestUrl = request.url;\n\n        if (!/^https?:\\/\\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {\n            requestUrl = requestUrl.replace(rCurrLoc, \"\");\n        }\n\n        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {\n            if (typeof response.response == \"function\") {\n                var ru = response.url;\n                var args = [request].concat(!ru ? [] : requestUrl.match(ru).slice(1));\n                return response.response.apply(response, args);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    return {\n        create: function () {\n            var server = create(this);\n            this.xhr = sinon.useFakeXMLHttpRequest();\n            server.requests = [];\n\n            this.xhr.onCreate = function (xhrObj) {\n                server.addRequest(xhrObj);\n            };\n\n            return server;\n        },\n\n        addRequest: function addRequest(xhrObj) {\n            var server = this;\n            push.call(this.requests, xhrObj);\n\n            xhrObj.onSend = function () {\n                server.handleRequest(this);\n            };\n\n            if (this.autoRespond && !this.responding) {\n                setTimeout(function () {\n                    server.responding = false;\n                    server.respond();\n                }, this.autoRespondAfter || 10);\n\n                this.responding = true;\n            }\n        },\n\n        getHTTPMethod: function getHTTPMethod(request) {\n            if (this.fakeHTTPMethods && /post/i.test(request.method)) {\n                var matches = (request.requestBody || \"\").match(/_method=([^\\b;]+)/);\n                return !!matches ? matches[1] : request.method;\n            }\n\n            return request.method;\n        },\n\n        handleRequest: function handleRequest(xhr) {\n            if (xhr.async) {\n                if (!this.queue) {\n                    this.queue = [];\n                }\n\n                push.call(this.queue, xhr);\n            } else {\n                this.processRequest(xhr);\n            }\n        },\n\n        respondWith: function respondWith(method, url, body) {\n            if (arguments.length == 1 && typeof method != \"function\") {\n                this.response = responseArray(method);\n                return;\n            }\n\n            if (!this.responses) { this.responses = []; }\n\n            if (arguments.length == 1) {\n                body = method;\n                url = method = null;\n            }\n\n            if (arguments.length == 2) {\n                body = url;\n                url = method;\n                method = null;\n            }\n\n            push.call(this.responses, {\n                method: method,\n                url: url,\n                response: typeof body == \"function\" ? body : responseArray(body)\n            });\n        },\n\n        respond: function respond() {\n            if (arguments.length > 0) this.respondWith.apply(this, arguments);\n            var queue = this.queue || [];\n            var request;\n\n            while(request = queue.shift()) {\n                this.processRequest(request);\n            }\n        },\n\n        processRequest: function processRequest(request) {\n            try {\n                if (request.aborted) {\n                    return;\n                }\n\n                var response = this.response || [404, {}, \"\"];\n\n                if (this.responses) {\n                    for (var i = 0, l = this.responses.length; i < l; i++) {\n                        if (match.call(this, this.responses[i], request)) {\n                            response = this.responses[i].response;\n                            break;\n                        }\n                    }\n                }\n\n                if (request.readyState != 4) {\n                    request.respond(response[0], response[1], response[2]);\n                }\n            } catch (e) {\n                sinon.logError(\"Fake server request processing\", e);\n            }\n        },\n\n        restore: function restore() {\n            return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);\n        }\n    };\n}());\n\nif (typeof module == \"object\" && typeof require == \"function\") {\n    module.exports = sinon;\n}\n\n/**\n * @depend fake_server.js\n * @depend fake_timers.js\n */\n/*jslint browser: true, eqeqeq: false, onevar: false*/\n/*global sinon*/\n/**\n * Add-on for sinon.fakeServer that automatically handles a fake timer along with\n * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery\n * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,\n * it polls the object for completion with setInterval. Dispite the direct\n * motivation, there is nothing jQuery-specific in this file, so it can be used\n * in any environment where the ajax implementation depends on setInterval or\n * setTimeout.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function () {\n    function Server() {}\n    Server.prototype = sinon.fakeServer;\n\n    sinon.fakeServerWithClock = new Server();\n\n    sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {\n        if (xhr.async) {\n            if (typeof setTimeout.clock == \"object\") {\n                this.clock = setTimeout.clock;\n            } else {\n                this.clock = sinon.useFakeTimers();\n                this.resetClock = true;\n            }\n\n            if (!this.longestTimeout) {\n                var clockSetTimeout = this.clock.setTimeout;\n                var clockSetInterval = this.clock.setInterval;\n                var server = this;\n\n                this.clock.setTimeout = function (fn, timeout) {\n                    server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                    return clockSetTimeout.apply(this, arguments);\n                };\n\n                this.clock.setInterval = function (fn, timeout) {\n                    server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);\n\n                    return clockSetInterval.apply(this, arguments);\n                };\n            }\n        }\n\n        return sinon.fakeServer.addRequest.call(this, xhr);\n    };\n\n    sinon.fakeServerWithClock.respond = function respond() {\n        var returnVal = sinon.fakeServer.respond.apply(this, arguments);\n\n        if (this.clock) {\n            this.clock.tick(this.longestTimeout || 0);\n            this.longestTimeout = 0;\n\n            if (this.resetClock) {\n                this.clock.restore();\n                this.resetClock = false;\n            }\n        }\n\n        return returnVal;\n    };\n\n    sinon.fakeServerWithClock.restore = function restore() {\n        if (this.clock) {\n            this.clock.restore();\n        }\n\n        return sinon.fakeServer.restore.apply(this, arguments);\n    };\n}());\n\n/**\n * @depend ../sinon.js\n * @depend collection.js\n * @depend util/fake_timers.js\n * @depend util/fake_server_with_clock.js\n */\n/*jslint eqeqeq: false, onevar: false, plusplus: false*/\n/*global require, module*/\n/**\n * Manages fake collections as well as fake utilities such as Sinon's\n * timers and fake XHR implementation in one convenient object.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\nif (typeof module == \"object\" && typeof require == \"function\") {\n    var sinon = require(\"../sinon\");\n    sinon.extend(sinon, require(\"./util/fake_timers\"));\n}\n\n(function () {\n    var push = [].push;\n\n    function exposeValue(sandbox, config, key, value) {\n        if (!value) {\n            return;\n        }\n\n        if (config.injectInto) {\n            config.injectInto[key] = value;\n        } else {\n            push.call(sandbox.args, value);\n        }\n    }\n\n    function prepareSandboxFromConfig(config) {\n        var sandbox = sinon.create(sinon.sandbox);\n\n        if (config.useFakeServer) {\n            if (typeof config.useFakeServer == \"object\") {\n                sandbox.serverPrototype = config.useFakeServer;\n            }\n\n            sandbox.useFakeServer();\n        }\n\n        if (config.useFakeTimers) {\n            if (typeof config.useFakeTimers == \"object\") {\n                sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);\n            } else {\n                sandbox.useFakeTimers();\n            }\n        }\n\n        return sandbox;\n    }\n\n    sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {\n        useFakeTimers: function useFakeTimers() {\n            this.clock = sinon.useFakeTimers.apply(sinon, arguments);\n\n            return this.add(this.clock);\n        },\n\n        serverPrototype: sinon.fakeServer,\n\n        useFakeServer: function useFakeServer() {\n            var proto = this.serverPrototype || sinon.fakeServer;\n\n            if (!proto || !proto.create) {\n                return null;\n            }\n\n            this.server = proto.create();\n            return this.add(this.server);\n        },\n\n        inject: function (obj) {\n            sinon.collection.inject.call(this, obj);\n\n            if (this.clock) {\n                obj.clock = this.clock;\n            }\n\n            if (this.server) {\n                obj.server = this.server;\n                obj.requests = this.server.requests;\n            }\n\n            return obj;\n        },\n\n        create: function (config) {\n            if (!config) {\n                return sinon.create(sinon.sandbox);\n            }\n\n            var sandbox = prepareSandboxFromConfig(config);\n            sandbox.args = sandbox.args || [];\n            var prop, value, exposed = sandbox.inject({});\n\n            if (config.properties) {\n                for (var i = 0, l = config.properties.length; i < l; i++) {\n                    prop = config.properties[i];\n                    value = exposed[prop] || prop == \"sandbox\" && sandbox;\n                    exposeValue(sandbox, config, prop, value);\n                }\n            } else {\n                exposeValue(sandbox, config, \"sandbox\", value);\n            }\n\n            return sandbox;\n        }\n    });\n\n    sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;\n\n    if (typeof module == \"object\" && typeof require == \"function\") {\n        module.exports = sinon.sandbox;\n    }\n}());\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n * @depend mock.js\n * @depend sandbox.js\n */\n/*jslint eqeqeq: false, onevar: false, forin: true, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Test function, sandboxes fakes\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function test(callback) {\n        var type = typeof callback;\n\n        if (type != \"function\") {\n            throw new TypeError(\"sinon.test needs to wrap a test function, got \" + type);\n        }\n\n        return function () {\n            var config = sinon.getConfig(sinon.config);\n            config.injectInto = config.injectIntoThis && this || config.injectInto;\n            var sandbox = sinon.sandbox.create(config);\n            var exception, result;\n            var args = Array.prototype.slice.call(arguments).concat(sandbox.args);\n\n            try {\n                result = callback.apply(this, args);\n            } finally {\n                sandbox.verifyAndRestore();\n            }\n\n            return result;\n        };\n    }\n\n    test.config = {\n        injectIntoThis: true,\n        injectInto: null,\n        properties: [\"spy\", \"stub\", \"mock\", \"clock\", \"server\", \"requests\"],\n        useFakeTimers: true,\n        useFakeServer: true\n    };\n\n    if (commonJSModule) {\n        module.exports = test;\n    } else {\n        sinon.test = test;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend test.js\n */\n/*jslint eqeqeq: false, onevar: false, eqeqeq: false*/\n/*global module, require, sinon*/\n/**\n * Test case, sandboxes all test functions\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon || !Object.prototype.hasOwnProperty) {\n        return;\n    }\n\n    function createTest(property, setUp, tearDown) {\n        return function () {\n            if (setUp) {\n                setUp.apply(this, arguments);\n            }\n\n            var exception, result;\n\n            try {\n                result = property.apply(this, arguments);\n            } catch (e) {\n                exception = e;\n            }\n\n            if (tearDown) {\n                tearDown.apply(this, arguments);\n            }\n\n            if (exception) {\n                throw exception;\n            }\n\n            return result;\n        };\n    }\n\n    function testCase(tests, prefix) {\n        /*jsl:ignore*/\n        if (!tests || typeof tests != \"object\") {\n            throw new TypeError(\"sinon.testCase needs an object with test functions\");\n        }\n        /*jsl:end*/\n\n        prefix = prefix || \"test\";\n        var rPrefix = new RegExp(\"^\" + prefix);\n        var methods = {}, testName, property, method;\n        var setUp = tests.setUp;\n        var tearDown = tests.tearDown;\n\n        for (testName in tests) {\n            if (tests.hasOwnProperty(testName)) {\n                property = tests[testName];\n\n                if (/^(setUp|tearDown)$/.test(testName)) {\n                    continue;\n                }\n\n                if (typeof property == \"function\" && rPrefix.test(testName)) {\n                    method = property;\n\n                    if (setUp || tearDown) {\n                        method = createTest(property, setUp, tearDown);\n                    }\n\n                    methods[testName] = sinon.test(method);\n                } else {\n                    methods[testName] = tests[testName];\n                }\n            }\n        }\n\n        return methods;\n    }\n\n    if (commonJSModule) {\n        module.exports = testCase;\n    } else {\n        sinon.testCase = testCase;\n    }\n}(typeof sinon == \"object\" && sinon || null));\n\n/**\n * @depend ../sinon.js\n * @depend stub.js\n */\n/*jslint eqeqeq: false, onevar: false, nomen: false, plusplus: false*/\n/*global module, require, sinon*/\n/**\n * Assertions matching the test spy retrieval interface.\n *\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2010-2011 Christian Johansen\n */\n\n(function (sinon, global) {\n    var commonJSModule = typeof module == \"object\" && typeof require == \"function\";\n    var slice = Array.prototype.slice;\n    var assert;\n\n    if (!sinon && commonJSModule) {\n        sinon = require(\"../sinon\");\n    }\n\n    if (!sinon) {\n        return;\n    }\n\n    function verifyIsStub() {\n        var method;\n\n        for (var i = 0, l = arguments.length; i < l; ++i) {\n            method = arguments[i];\n\n            if (!method) {\n                assert.fail(\"fake is not a spy\");\n            }\n\n            if (typeof method != \"function\") {\n                assert.fail(method + \" is not a function\");\n            }\n\n            if (typeof method.getCall != \"function\") {\n                assert.fail(method + \" is not stubbed\");\n            }\n        }\n    }\n\n    function failAssertion(object, msg) {\n        object = object || global;\n        var failMethod = object.fail || assert.fail;\n        failMethod.call(object, msg);\n    }\n\n    function mirrorPropAsAssertion(name, method, message) {\n        if (arguments.length == 2) {\n            message = method;\n            method = name;\n        }\n\n        assert[name] = function (fake) {\n            verifyIsStub(fake);\n\n            var args = slice.call(arguments, 1);\n            var failed = false;\n\n            if (typeof method == \"function\") {\n                failed = !method(fake);\n            } else {\n                failed = typeof fake[method] == \"function\" ?\n                    !fake[method].apply(fake, args) : !fake[method];\n            }\n\n            if (failed) {\n                failAssertion(this, fake.printf.apply(fake, [message].concat(args)));\n            } else {\n                assert.pass(name);\n            }\n        };\n    }\n\n    function exposedName(prefix, prop) {\n        return !prefix || /^fail/.test(prop) ? prop :\n            prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);\n    };\n\n    assert = {\n        failException: \"AssertError\",\n\n        fail: function fail(message) {\n            var error = new Error(message);\n            error.name = this.failException || assert.failException;\n\n            throw error;\n        },\n\n        pass: function pass(assertion) {},\n\n        callOrder: function assertCallOrder() {\n            verifyIsStub.apply(null, arguments);\n            var expected = \"\", actual = \"\";\n\n            if (!sinon.calledInOrder(arguments)) {\n                try {\n                    expected = [].join.call(arguments, \", \");\n                    actual = sinon.orderByFirstCall(slice.call(arguments)).join(\", \");\n                } catch (e) {\n                    // If this fails, we'll just fall back to the blank string\n                }\n\n                failAssertion(this, \"expected \" + expected + \" to be \" +\n                              \"called in order but were called as \" + actual);\n            } else {\n                assert.pass(\"callOrder\");\n            }\n        },\n\n        callCount: function assertCallCount(method, count) {\n            verifyIsStub(method);\n\n            if (method.callCount != count) {\n                var msg = \"expected %n to be called \" + sinon.timesInWords(count) +\n                    \" but was called %c%C\";\n                failAssertion(this, method.printf(msg));\n            } else {\n                assert.pass(\"callCount\");\n            }\n        },\n\n        expose: function expose(target, options) {\n            if (!target) {\n                throw new TypeError(\"target is null or undefined\");\n            }\n\n            var o = options || {};\n            var prefix = typeof o.prefix == \"undefined\" && \"assert\" || o.prefix;\n            var includeFail = typeof o.includeFail == \"undefined\" || !!o.includeFail;\n\n            for (var method in this) {\n                if (method != \"export\" && (includeFail || !/^(fail)/.test(method))) {\n                    target[exposedName(prefix, method)] = this[method];\n                }\n            }\n\n            return target;\n        }\n    };\n\n    mirrorPropAsAssertion(\"called\", \"expected %n to have been called at least once but was never called\");\n    mirrorPropAsAssertion(\"notCalled\", function (spy) { return !spy.called; },\n                          \"expected %n to not have been called but was called %c%C\");\n    mirrorPropAsAssertion(\"calledOnce\", \"expected %n to be called once but was called %c%C\");\n    mirrorPropAsAssertion(\"calledTwice\", \"expected %n to be called twice but was called %c%C\");\n    mirrorPropAsAssertion(\"calledThrice\", \"expected %n to be called thrice but was called %c%C\");\n    mirrorPropAsAssertion(\"calledOn\", \"expected %n to be called with %1 as this but was called with %t\");\n    mirrorPropAsAssertion(\"alwaysCalledOn\", \"expected %n to always be called with %1 as this but was called with %t\");\n    mirrorPropAsAssertion(\"calledWith\", \"expected %n to be called with arguments %*%C\");\n    mirrorPropAsAssertion(\"alwaysCalledWith\", \"expected %n to always be called with arguments %*%C\");\n    mirrorPropAsAssertion(\"calledWithExactly\", \"expected %n to be called with exact arguments %*%C\");\n    mirrorPropAsAssertion(\"alwaysCalledWithExactly\", \"expected %n to always be called with exact arguments %*%C\");\n    mirrorPropAsAssertion(\"neverCalledWith\", \"expected %n to never be called with arguments %*%C\");\n    mirrorPropAsAssertion(\"threw\", \"%n did not throw exception%C\");\n    mirrorPropAsAssertion(\"alwaysThrew\", \"%n did not always throw exception%C\");\n\n    if (commonJSModule) {\n        module.exports = assert;\n    } else {\n        sinon.assert = assert;\n    }\n}(typeof sinon == \"object\" && sinon || null, typeof window != \"undefined\" ? window : global));\n\nreturn sinon;}.call(typeof window != 'undefined' && window || {}));\n\n})();\n//@ sourceURL=sinon");